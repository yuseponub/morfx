---
phase: 10.1-task-notes-history
plan: 02
type: execute
wave: 2
depends_on: ["10.1-01"]
files_modified:
  - src/app/actions/task-notes.ts
  - src/app/actions/task-activity.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can create notes on a task"
    - "User can update and delete their own notes"
    - "User can fetch activity history for a task"
    - "Activity records include user profile info"
  artifacts:
    - path: "src/app/actions/task-notes.ts"
      provides: "CRUD operations for task notes"
      exports: ["getTaskNotes", "createTaskNote", "updateTaskNote", "deleteTaskNote"]
    - path: "src/app/actions/task-activity.ts"
      provides: "Fetch and format task activity"
      exports: ["getTaskActivity", "formatTaskChanges", "getTaskActionDescription"]
  key_links:
    - from: "src/app/actions/task-notes.ts"
      to: "task_notes table"
      via: "Supabase client insert/update/delete"
      pattern: "supabase.*from.*task_notes"
    - from: "src/app/actions/task-notes.ts"
      to: "task_activity table"
      via: "Insert activity for note_added/updated/deleted"
      pattern: "action.*note_added"
    - from: "src/app/actions/task-activity.ts"
      to: "task_activity table"
      via: "Supabase client select with profile join"
      pattern: "supabase.*from.*task_activity"
---

<objective>
Create Server Actions for task notes CRUD and activity fetching.

Purpose: Provide the data layer for notes and activity UI components. Notes follow the contact_notes pattern with author-based permissions. Activity follows the contact_activity pattern with user profile lookup.

Output: Two server action files providing full CRUD for notes and read operations for activity.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10.1-task-notes-history/10.1-RESEARCH.md
@.planning/phases/10.1-task-notes-history/10.1-01-SUMMARY.md

# Key reference files - follow these patterns exactly
@src/app/actions/notes.ts
@src/app/actions/activity.ts
@src/lib/tasks/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create task notes Server Actions</name>
  <files>src/app/actions/task-notes.ts</files>
  <action>
Create new file `src/app/actions/task-notes.ts` following the exact pattern from `src/app/actions/notes.ts`:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { cookies } from 'next/headers'
import type { TaskNoteWithUser } from '@/lib/tasks/types'

// ============================================================================
// Helper Types
// ============================================================================

type ActionResult<T = void> =
  | { success: true; data: T }
  | { error: string }
```

Implement these functions mirroring notes.ts:

1. **getTaskNotes(taskId: string): Promise<TaskNoteWithUser[]>**
   - Auth check (return [] if not authenticated)
   - Query task_notes where task_id = taskId, order by created_at DESC
   - Fetch user profiles separately using user_id array
   - Map notes with user info
   - Return empty array on error

2. **createTaskNote(taskId: string, content: string): Promise<ActionResult<TaskNoteWithUser>>**
   - Auth check
   - Validate content (trim, check not empty)
   - Get workspace_id from cookie
   - Insert note with task_id, workspace_id, user_id, content
   - **Log activity:** Insert into task_activity with action='note_added', metadata={preview: content.substring(0, 100)}
   - Fetch user profile for response
   - revalidatePath('/tareas')
   - Return { success: true, data: note with user }

3. **updateTaskNote(noteId: string, content: string): Promise<ActionResult<void>>**
   - Auth check
   - Validate content
   - Fetch note to check permissions (get task_id for activity)
   - Check if user is author OR admin/owner (same pattern as notes.ts)
   - Update note content
   - Log activity with action='note_updated'
   - revalidatePath('/tareas')

4. **deleteTaskNote(noteId: string): Promise<ActionResult<void>>**
   - Auth check
   - Fetch note to check permissions and get content preview
   - Check author OR admin/owner
   - Log activity BEFORE delete with action='note_deleted'
   - Delete note
   - revalidatePath('/tareas')

**CRITICAL patterns from notes.ts to follow:**
- Error handling: Return { error: string } instead of throwing
- Profile lookup: Separate query to profiles table, build Map for lookup
- Activity logging: Insert directly, don't rely on trigger for note actions
- Permission check: Author or (admin/owner via workspace_members role check)
- Always revalidatePath('/tareas') after mutations
  </action>
  <verify>
```bash
# Check file structure
grep -E "(export async function|getTaskNotes|createTaskNote|updateTaskNote|deleteTaskNote)" /mnt/c/Users/Usuario/Proyectos/morfx-new/src/app/actions/task-notes.ts
# Verify imports
head -15 /mnt/c/Users/Usuario/Proyectos/morfx-new/src/app/actions/task-notes.ts
# TypeScript check
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && pnpm tsc --noEmit --skipLibCheck 2>&1 | head -20
```
  </verify>
  <done>
src/app/actions/task-notes.ts exists with:
- getTaskNotes function fetching notes with user profiles
- createTaskNote with activity logging
- updateTaskNote with permission checks and activity
- deleteTaskNote with permission checks and activity
- Follows notes.ts pattern exactly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create task activity Server Actions</name>
  <files>src/app/actions/task-activity.ts</files>
  <action>
Create new file `src/app/actions/task-activity.ts` following the exact pattern from `src/app/actions/activity.ts`:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import type { TaskActivityWithUser } from '@/lib/tasks/types'

// ============================================================================
// Types
// ============================================================================

interface GetActivityOptions {
  /** Filter by specific action types */
  types?: string[]
  /** Maximum number of records to return (default: 50) */
  limit?: number
}
```

Implement these functions:

1. **getTaskActivity(taskId: string, options?: GetActivityOptions): Promise<TaskActivityWithUser[]>**
   - Auth check (return [] if not authenticated)
   - Build query: from task_activity, where task_id = taskId
   - Optional filter by action types using .in('action', types)
   - Order by created_at DESC
   - Limit (default 50)
   - Fetch user profiles separately
   - Map activities with user info (null user for system actions)
   - Return empty array on error

2. **Formatting helpers (export for UI):**

```typescript
/** Field labels for displaying activity diffs in Spanish */
const FIELD_LABELS: Record<string, string> = {
  title: 'Titulo',
  description: 'Descripcion',
  due_date: 'Fecha limite',
  priority: 'Prioridad',
  status: 'Estado',
  task_type_id: 'Tipo de tarea',
  assigned_to: 'Asignado a',
  contact_id: 'Contacto',
  order_id: 'Pedido',
  conversation_id: 'Conversacion',
}

export async function getTaskFieldLabels(): Promise<Record<string, string>> {
  return FIELD_LABELS
}

function formatValueSync(value: unknown): string {
  if (value === null || value === undefined) return '(vacio)'
  if (typeof value === 'boolean') return value ? 'Si' : 'No'
  if (typeof value === 'object') return JSON.stringify(value)
  return String(value)
}

export async function formatTaskValue(value: unknown): Promise<string> {
  return formatValueSync(value)
}

export async function formatTaskChanges(
  changes: Record<string, { old: unknown; new: unknown }> | null
): Promise<string[]> {
  if (!changes) return []
  return Object.entries(changes)
    .filter(([key]) => !['updated_at', 'created_at'].includes(key))
    .map(([key, { old: oldVal, new: newVal }]) => {
      const fieldLabel = FIELD_LABELS[key] || key
      return `${fieldLabel}: ${formatValueSync(oldVal)} -> ${formatValueSync(newVal)}`
    })
}

export async function getTaskActionDescription(action: string): Promise<string> {
  const descriptions: Record<string, string> = {
    created: 'Tarea creada',
    updated: 'Tarea actualizada',
    completed: 'Tarea completada',
    reopened: 'Tarea reabierta',
    due_date_changed: 'Fecha limite cambiada',
    deleted: 'Tarea eliminada',
    note_added: 'Nota agregada',
    note_updated: 'Nota editada',
    note_deleted: 'Nota eliminada',
  }
  return descriptions[action] || action
}
```

**CRITICAL:** Follow activity.ts pattern exactly for profile lookup and error handling.
  </action>
  <verify>
```bash
# Check exports
grep -E "(export async function|getTaskActivity|formatTaskChanges|getTaskActionDescription)" /mnt/c/Users/Usuario/Proyectos/morfx-new/src/app/actions/task-activity.ts
# TypeScript check
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && pnpm tsc --noEmit --skipLibCheck 2>&1 | head -20
```
  </verify>
  <done>
src/app/actions/task-activity.ts exists with:
- getTaskActivity function with filtering and profile lookup
- formatTaskChanges for diff display
- getTaskActionDescription for Spanish labels
- formatTaskValue helper
- Follows activity.ts pattern exactly
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Both server action files exist
2. TypeScript compiles without errors
3. Both files follow existing patterns from notes.ts and activity.ts

```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && pnpm tsc --noEmit --skipLibCheck
```
</verification>

<success_criteria>
- getTaskNotes returns notes with user profiles
- createTaskNote logs note_added activity
- updateTaskNote checks permissions and logs note_updated
- deleteTaskNote checks permissions and logs note_deleted
- getTaskActivity returns activities with user profiles
- Formatting helpers provide Spanish labels
- All mutations call revalidatePath('/tareas')
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-task-notes-history/10.1-02-SUMMARY.md`
</output>
