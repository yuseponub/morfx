---
phase: 13-agent-engine-core
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/lib/agents/registry.ts
  - src/lib/agents/session-manager.ts
  - src/lib/agents/index.ts
autonomous: true

must_haves:
  truths:
    - "Multiple agents can be registered with different configurations"
    - "Sessions can be created with initial state"
    - "Session updates use optimistic locking to detect conflicts"
    - "Turns are recorded with proper turn numbering"
  artifacts:
    - path: "src/lib/agents/registry.ts"
      provides: "AgentRegistry class with register, get, list methods"
      exports: ["AgentRegistry", "agentRegistry"]
    - path: "src/lib/agents/session-manager.ts"
      provides: "SessionManager with CRUD operations and optimistic locking"
      exports: ["SessionManager"]
  key_links:
    - from: "src/lib/agents/session-manager.ts"
      to: "agent_sessions table"
      via: "Supabase client queries with version check"
      pattern: "\\.eq\\('version', expectedVersion\\)"
    - from: "src/lib/agents/registry.ts"
      to: "src/lib/agents/types.ts"
      via: "AgentConfig type import"
      pattern: "import.*AgentConfig"
---

<objective>
Create Agent Registry and Session Manager for state management.

Purpose: The registry enables multiple agent configurations (sales agent, support agent, etc.). The session manager handles all database operations with optimistic locking to prevent concurrent message processing from corrupting session state.

Output: AgentRegistry singleton for agent configuration, SessionManager class for session CRUD with version-based conflict detection.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-agent-engine-core/13-CONTEXT.md
@.planning/phases/13-agent-engine-core/13-RESEARCH.md
@.planning/phases/13-agent-engine-core/13-01-SUMMARY.md

# Types from Plan 01
@src/lib/agents/types.ts
@src/lib/agents/errors.ts

# Supabase client patterns
@src/lib/supabase/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Agent Registry</name>
  <files>src/lib/agents/registry.ts</files>
  <action>
Create the AgentRegistry class that manages agent configurations:

```typescript
/**
 * Agent Registry
 * Phase 13: Agent Engine Core
 *
 * Centralized registry for agent configurations.
 * Agents are registered at application startup and accessed by ID.
 */

import type { AgentConfig } from './types'
import { AgentNotFoundError } from './errors'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('agent-registry')

/**
 * Registry for managing agent configurations.
 *
 * Agents are code-defined (not database-stored) for simplicity.
 * Each agent has: ID, name, Claude model configs, available tools,
 * state machine definition, and confidence thresholds.
 *
 * @example
 * ```typescript
 * agentRegistry.register({
 *   id: 'somnio-sales',
 *   name: 'Somnio Sales Agent',
 *   // ... full config
 * })
 *
 * const agent = agentRegistry.get('somnio-sales')
 * ```
 */
export class AgentRegistry {
  private agents = new Map<string, AgentConfig>()

  /**
   * Register a new agent configuration.
   * Overwrites if agent with same ID already exists.
   */
  register(config: AgentConfig): void {
    // Validate required fields
    if (!config.id || !config.name) {
      throw new Error('Agent config must have id and name')
    }
    if (!config.intentDetector?.systemPrompt) {
      throw new Error('Agent config must have intentDetector.systemPrompt')
    }
    if (!config.orchestrator?.systemPrompt) {
      throw new Error('Agent config must have orchestrator.systemPrompt')
    }

    this.agents.set(config.id, config)
    logger.info({ agentId: config.id, name: config.name }, 'Agent registered')
  }

  /**
   * Get agent configuration by ID.
   * @throws AgentNotFoundError if agent doesn't exist
   */
  get(agentId: string): AgentConfig {
    const agent = this.agents.get(agentId)
    if (!agent) {
      throw new AgentNotFoundError(agentId)
    }
    return agent
  }

  /**
   * Check if agent exists in registry.
   */
  has(agentId: string): boolean {
    return this.agents.has(agentId)
  }

  /**
   * Get all registered agents.
   */
  list(): AgentConfig[] {
    return Array.from(this.agents.values())
  }

  /**
   * Get list of agent IDs.
   */
  listIds(): string[] {
    return Array.from(this.agents.keys())
  }

  /**
   * Unregister an agent (mainly for testing).
   */
  unregister(agentId: string): boolean {
    const deleted = this.agents.delete(agentId)
    if (deleted) {
      logger.info({ agentId }, 'Agent unregistered')
    }
    return deleted
  }

  /**
   * Clear all registrations (for testing).
   */
  clear(): void {
    this.agents.clear()
    logger.info('All agents cleared from registry')
  }

  /**
   * Get count of registered agents.
   */
  get size(): number {
    return this.agents.size
  }
}

/** Singleton instance of the agent registry */
export const agentRegistry = new AgentRegistry()
```

Key implementation notes:
- Uses Map for O(1) lookups by agent ID
- Validates required config fields on registration
- Throws AgentNotFoundError for missing agents (not undefined return)
- Provides list/listIds for discovering available agents
- Singleton pattern for application-wide access
- Logging for observability
  </action>
  <verify>
TypeScript compilation:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/registry.ts
```
Check exports:
```bash
grep -E "^export" src/lib/agents/registry.ts
```
Should export AgentRegistry class and agentRegistry singleton.
  </verify>
  <done>
- AgentRegistry class with register, get, has, list, listIds, unregister, clear methods
- Validation on registration for required fields
- AgentNotFoundError thrown for missing agents
- Singleton agentRegistry exported for application-wide use
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Session Manager with Optimistic Locking</name>
  <files>
src/lib/agents/session-manager.ts
src/lib/agents/index.ts
  </files>
  <action>
Create SessionManager class that handles all session database operations:

```typescript
/**
 * Session Manager
 * Phase 13: Agent Engine Core
 *
 * Handles session CRUD operations with optimistic locking.
 * All database operations use admin client to bypass RLS
 * (workspace isolation enforced via explicit workspace_id filters).
 */

import { createAdminClient } from '@/lib/supabase/admin'
import type {
  AgentSession,
  AgentSessionWithState,
  AgentTurn,
  SessionState,
  TurnRole,
  TurnToolCall,
} from './types'
import {
  VersionConflictError,
  SessionError,
  SessionNotFoundError,
} from './errors'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('session-manager')

/** Parameters for creating a new session */
export interface CreateSessionParams {
  agentId: string
  conversationId: string
  contactId: string
  workspaceId: string
  initialMode?: string
  initialState?: Partial<SessionState>
}

/** Parameters for adding a turn */
export interface AddTurnParams {
  sessionId: string
  turnNumber: number
  role: TurnRole
  content: string
  intentDetected?: string | null
  confidence?: number | null
  toolsCalled?: TurnToolCall[]
  tokensUsed?: number
}

/** Parameters for updating session with version check */
export interface UpdateSessionParams {
  currentMode?: string
  status?: AgentSession['status']
  lastActivityAt?: string
}

/**
 * Manages agent sessions in the database.
 *
 * Uses optimistic locking via version column:
 * 1. Read session with current version
 * 2. Make changes in memory
 * 3. Write back with version check
 * 4. If version mismatch, throw VersionConflictError
 *
 * Caller should catch VersionConflictError and retry with fresh data.
 */
export class SessionManager {
  private supabase = createAdminClient()

  // ============================================================================
  // Session CRUD
  // ============================================================================

  /**
   * Create a new session for a conversation.
   * Also creates the associated session_state record.
   */
  async createSession(params: CreateSessionParams): Promise<AgentSessionWithState> {
    logger.info(
      { agentId: params.agentId, conversationId: params.conversationId },
      'Creating new session'
    )

    // Insert session
    const { data: session, error: sessionError } = await this.supabase
      .from('agent_sessions')
      .insert({
        agent_id: params.agentId,
        conversation_id: params.conversationId,
        contact_id: params.contactId,
        workspace_id: params.workspaceId,
        version: 1,
        status: 'active',
        current_mode: params.initialMode ?? 'conversacion',
      })
      .select()
      .single()

    if (sessionError) {
      logger.error({ error: sessionError }, 'Failed to create session')
      throw new SessionError('Failed to create session', undefined, sessionError)
    }

    // Initialize session state
    const initialState: SessionState = {
      intents_vistos: [],
      templates_enviados: [],
      datos_capturados: {},
      pack_seleccionado: null,
      ...params.initialState,
    }

    const { error: stateError } = await this.supabase
      .from('session_state')
      .insert({
        session_id: session.id,
        ...initialState,
      })

    if (stateError) {
      // Rollback session if state creation fails
      await this.supabase.from('agent_sessions').delete().eq('id', session.id)
      logger.error({ error: stateError }, 'Failed to create session state')
      throw new SessionError('Failed to create session state', session.id, stateError)
    }

    logger.info({ sessionId: session.id }, 'Session created successfully')

    return {
      ...session,
      state: initialState,
    }
  }

  /**
   * Get session by ID with state.
   * @throws SessionNotFoundError if session doesn't exist
   */
  async getSession(sessionId: string): Promise<AgentSessionWithState> {
    const { data: session, error } = await this.supabase
      .from('agent_sessions')
      .select('*')
      .eq('id', sessionId)
      .single()

    if (error || !session) {
      throw new SessionNotFoundError(sessionId)
    }

    const state = await this.getState(sessionId)

    return {
      ...session,
      state,
    }
  }

  /**
   * Get session by conversation ID (if exists).
   * Returns null if no session exists for the conversation.
   */
  async getSessionByConversation(
    conversationId: string,
    agentId: string
  ): Promise<AgentSessionWithState | null> {
    const { data: session, error } = await this.supabase
      .from('agent_sessions')
      .select('*')
      .eq('conversation_id', conversationId)
      .eq('agent_id', agentId)
      .eq('status', 'active')
      .maybeSingle()

    if (error) {
      logger.error({ error, conversationId }, 'Error fetching session by conversation')
      throw new SessionError('Failed to fetch session', undefined, error)
    }

    if (!session) {
      return null
    }

    const state = await this.getState(session.id)

    return {
      ...session,
      state,
    }
  }

  /**
   * Update session with optimistic locking.
   * @throws VersionConflictError if version doesn't match
   */
  async updateSessionWithVersion(
    sessionId: string,
    expectedVersion: number,
    updates: UpdateSessionParams
  ): Promise<AgentSession> {
    const { data, error } = await this.supabase
      .from('agent_sessions')
      .update({
        ...(updates.currentMode !== undefined && { current_mode: updates.currentMode }),
        ...(updates.status !== undefined && { status: updates.status }),
        ...(updates.lastActivityAt !== undefined && { last_activity_at: updates.lastActivityAt }),
        version: expectedVersion + 1,
        updated_at: new Date().toISOString(),
      })
      .eq('id', sessionId)
      .eq('version', expectedVersion)
      .select()
      .single()

    // PGRST116 = no rows returned (version mismatch)
    if (error?.code === 'PGRST116' || !data) {
      logger.warn(
        { sessionId, expectedVersion },
        'Version conflict detected - session was modified concurrently'
      )
      throw new VersionConflictError(sessionId, expectedVersion)
    }

    if (error) {
      throw new SessionError('Failed to update session', sessionId, error)
    }

    logger.debug(
      { sessionId, newVersion: data.version },
      'Session updated successfully'
    )

    return data
  }

  /**
   * Close a session (set status to 'closed').
   */
  async closeSession(sessionId: string, expectedVersion: number): Promise<AgentSession> {
    return this.updateSessionWithVersion(sessionId, expectedVersion, {
      status: 'closed',
    })
  }

  /**
   * Hand off session to human.
   */
  async handoffSession(sessionId: string, expectedVersion: number): Promise<AgentSession> {
    return this.updateSessionWithVersion(sessionId, expectedVersion, {
      status: 'handed_off',
    })
  }

  // ============================================================================
  // State Operations
  // ============================================================================

  /**
   * Get session state.
   */
  async getState(sessionId: string): Promise<SessionState> {
    const { data, error } = await this.supabase
      .from('session_state')
      .select('*')
      .eq('session_id', sessionId)
      .single()

    if (error || !data) {
      // Return default state if not found (shouldn't happen normally)
      logger.warn({ sessionId }, 'Session state not found, returning default')
      return {
        intents_vistos: [],
        templates_enviados: [],
        datos_capturados: {},
        pack_seleccionado: null,
      }
    }

    return data as SessionState
  }

  /**
   * Update session state.
   */
  async updateState(sessionId: string, updates: Partial<SessionState>): Promise<SessionState> {
    const { data, error } = await this.supabase
      .from('session_state')
      .update({
        ...updates,
        updated_at: new Date().toISOString(),
      })
      .eq('session_id', sessionId)
      .select()
      .single()

    if (error) {
      throw new SessionError('Failed to update session state', sessionId, error)
    }

    return data as SessionState
  }

  /**
   * Add an intent to the intents_vistos array.
   */
  async addIntentSeen(sessionId: string, intent: string): Promise<void> {
    const state = await this.getState(sessionId)
    const orden = state.intents_vistos.length + 1
    const timestamp = new Date().toISOString()

    await this.updateState(sessionId, {
      intents_vistos: [
        ...state.intents_vistos,
        { intent, orden, timestamp },
      ],
    })
  }

  /**
   * Add a template to the templates_enviados array.
   */
  async addTemplateSent(sessionId: string, templateName: string): Promise<void> {
    const state = await this.getState(sessionId)

    await this.updateState(sessionId, {
      templates_enviados: [...state.templates_enviados, templateName],
    })
  }

  /**
   * Update captured data fields.
   */
  async updateCapturedData(
    sessionId: string,
    newData: Record<string, string>
  ): Promise<void> {
    const state = await this.getState(sessionId)

    await this.updateState(sessionId, {
      datos_capturados: {
        ...state.datos_capturados,
        ...newData,
      },
    })
  }

  // ============================================================================
  // Turn Operations
  // ============================================================================

  /**
   * Add a turn to the session.
   */
  async addTurn(params: AddTurnParams): Promise<AgentTurn> {
    const { data, error } = await this.supabase
      .from('agent_turns')
      .insert({
        session_id: params.sessionId,
        turn_number: params.turnNumber,
        role: params.role,
        content: params.content,
        intent_detected: params.intentDetected ?? null,
        confidence: params.confidence ?? null,
        tools_called: params.toolsCalled ?? [],
        tokens_used: params.tokensUsed ?? 0,
      })
      .select()
      .single()

    if (error) {
      throw new SessionError('Failed to add turn', params.sessionId, error)
    }

    logger.debug(
      { sessionId: params.sessionId, turnNumber: params.turnNumber, role: params.role },
      'Turn added'
    )

    return data as AgentTurn
  }

  /**
   * Get all turns for a session, ordered by turn number.
   */
  async getTurns(sessionId: string): Promise<AgentTurn[]> {
    const { data, error } = await this.supabase
      .from('agent_turns')
      .select('*')
      .eq('session_id', sessionId)
      .order('turn_number', { ascending: true })

    if (error) {
      throw new SessionError('Failed to get turns', sessionId, error)
    }

    return (data ?? []) as AgentTurn[]
  }

  /**
   * Get total tokens used in a session.
   */
  async getTotalTokensUsed(sessionId: string): Promise<number> {
    const { data, error } = await this.supabase
      .from('agent_turns')
      .select('tokens_used')
      .eq('session_id', sessionId)

    if (error) {
      throw new SessionError('Failed to get token count', sessionId, error)
    }

    return data?.reduce((sum, turn) => sum + (turn.tokens_used ?? 0), 0) ?? 0
  }

  /**
   * Get turn count for a session.
   */
  async getTurnCount(sessionId: string): Promise<number> {
    const { count, error } = await this.supabase
      .from('agent_turns')
      .select('*', { count: 'exact', head: true })
      .eq('session_id', sessionId)

    if (error) {
      throw new SessionError('Failed to get turn count', sessionId, error)
    }

    return count ?? 0
  }
}
```

**Update src/lib/agents/index.ts to add exports:**

Add to existing exports:
```typescript
// Registry
export { AgentRegistry, agentRegistry } from './registry'

// Session Manager
export { SessionManager } from './session-manager'
export type { CreateSessionParams, AddTurnParams, UpdateSessionParams } from './session-manager'
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/session-manager.ts
```
Check SessionManager methods:
```bash
grep -E "async (create|get|update|add|close|handoff)" src/lib/agents/session-manager.ts | head -15
```
Verify version check pattern:
```bash
grep "\.eq('version'" src/lib/agents/session-manager.ts
```
Should find the optimistic locking check.
  </verify>
  <done>
- SessionManager class with createSession, getSession, getSessionByConversation
- updateSessionWithVersion with optimistic locking (version check in WHERE clause)
- VersionConflictError thrown when version mismatch detected
- State operations: getState, updateState, addIntentSeen, addTemplateSent, updateCapturedData
- Turn operations: addTurn, getTurns, getTotalTokensUsed, getTurnCount
- All methods use admin client with proper error handling
- Exports added to index.ts
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Registry exports verified:
```bash
grep -E "export.*AgentRegistry|export.*agentRegistry" src/lib/agents/registry.ts
```

2. SessionManager has optimistic locking:
```bash
grep -A5 "updateSessionWithVersion" src/lib/agents/session-manager.ts | head -10
```

3. All exports in index.ts:
```bash
grep "export" src/lib/agents/index.ts
```

4. TypeScript compiles:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit
```
</verification>

<success_criteria>
- AgentRegistry can register, get, list, unregister agents
- AgentRegistry throws AgentNotFoundError for missing agents
- SessionManager createSession creates both session and state records
- SessionManager updateSessionWithVersion enforces version check
- SessionManager throws VersionConflictError on version mismatch
- Turn operations properly track turn numbers and token usage
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-agent-engine-core/13-02-SUMMARY.md`
</output>
