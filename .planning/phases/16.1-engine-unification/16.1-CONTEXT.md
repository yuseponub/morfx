# Phase 16.1: Engine Unification - Context

**Gathered:** 2026-02-10
**Status:** Ready for planning

<domain>
## Phase Boundary

Unificar SandboxEngine y SomnioEngine en un solo engine con patrón de ports/adapters. Lo que se configure y arregle en sandbox debe funcionar idéntico en producción. Cada entorno (sandbox/prod) puede configurar tiempos y velocidades de forma independiente sin afectar al otro.

**NO es scope:** Crear nuevos agentes, cambiar la lógica de Somnio, agregar features nuevas a sandbox.

</domain>

<decisions>
## Implementation Decisions

### Arquitectura: Engine = Runner de I/O

- El engine unificado es un **runner minimalista** que solo conecta adapters de I/O con el agente
- **Toda la lógica de negocio vive dentro del agente** (intents, transiciones, ingest, templates, orders, debug info)
- El engine no sabe ni impone estructura de intents — agentes futuros podrán tener arquitectura completamente diferente
- El agente recibe input + adapters → retorna output (mensajes, nuevo estado, debug info, timer signals)

### 5 Adapters de I/O

1. **Storage** — Leer/guardar estado de sesión
   - Sandbox: in-memory (estado como parámetro, retorna nuevo estado)
   - Producción: Supabase via SessionManager (DB reads/writes)

2. **Timer** — Señalizar start/cancel/reevaluate de temporizadores
   - Sandbox: retorna TimerSignal en resultado → frontend simulator interpreta
   - Producción: emite eventos Inngest → timer workflows reales

3. **Messaging** — Enviar mensajes de respuesta al cliente
   - Sandbox: retorna array de strings, frontend aplica delays según response speed
   - Producción: MessageSequencer calcula delays reales, escribe en DB, envía por WhatsApp

4. **Orders** — Crear contacto/pedido cuando cliente confirma compra
   - Sandbox: CrmOrchestrator con modo dry-run o live, tool execution tracking con mode annotation
   - Producción: OrderCreator escribe directo en DB

5. **Debug** — Información de debug por turno
   - Sandbox: retorna DebugTurn completo (intent, tokens por modelo, tools, stateAfter, ingestStatus timeline)
   - Producción: solo loguea, no retorna debug info al cliente

### EngineConfig como parámetro

El engine recibe un objeto `EngineConfig` inyectado por el caller:
- **Timer durations** — 5 niveles (L0-L4) en segundos
- **Response speed** — delays entre mensajes (real/rápido/instantáneo o custom)
- **CRM modes** — enable/disable por agente CRM + modo dry-run/live

Cada entorno resuelve su config **antes** de llamar al engine:
- Sandbox: presets del frontend (sliders, toggles)
- Producción: valores en código (hardcoded o workspace_agent_config de DB)
- Mirror mode (futuro): sandbox lee config de prod con override — **DIFERIDO para fase futura**

Modelo AI es solo visualización frontend, NO va en EngineConfig.

### forceIntent es parte del engine

- `forceIntent` se mantiene como parámetro del input del engine (no solo de sandbox)
- Usado por timer simulator (sandbox) e Inngest workflows (producción) para forzar transiciones
- Cuando activo: skip intent detection, confidence 100%, skip validation en orchestrator
- Soporta: ofrecer_promos (ingest complete), compra_confirmada (timer timeout), etc.

### Componentes core compartidos

Estos componentes son compartidos e idénticos para todos los entornos:
- IntentDetector
- SomnioOrchestrator (con TemplateManager, TransitionValidator, DataExtractor)
- IngestManager
- MessageClassifier

NO se vuelven inyectables — quedan como dependencias directas del agente Somnio.

### Debug panel por agente

- Cada agente define qué debug info retorna — no hay estructura fija del engine
- Somnio retorna: IntentInfo, ToolExecutions, TokenInfo (por modelo), IngestStatus con timeline
- Agentes futuros podrían retornar debug info completamente diferente
- Sandbox renderiza lo que el agente devuelva

### Estrategia de migración: Big bang con backup

- Se crea el engine unificado
- Se migra sandbox Y producción al mismo tiempo
- Los engines viejos (sandbox-engine.ts y somnio-engine.ts) se conservan como respaldo
- Se borran cuando todo funcione bien y pasemos a fase 17 (preguntar al usuario antes de borrar)

### Ubicación de archivos

Claude's Discretion — organizar la estructura de archivos según convenciones del proyecto actual.

</decisions>

<specifics>
## Specific Ideas

### Funcionalidades que NO se pueden perder del sandbox

El sandbox es la referencia de cómo debe funcionar el agente. Se trabajó muchas horas en él. Todo debe funcionar idéntico:

1. **Ingest Mode completo** — clasificación datos/pregunta/mixto/irrelevante, acumulación silenciosa, timeline de clasificaciones
2. **Implicit Yes** — detección de datos fuera de collecting_data, transición automática a collecting_data o directo a ofrecer_promos si todos los campos llegan juntos
3. **forceIntent** — timer fuerza intents (ofrecer_promos, compra_confirmada), skip validation, skip templates en compra_confirmada forzado
4. **Timer signals** — start/cancel/reevaluate con two-step signal pattern (cancel ingest → start promo)
5. **IngestStatus tracking** — timeline completa, fieldsAccumulated, lastClassification, firstDataAt
6. **CRM routing** — order-manager con dry-run/live, tool execution tracking con mode annotation, mensajes [SANDBOX: CRM DRY-RUN/LIVE]
7. **Debug turn completo** — IntentInfo con alternativas/reasoning, tokens por modelo (Haiku/Sonnet split), tools con duración y modo, stateAfter
8. **State mutation pattern** — handleIngestMode/checkImplicitYes mutan currentState como canal de comunicación al caller (WARNING comments documentados)
9. **Mock session building** — intentsVistos ANTES del intent actual para primera_vez vs siguientes en TemplateManager
10. **Templates** — TemplateManager con primera_vez vs siguientes, sustitución de variables (precios, nombre, ciudad, pack), ordenamiento por campo orden
11. **Order Manager modes** — dos caminos para crear orden:
    - Con ingest: datos acumulados silenciosamente → ofrecer_promos → resumen → compra_confirmada → order
    - Con flujo normal: conversación → captura_datos_si_compra → collecting_data (con respuestas) → ofrecer_promos → resumen → compra_confirmada → order

### Extensibilidad

- El diseño de ports/adapters debe permitir enchufar engines con arquitectura completamente diferente en el futuro
- Los agentes futuros NO son variaciones de Somnio — tendrán estructura lógica diferente
- El contrato es simple: recibe mensaje → retorna respuesta + estado + debug
- No crear abstracciones prematuras para agentes futuros — solo asegurar que el diseño no bloquee

</specifics>

<deferred>
## Deferred Ideas

- **Sandbox Mirror mode** — Toggle en sandbox para leer config real de producción con override puntual. Útil para verificar "¿se comporta igual que en prod?"
- **Config-driven agents** — Definir agentes con JSON/config en vez de código. No aplica ahora porque cada agente futuro tendrá arquitectura diferente.
- **Versionado de agentes** — v1/v2 del mismo agente. Decisión: no hay versionado, si querés experimentar creás agente nuevo.
- **Debug panel unificado** — Panel de debug adaptable a cualquier agente. Por ahora cada agente define su debug. Consolidar cuando haya más agentes y patrones comunes.

</deferred>

---

*Phase: 16.1-engine-unification*
*Context gathered: 2026-02-10*
