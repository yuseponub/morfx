---
phase: 15.5-somnio-ingest-system
plan: 03
type: execute
wave: 3
depends_on: ["15.5-02"]
files_modified:
  - src/lib/agents/somnio/somnio-engine.ts
  - src/lib/agents/somnio/somnio-orchestrator.ts
  - src/lib/sandbox/types.ts
  - src/lib/sandbox/sandbox-engine.ts
  - src/lib/agents/somnio/index.ts
autonomous: true

must_haves:
  truths:
    - "SomnioEngine routes through IngestManager when in collecting_data mode"
    - "SomnioEngine returns no response for 'datos' classification (silent)"
    - "SomnioEngine emits ingest.started event on first data detection"
    - "SomnioEngine emits ingest.completed when 8 fields present"
    - "SandboxState shows ingestStatus with timer information"
    - "Implicit yes: datos outside collecting_data triggers mode transition"
  artifacts:
    - path: "src/lib/agents/somnio/somnio-engine.ts"
      provides: "Integrated ingest flow in main processing"
      contains: "IngestManager"
    - path: "src/lib/sandbox/types.ts"
      provides: "IngestStatus type for sandbox visibility"
      contains: "ingestStatus"
    - path: "src/lib/sandbox/sandbox-engine.ts"
      provides: "Ingest status tracking in sandbox"
      contains: "ingestStatus"
  key_links:
    - from: "somnio-engine.ts"
      to: "ingest-manager.ts"
      via: "IngestManager.handleMessage()"
      pattern: "ingestManager\\.handleMessage"
    - from: "somnio-engine.ts"
      to: "inngest"
      via: "event emission"
      pattern: "inngest\\.send.*ingest"
    - from: "sandbox-engine.ts"
      to: "ingest-manager.ts"
      via: "IngestManager for classification"
      pattern: "ingestManager"
---

<objective>
Integrate IngestManager into SomnioEngine and add ingest visibility to Sandbox

Purpose: Wire the ingest system into the main agent flow and provide debug visibility
Output: Complete ingest flow working in both production engine and sandbox
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15.5-somnio-ingest-system/15.5-CONTEXT.md
@.planning/phases/15.5-somnio-ingest-system/15.5-RESEARCH.md
@.planning/phases/15.5-somnio-ingest-system/15.5-01-SUMMARY.md
@.planning/phases/15.5-somnio-ingest-system/15.5-02-SUMMARY.md

# Files to modify
@src/lib/agents/somnio/somnio-engine.ts
@src/lib/agents/somnio/somnio-orchestrator.ts
@src/lib/sandbox/types.ts
@src/lib/sandbox/sandbox-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate IngestManager into SomnioEngine</name>
  <files>src/lib/agents/somnio/somnio-engine.ts</files>
  <action>
Modify SomnioEngine to use IngestManager when in collecting_data mode:

1. Add IngestManager as class member:
   ```typescript
   private ingestManager: IngestManager
   ```
   Initialize in constructor: `this.ingestManager = new IngestManager(this.claudeClient)`

2. Modify processMessage() flow - after intent detection, BEFORE orchestration:
   ```typescript
   // Check for ingest mode handling
   const currentMode = session.current_mode
   const sessionState = session.state

   // Build ingest state from session
   const ingestState: IngestState = {
     active: currentMode === 'collecting_data',
     startedAt: sessionState.proactive_started_at ?? null,
     firstDataAt: sessionState.first_data_at ?? null,
     fieldsCollected: Object.keys(sessionState.datos_capturados).filter(
       k => sessionState.datos_capturados[k] && sessionState.datos_capturados[k] !== 'N/A'
     ),
   }

   // Route through IngestManager if in collecting_data mode
   if (currentMode === 'collecting_data') {
     const ingestResult = await this.ingestManager.handleMessage(
       input.messageContent,
       ingestState,
       session.state.datos_capturados,
       history
     )

     // Emit timer events if needed
     if (ingestResult.shouldEmitTimerStart) {
       await this.emitIngestStarted(session, ingestResult.timerDuration === '6m')
     }
     if (ingestResult.shouldEmitTimerComplete) {
       await this.emitIngestCompleted(session.id, 'all_fields')
     }

     // Handle silent accumulation
     if (ingestResult.action === 'silent') {
       // Update datos_capturados if data was extracted
       if (ingestResult.extractedData) {
         await this.sessionManager.updateState(session.id, {
           datos_capturados: mergeExtractedData(
             sessionState.datos_capturados,
             ingestResult.extractedData
           ),
           first_data_at: ingestState.firstDataAt ?? new Date().toISOString(),
         })
       }

       // Return early - no response sent
       return {
         success: true,
         response: undefined, // SILENT
         sessionId: session.id,
         tokensUsed: 0,
         newMode: currentMode,
       }
     }

     // For 'respond' or 'complete', continue to orchestrator
     // But pass extracted data for state update
     if (ingestResult.extractedData) {
       await this.sessionManager.updateState(session.id, {
         datos_capturados: mergeExtractedData(
           sessionState.datos_capturados,
           ingestResult.extractedData
         ),
       })
     }
   }
   ```

3. Add helper methods:
   ```typescript
   private async emitIngestStarted(session: AgentSessionWithState, hasPartialData: boolean): Promise<void> {
     const timerDurationMs = hasPartialData ? 360000 : 600000 // 6 min or 10 min
     const inngest = await import('@/inngest/client').then(m => m.inngest)
     await inngest.send({
       name: 'agent/ingest.started',
       data: {
         sessionId: session.id,
         conversationId: session.conversation_id,
         workspaceId: this.workspaceId,
         hasPartialData,
         timerDurationMs,
       },
     })
   }

   private async emitIngestCompleted(sessionId: string, reason: 'all_fields' | 'timeout' | 'cancelled'): Promise<void> {
     const inngest = await import('@/inngest/client').then(m => m.inngest)
     await inngest.send({
       name: 'agent/ingest.completed',
       data: { sessionId, reason },
     })
   }
   ```

4. Handle "implicit yes" (datos sent outside collecting_data):
   - Run classifier on ANY message before intent detection
   - If classification is 'datos' and NOT in collecting_data:
     - Transition to collecting_data
     - Process as if user said "si" first
     - Send the 2 collecting_data templates
     - Extract the data from current message
  </action>
  <verify>
TypeScript compiles: `cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --skipLibCheck 2>&1 | grep -E "(error|somnio-engine)" || echo "No errors"`
  </verify>
  <done>
SomnioEngine routes through IngestManager in collecting_data mode, returns silent for datos, emits timer events
  </done>
</task>

<task type="auto">
  <name>Task 2: Add IngestStatus to SandboxState types</name>
  <files>src/lib/sandbox/types.ts</files>
  <action>
Add IngestStatus type and include in SandboxState:

```typescript
/**
 * Ingest status for sandbox visibility (Phase 15.5)
 */
export interface IngestStatus {
  active: boolean
  startedAt: string | null
  firstDataAt: string | null
  fieldsAccumulated: string[]
  timerType: 'partial' | 'no_data' | null
  timerExpiresAt: string | null
  lastClassification?: MessageClassification
}

// Update SandboxState interface
export interface SandboxState {
  currentMode: string
  intentsVistos: string[]
  templatesEnviados: string[]
  datosCapturados: Record<string, string>
  packSeleccionado: PackSelection | null
  // NEW: Ingest tracking for debug visibility
  ingestStatus?: IngestStatus
}
```

Import MessageClassification from message-classifier.ts.
  </action>
  <verify>
Check type exists: `cd /mnt/c/Users/Usuario/Proyectos/morfx-new && grep "IngestStatus" src/lib/sandbox/types.ts`
  </verify>
  <done>
IngestStatus type defined and added to SandboxState interface
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate IngestManager into SandboxEngine</name>
  <files>src/lib/sandbox/sandbox-engine.ts</files>
  <action>
Update SandboxEngine to track ingest status:

1. Add IngestManager member:
   ```typescript
   private ingestManager: IngestManager

   constructor() {
     this.claudeClient = new ClaudeClient()
     this.intentDetector = new IntentDetector(this.claudeClient)
     this.orchestrator = new SomnioOrchestrator(this.claudeClient)
     this.ingestManager = new IngestManager(this.claudeClient)
   }
   ```

2. Modify processMessage() to use IngestManager in collecting_data mode:
   - Before intent detection, check if in collecting_data
   - Call ingestManager.handleMessage()
   - If action='silent', update state and return with note "[Acumulando datos silenciosamente]"
   - Update ingestStatus in newState

3. Track ingest status in state:
   ```typescript
   // Build ingest status for sandbox visibility
   const ingestStatus: IngestStatus = {
     active: currentState.currentMode === 'collecting_data',
     startedAt: null, // Would be tracked in real session
     firstDataAt: Object.keys(currentState.datosCapturados).length > 0
       ? new Date().toISOString()
       : null,
     fieldsAccumulated: Object.keys(currentState.datosCapturados),
     timerType: Object.keys(currentState.datosCapturados).length > 0
       ? 'partial'
       : 'no_data',
     timerExpiresAt: null, // Timer simulation not needed in sandbox
     lastClassification: ingestResult?.classification,
   }
   ```

4. Add classification info to debug output:
   - When ingest is active, show classification in debug turn
   - Show "[SANDBOX: Silent - clasificacion: datos]" for silent responses
  </action>
  <verify>
TypeScript compiles: `cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --skipLibCheck 2>&1 | grep -E "(error|sandbox-engine)" || echo "No errors"`
  </verify>
  <done>
SandboxEngine tracks ingestStatus and shows classification in debug output
  </done>
</task>

</tasks>

<verification>
1. SomnioEngine uses IngestManager: `grep "IngestManager" src/lib/agents/somnio/somnio-engine.ts`
2. SandboxState has ingestStatus: `grep "ingestStatus" src/lib/sandbox/types.ts`
3. SandboxEngine tracks ingest: `grep "ingestManager" src/lib/sandbox/sandbox-engine.ts`
4. TypeScript compiles without errors
</verification>

<success_criteria>
- SomnioEngine returns no response (silent) for 'datos' classification in collecting_data mode
- SomnioEngine emits agent/ingest.started on first data
- SomnioEngine emits agent/ingest.completed when 8 fields complete
- SandboxState includes ingestStatus with timer info
- SandboxEngine shows classification in debug output
- Implicit yes flow works (datos outside collecting_data triggers transition)
</success_criteria>

<output>
After completion, create `.planning/phases/15.5-somnio-ingest-system/15.5-03-SUMMARY.md`
</output>
