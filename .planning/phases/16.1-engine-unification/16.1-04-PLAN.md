---
phase: 16.1-engine-unification
plan: 04
type: execute
wave: 3
depends_on: ["16.1-01", "16.1-02", "16.1-03"]
files_modified:
  - src/lib/agents/engine/unified-engine.ts
  - src/lib/agents/engine/index.ts
  - src/app/api/sandbox/process/route.ts
autonomous: true

must_haves:
  truths:
    - "UnifiedEngine.processMessage() delegates all business logic to SomnioAgent and all I/O to adapters"
    - "Sandbox API route uses UnifiedEngine + createSandboxAdapters and returns identical SandboxEngineResult shape"
    - "Sandbox timer simulator still receives timerSignal from engine result"
    - "Sandbox debug panel still receives full DebugTurn"
    - "Sandbox CRM dry-run/live still works with mode annotation messages"
  artifacts:
    - path: "src/lib/agents/engine/unified-engine.ts"
      provides: "UnifiedEngine class — thin runner connecting input to agent to adapters"
      exports: ["UnifiedEngine"]
    - path: "src/app/api/sandbox/process/route.ts"
      provides: "Sandbox API route using unified engine"
  key_links:
    - from: "src/lib/agents/engine/unified-engine.ts"
      to: "src/lib/agents/somnio/somnio-agent.ts"
      via: "calls SomnioAgent.processMessage()"
      pattern: "somnioAgent\\.processMessage"
    - from: "src/app/api/sandbox/process/route.ts"
      to: "src/lib/agents/engine/unified-engine.ts"
      via: "creates UnifiedEngine and calls processMessage"
      pattern: "UnifiedEngine"
    - from: "src/app/api/sandbox/process/route.ts"
      to: "src/lib/agents/engine-adapters/sandbox/index.ts"
      via: "creates sandbox adapters"
      pattern: "createSandboxAdapters"
---

<objective>
Create the UnifiedEngine class and wire the sandbox API route to use it.

Purpose: The engine is the thin runner that connects input -> agent -> adapters. Wiring the sandbox first allows isolated testing of the unified flow without risking production.
Output: `UnifiedEngine` class + updated sandbox route. Sandbox should behave identically to before.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/16.1-engine-unification/16.1-CONTEXT.md
@.planning/phases/16.1-engine-unification/16.1-RESEARCH.md
@.planning/phases/16.1-engine-unification/16.1-01-SUMMARY.md
@.planning/phases/16.1-engine-unification/16.1-02-SUMMARY.md
@.planning/phases/16.1-engine-unification/16.1-03-SUMMARY.md

Key source files:
@src/lib/agents/engine/types.ts (types from Plan 01)
@src/lib/agents/somnio/somnio-agent.ts (agent from Plan 02)
@src/lib/agents/engine-adapters/sandbox/index.ts (sandbox adapters from Plan 03)
@src/app/api/sandbox/process/route.ts (current sandbox route to update)
@src/lib/sandbox/sandbox-engine.ts (OLD engine — reference for behavior comparison)
@src/lib/sandbox/types.ts (SandboxEngineResult shape to preserve)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UnifiedEngine class</name>
  <files>
    src/lib/agents/engine/unified-engine.ts
    src/lib/agents/engine/index.ts
  </files>
  <action>
Create `src/lib/agents/engine/unified-engine.ts` — the thin runner.

**Class structure:**
```typescript
export class UnifiedEngine {
  private somnioAgent: SomnioAgent
  private adapters: EngineAdapters
  private config: EngineConfig

  constructor(adapters: EngineAdapters, config: EngineConfig) {
    this.adapters = adapters
    this.config = config
    this.somnioAgent = new SomnioAgent()
  }

  async processMessage(input: EngineInput): Promise<EngineOutput> {
    // ... thin runner logic
  }
}
```

**processMessage flow:**

1. **Get session** via storage adapter:
   - If `input.sessionId` provided: `adapters.storage.getSession(input.sessionId)`
   - Else: `adapters.storage.getOrCreateSession(input.conversationId, input.contactId)`

2. **Get history** via storage adapter:
   - If `input.history` provided (sandbox path): use directly
   - Else: `adapters.storage.getHistory(session.id)`

3. **Call SomnioAgent.processMessage():**
   ```typescript
   const agentOutput = await this.somnioAgent.processMessage({
     message: input.message,
     session,
     history,
     turnNumber: input.turnNumber ?? (history.length + 1),
     forceIntent: input.forceIntent,
   })
   ```

4. **Storage I/O** based on agent output:
   - If `agentOutput.stateUpdates.newMode`: `adapters.storage.updateMode(session.id, session.version, newMode)`
   - Apply state updates: `adapters.storage.saveState(session.id, ...)`
   - Record user turn: `adapters.storage.addTurn(...)`
   - Add intent seen: `adapters.storage.addIntentSeen(...)`
   - If handoff: `adapters.storage.handoff(...)`

5. **Timer I/O** based on agent output:
   - For each signal in `agentOutput.timerSignals`: `adapters.timer.signal(signal)`
   - If production timer events needed: call optional methods

6. **Orders I/O** if `agentOutput.shouldCreateOrder`:
   - `adapters.orders.createOrder(agentOutput.orderData, mode)`
   - Capture order result for output

7. **Messaging I/O** if messages to send:
   - `adapters.messaging.send({ messages, templates, ... })`

8. **Debug I/O:**
   - `adapters.debug.recordIntent(agentOutput.intentInfo)`
   - `adapters.debug.recordTools(agentOutput.tools)`
   - `adapters.debug.recordTokens(agentOutput.tokenDetails)`
   - `adapters.debug.recordState(agentOutput.stateUpdates)`

9. **Build EngineOutput:**
   ```typescript
   return {
     success: agentOutput.success,
     messages: agentOutput.messages,
     newState: (adapters.storage as any).getState?.(),  // sandbox-only
     debugTurn: adapters.debug.getDebugTurn(input.turnNumber ?? 1),
     timerSignal: adapters.timer.getLastSignal(),
     orderCreated: orderResult?.success,
     orderId: orderResult?.orderId,
     contactId: orderResult?.contactId,
     newMode: agentOutput.stateUpdates.newMode,
     tokensUsed: agentOutput.totalTokens,
     sessionId: session.id,
     messagesSent: messagingResult?.messagesSent,
     response: agentOutput.messages.join('\n'),
     error: agentOutput.error,
   }
   ```

**IMPORTANT — The engine is dumb:**
- NO business logic decisions
- NO intent detection
- NO ingest handling
- NO template selection
- Only: read state -> call agent -> write state -> call adapters -> return result

**Update barrel (src/lib/agents/engine/index.ts):**
Add `export { UnifiedEngine } from './unified-engine'` to existing type exports.
  </action>
  <verify>`npx tsc --noEmit` passes. UnifiedEngine compiles and exports correctly.</verify>
  <done>UnifiedEngine is a thin runner of ~100-150 lines that delegates all logic to SomnioAgent and all I/O to adapters.</done>
</task>

<task type="auto">
  <name>Task 2: Wire sandbox API route to UnifiedEngine</name>
  <files>src/app/api/sandbox/process/route.ts</files>
  <action>
Update `src/app/api/sandbox/process/route.ts` to use UnifiedEngine + sandbox adapters instead of SandboxEngine.

**Changes:**

1. **Replace imports:**
   - Remove: `import { SandboxEngine } from '@/lib/sandbox/sandbox-engine'`
   - Add: `import { UnifiedEngine } from '@/lib/agents/engine'`
   - Add: `import { createSandboxAdapters } from '@/lib/agents/engine-adapters/sandbox'`
   - Keep: `import type { SandboxState } from '@/lib/sandbox/types'`

2. **Remove module-level engine instance:**
   - Remove: `const engine = new SandboxEngine()`
   - The unified engine is created per-request with adapters (stateless adapters created per-request)

3. **Update POST handler:**
   ```typescript
   // Create adapters for this request
   const adapters = createSandboxAdapters({
     state,
     history: history ?? [],
     crmModes: crmAgents,
     workspaceId,
   })

   // Create engine with adapters
   const engine = new UnifiedEngine(adapters, { workspaceId: workspaceId ?? 'sandbox' })

   // Process message
   const result = await engine.processMessage({
     sessionId: 'sandbox-session',
     conversationId: 'sandbox-conversation',
     contactId: 'sandbox-contact',
     message,
     workspaceId: workspaceId ?? 'sandbox',
     history: history ?? [],
     turnNumber: turnNumber ?? 1,
     forceIntent,
   })
   ```

4. **Map EngineOutput to SandboxEngineResult shape:**
   The frontend expects `SandboxEngineResult` (from sandbox/types.ts). Map the EngineOutput:
   ```typescript
   const sandboxResult: SandboxEngineResult = {
     success: result.success,
     messages: result.messages,
     debugTurn: result.debugTurn,
     newState: result.newState,
     error: result.error ? { code: result.error.code, message: result.error.message } : undefined,
     timerSignal: result.timerSignal,
   }
   return NextResponse.json(sandboxResult)
   ```

5. **Keep everything else unchanged:**
   - Authentication check stays
   - Workspace membership check for LIVE mode stays
   - Import of somnio and crm modules for registration stays
   - initializeTools() stays
   - Error handling stays

**CRITICAL:** The response shape MUST be exactly `SandboxEngineResult`. The frontend (sandbox-layout.tsx) reads: `result.success`, `result.messages`, `result.debugTurn`, `result.newState`, `result.timerSignal`, `result.error`. All must be present and correct.

**CRITICAL for silent responses:** When ingest classifies message as 'datos', the agent returns `messages: ['[SANDBOX: Silent - clasificacion: datos, ...]']`. This message should be in the result. After receiving the engine result, check if `result.messages.length === 0` and handle it explicitly:

```typescript
// After engine.processMessage(...)
if (result.messages.length === 0) {
  // Silent accumulation path: the agent classified as 'datos' and returned
  // an earlyReturn with no visible messages. Inject a debug-only message
  // so the sandbox UI shows something to the user.
  const debugMsg = result.debugTurn?.classification
    ? `[SANDBOX: Silent - clasificacion: ${result.debugTurn.classification}]`
    : '[SANDBOX: Silent - datos acumulados]'
  result.messages = [debugMsg]
}
```

This ensures the sandbox frontend always has at least one message to display. In production this path doesn't apply because the messaging adapter handles delivery independently. Verify this path works correctly by testing with a 'datos' only message during ingest mode.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. The route.ts file no longer imports SandboxEngine
3. The route.ts file imports UnifiedEngine and createSandboxAdapters
4. Response type matches SandboxEngineResult exactly
  </verify>
  <done>Sandbox API route uses UnifiedEngine with sandbox adapters. Frontend receives identical SandboxEngineResult shape. Timer signal, debug turn, and all state fields preserved.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes across the entire project
2. UnifiedEngine is a thin class (~100-150 lines) with no business logic
3. Sandbox route creates per-request adapters and engine
4. The response shape from sandbox route matches SandboxEngineResult interface
5. Old SandboxEngine is still in codebase (backup) but no longer imported by the route
</verification>

<success_criteria>
- UnifiedEngine class created and exported
- Sandbox route uses unified engine
- Sandbox response shape unchanged (frontend compatibility)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16.1-engine-unification/16.1-04-SUMMARY.md`
</output>
