---
phase: 18-domain-layer-foundation
plan: 07
type: execute
wave: 4
depends_on: ["18-01"]
files_modified:
  - src/lib/domain/tasks.ts
  - src/lib/domain/index.ts
  - src/app/actions/tasks.ts
  - src/lib/automations/action-executor.ts
  - src/lib/tools/handlers/crm/index.ts
  - src/lib/tools/schemas/crm.tools.ts
autonomous: true

must_haves:
  truths:
    - "createTask domain function creates task + emits task.created trigger (new trigger via emitTaskCompleted pattern)"
    - "updateTask domain function updates task fields"
    - "completeTask domain function marks task as completed + emits task.completed trigger"
    - "deleteTask domain function deletes task"
    - "4 new task tool handlers registered: task.create, task.update, task.complete, task.list"
    - "Action executor create_task calls domain.createTask instead of direct DB"
    - "Server actions delegate to domain functions"
  artifacts:
    - path: "src/lib/domain/tasks.ts"
      provides: "4 task domain functions"
      exports: ["createTask", "updateTask", "completeTask", "deleteTask"]
    - path: "src/lib/tools/schemas/crm.tools.ts"
      provides: "4 new task tool schemas"
      contains: "task.create"
  key_links:
    - from: "src/lib/domain/tasks.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "import emitTaskCompleted"
      pattern: "trigger-emitter"
    - from: "src/lib/tools/handlers/crm/index.ts"
      to: "src/lib/domain/tasks.ts"
      via: "import domain task functions"
      pattern: "domain/tasks"
---

<objective>
Create task domain functions, wire all callers, and create 4 new task tool handlers. This makes tasks fully domain-powered and gives the bot ability to manage tasks.

Purpose: Tasks currently have a trigger gap — the action executor's create_task doesn't emit any trigger. After this plan, every task mutation goes through domain/ with proper trigger emission, and the bot gains task.create/update/complete/list capabilities.

Output: `src/lib/domain/tasks.ts` + 2 refactored callers + 4 new tool handlers.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/18-domain-layer-foundation/18-RESEARCH.md

Key reference files (READ THESE):
@src/app/actions/tasks.ts (server actions: createTask, updateTask, deleteTask — with emitTaskCompleted for status=completed)
@src/lib/automations/action-executor.ts (create_task action — direct DB, NO trigger)
@src/lib/automations/trigger-emitter.ts (emitTaskCompleted signature)
@src/lib/tools/schemas/crm.tools.ts (existing schema pattern for new tool registrations)
@src/lib/domain/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tasks domain functions + wire callers</name>
  <files>src/lib/domain/tasks.ts, src/lib/domain/index.ts, src/app/actions/tasks.ts, src/lib/automations/action-executor.ts</files>
  <action>
Create `src/lib/domain/tasks.ts` with 4 functions:

**createTask(ctx, params):**
- Params: title, description?, dueDate?, priority? ('low'|'medium'|'high'|'urgent'), status? ('pending'|'in_progress'|'completed'), contactId?, orderId?, conversationId?, assignedTo?
- Logic: Insert into tasks with workspace_id. Only one of contactId/orderId/conversationId can be set (exclusive arc pattern from Phase 10).
- Emit: No specific trigger for task creation currently defined in Phase 17 trigger catalog. BUT the domain function should be ready — add a comment `// TODO: emitTaskCreated when trigger type added` or if create triggers exist, emit them.
- Actually, check the TRIGGER_CATALOG in constants.ts — if there's no task.created trigger, just don't emit. The important trigger is task.completed.
- Return: `{ taskId: string }`

**updateTask(ctx, params):**
- Params: taskId, title?, description?, dueDate?, priority?, status?, assignedTo?
- Logic: Read current task. Update task row. If status changes to 'completed', call completeTask internally (or just emit the trigger directly).
- If status changed to 'completed': emit `emitTaskCompleted({ workspaceId, taskId, taskTitle, contactId, orderId, cascadeDepth })`
- Return: `{ taskId: string }`

**completeTask(ctx, params):**
- Params: taskId
- Logic: Read current task. Set status='completed', completed_at=timezone('America/Bogota', NOW()).
- Emit: `emitTaskCompleted({ workspaceId, taskId, taskTitle: task.title, contactId: task.contact_id, orderId: task.order_id, cascadeDepth })`
- Return: `{ taskId: string }`
- IMPORTANT: Use Colombia timezone for completed_at (CLAUDE.md rule).

**deleteTask(ctx, params):**
- Params: taskId
- Logic: Verify task belongs to workspace. Delete from tasks.
- Return: `{ taskId: string }`

Update `src/lib/domain/index.ts` to add `export * from './tasks'`.

**Wire `src/app/actions/tasks.ts`:**
1. Import domain task functions
2. Refactor createTask, updateTask, deleteTask to call domain functions
3. REMOVE inline emitTaskCompleted from the server action
4. Keep auth validation + revalidatePath

**Wire `src/lib/automations/action-executor.ts`:**
1. The `create_task` action: Call `domainCreateTask(ctx, params)` instead of direct DB insert
2. Build DomainContext: `{ workspaceId, source: 'automation', cascadeDepth }`
3. Remove direct DB task insert code
  </action>
  <verify>File compiles. 4 task domain functions exported. Server action has no emitTaskCompleted. Action executor create_task uses domain. Barrel export updated.</verify>
  <done>Task domain functions created, all callers wired, trigger gap fixed.</done>
</task>

<task type="auto">
  <name>Task 2: Create 4 new task tool handlers</name>
  <files>src/lib/tools/handlers/crm/index.ts, src/lib/tools/schemas/crm.tools.ts</files>
  <action>
**Add 4 new task tool handlers** to `src/lib/tools/handlers/crm/index.ts`:

1. **task.create**: Calls `domainCreateTask(ctx, params)`. Bot permission: YES.
   - Input: title (required), description?, dueDate?, priority?, contactId?, orderId?
   - Build DomainContext: `{ workspaceId: context.workspaceId, source: 'tool-handler' }`
   - Map DomainResult to ToolResult

2. **task.update**: Calls `domainUpdateTask(ctx, params)`. Bot permission: YES.
   - Input: taskId (required), title?, description?, dueDate?, priority?, status?

3. **task.complete**: Calls `domainCompleteTask(ctx, { taskId })`. Bot permission: YES.
   - Input: taskId (required)
   - Convenience handler — equivalent to updateTask with status=completed

4. **task.list**: Read-only. Query tasks with filters. Uses createAdminClient + workspace_id.
   - Input: contactId?, orderId?, status?, priority?, page?, pageSize?
   - Query tasks table with filters, return paginated results

**Add tool schemas** to `src/lib/tools/schemas/crm.tools.ts`:
- Add 4 task tool definitions following existing schema pattern
- Names: task.create, task.update, task.complete, task.list
- Include parameter JSON Schema with descriptions in Spanish (matching existing tool descriptions)

**Register handlers:**
- Add task handlers to the `crmHandlers` record export in `crm/index.ts`
- Verify `src/lib/tools/init.ts` will pick them up (it iterates crmToolSchemas and finds handlers by name)
  </action>
  <verify>4 new tool schemas in crm.tools.ts (grep for 'task.create'). 4 new handlers in crmHandlers export. TypeScript compiles.</verify>
  <done>4 task tool handlers created and registered. Bot can now manage tasks.</done>
</task>

</tasks>

<verification>
1. `src/lib/domain/tasks.ts` exports 4 functions
2. completeTask emits task.completed trigger
3. Server action has no inline trigger emission
4. Action executor create_task uses domain (trigger gap FIXED)
5. 4 new task tool handlers registered (task.create, task.update, task.complete, task.list)
6. 4 new task tool schemas in crm.tools.ts
7. `npx tsc --noEmit` passes
8. `src/lib/domain/index.ts` re-exports tasks
</verification>

<success_criteria>
- Every task mutation goes through domain/tasks.ts
- task.completed trigger fires from all callers (server action, automation, bot)
- Bot can create, update, complete, and list tasks
- Action executor's create_task trigger gap is fixed
</success_criteria>

<output>
After completion, create `.planning/phases/18-domain-layer-foundation/18-07-SUMMARY.md`
</output>
