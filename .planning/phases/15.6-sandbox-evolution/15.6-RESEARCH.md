# Phase 15.6: Sandbox Evolution - Research

**Researched:** 2026-02-07
**Domain:** Multi-panel debug UI, agent architecture (conversational vs CRM), dry-run/live tool execution, token tracking per model, ingest configuration UI
**Confidence:** HIGH (codebase analysis) / MEDIUM (library recommendations)

## Summary

This phase evolves the existing sandbox from a simple chat + single-tab debug panel into a multi-panel IDE-like environment with drag-and-drop tab arrangement, CRM agent separation, dry-run/live tool execution, configurable ingest timers, and per-model token tracking.

The current codebase uses `allotment` v1.20.5 for a basic 60/40 horizontal split (chat | debug panel) and Radix UI Tabs for switching between Tools, Estado, Intent, and Tokens tabs (one visible at a time). The user wants up to 3 debug panels visible simultaneously with drag-and-drop rearrangement. The project already has `@dnd-kit` (v6.3.1, v10.0.0 sortable) installed.

The agent architecture currently has a single SomnioEngine/SomnioOrchestrator that handles everything. The user wants to separate this into: (a) conversational agents (Somnio - handles sales flow, templates, intent detection) that emit results, and (b) CRM agents (Order Manager, Edit Order, etc.) that execute data operations. An orchestrator layer routes between them.

**Primary recommendation:** Use the existing `allotment` for the main layout split (chat | debug area), then build a custom multi-panel layout within the debug area using `@dnd-kit/sortable` for tab drag-and-drop reordering plus CSS Grid/Flexbox for panel arrangement (max 3 visible). Do NOT introduce react-resizable-panels -- it would require replacing existing working allotment code and learning a new v4 API with breaking changes. Use Radix UI Slider (new) for ingest timer controls.

## Standard Stack

### Core (Already Installed)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| allotment | 1.20.5 | Resizable split panels | Already used for chat/debug split, proven in project |
| @dnd-kit/core | 6.3.1 | Drag and drop primitives | Already installed, lightweight, accessible |
| @dnd-kit/sortable | 10.0.0 | Sortable lists/tabs | Already installed, handles tab reordering |
| @dnd-kit/utilities | 3.2.2 | DnD utility functions | Already installed, CSS transform helpers |
| @radix-ui/react-tabs | 1.1.13 | Tab UI component | Already used in debug-tabs.tsx |
| @radix-ui/react-switch | 1.2.6 | Toggle switch | Already installed, for dry-run/live toggle |
| @radix-ui/react-select | 2.2.6 | Select/dropdown | Already installed, for CRM agent dropdown |
| @radix-ui/react-tooltip | 1.2.8 | Tooltips | Already installed, for panel controls |

### Supporting (New)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @radix-ui/react-slider | latest | Range slider | Ingest timer fine-tuning controls |
| @radix-ui/react-toggle-group | 1.1.11 | Preset buttons | Ingest timer presets (Real/Rapido/Instantaneo) - already installed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| allotment + @dnd-kit | react-resizable-panels v4 | Would require replacing existing allotment code + learning v4 API with breaking changes (PanelGroup->Group, direction->orientation). Not worth the churn. |
| @dnd-kit for tab DnD | react-beautiful-dnd | Unmaintained, does not support React 19 |
| Custom panel layout | react-grid-layout | Overkill for max-3-panel fixed layout, heavy dependency |
| Custom panel layout | react-mosaic | IDE-like but over-engineered for 3 panels |

**Installation:**
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx shadcn@latest add slider
```

Note: This will add `@radix-ui/react-slider` and the slider component to `src/components/ui/slider.tsx`.

## Architecture Patterns

### Recommended Project Structure
```
src/
  app/(dashboard)/sandbox/
    components/
      debug-panel/
        debug-tabs.tsx          # MODIFIED: multi-panel container with DnD
        tools-tab.tsx           # MODIFIED: dry-run/live mode support
        state-tab.tsx           # EXISTING (minor changes)
        intent-tab.tsx          # EXISTING (minor changes)
        tokens-tab.tsx          # MODIFIED: per-model breakdown
        ingest-tab.tsx          # NEW: ingest config + timeline
        panel-container.tsx     # NEW: manages visible panels (max 3)
        tab-bar.tsx             # NEW: draggable tab bar with DnD
        index.ts                # MODIFIED: updated exports
      sandbox-header.tsx        # MODIFIED: CRM agent multi-select dropdown
      sandbox-layout.tsx        # MODIFIED: CRM agent state + orchestration
      sandbox-split-panel.tsx   # EXISTING (no changes)
  lib/
    sandbox/
      types.ts                  # MODIFIED: new types for CRM agents, per-model tokens
      sandbox-engine.ts         # MODIFIED: CRM agent integration + dry-run/live
      sandbox-session.ts        # EXISTING (minor changes)
    agents/
      crm/                      # NEW: CRM agent system
        types.ts                # CRM agent interfaces
        crm-agent-registry.ts   # Registry of CRM agents
        orchestrator.ts         # CRM orchestrator (routes commands to agents)
        order-manager/          # First CRM agent
          agent.ts              # OrderManager agent with 3 modes
          tools.ts              # Tool definitions + mock generators
        base-crm-agent.ts       # Base class for CRM agents
```

### Pattern 1: Multi-Panel Debug Layout with DnD Tab Bar
**What:** A tab bar where tabs can be dragged to reorder, with up to 3 panels visible simultaneously. Each panel renders one tab's content.
**When to use:** When users need to see multiple debug views at once (e.g., Tools + Estado + Ingest).

```typescript
// Tab bar with @dnd-kit sortable
import { DndContext, closestCenter } from '@dnd-kit/core'
import { SortableContext, horizontalListSortingStrategy, arrayMove } from '@dnd-kit/sortable'
import { useSortable } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

interface PanelTab {
  id: string
  label: string
  icon: React.ComponentType
  visible: boolean // Whether this panel is currently shown
}

function SortableTab({ tab, onToggleVisible }: { tab: PanelTab; onToggleVisible: () => void }) {
  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id: tab.id })
  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  }

  return (
    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>
      <button
        onClick={onToggleVisible}
        className={cn(
          'px-3 py-1.5 text-xs flex items-center gap-1.5 rounded-t',
          tab.visible ? 'bg-background border-t border-x' : 'bg-muted/50 text-muted-foreground'
        )}
      >
        <tab.icon className="h-3.5 w-3.5" />
        {tab.label}
      </button>
    </div>
  )
}

function TabBar({ tabs, onReorder, onToggleTab }: TabBarProps) {
  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event
    if (active.id !== over?.id) {
      const oldIndex = tabs.findIndex(t => t.id === active.id)
      const newIndex = tabs.findIndex(t => t.id === over?.id)
      onReorder(arrayMove(tabs, oldIndex, newIndex))
    }
  }

  return (
    <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
      <SortableContext items={tabs} strategy={horizontalListSortingStrategy}>
        <div className="flex gap-1 px-3 pt-2 border-b">
          {tabs.map(tab => (
            <SortableTab key={tab.id} tab={tab} onToggleVisible={() => onToggleTab(tab.id)} />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  )
}
```

### Pattern 2: Command/Handler for CRM Agents
**What:** Conversational agent (Somnio) emits commands/results. Orchestrator routes to CRM agents. CRM agents execute operations.
**When to use:** Separating conversational flow from data operations.

```typescript
// CRM Agent command types
interface CrmCommand {
  type: 'create_order' | 'edit_order' | 'search_contact'
  payload: Record<string, unknown>
  source: 'orchestrator' | 'manual' // manual = triggered from sandbox UI
}

interface CrmAgentResult {
  success: boolean
  data?: Record<string, unknown>
  toolCalls: ToolExecution[] // For debug visibility
  tokensUsed: { model: string; input: number; output: number }[]
}

// Base CRM Agent interface
interface CrmAgent {
  id: string
  name: string
  description: string
  supportedCommands: string[]
  execute(command: CrmCommand, mode: 'dry-run' | 'live'): Promise<CrmAgentResult>
}

// CRM Orchestrator routes commands to agents
class CrmOrchestrator {
  private agents: Map<string, CrmAgent> = new Map()

  async route(command: CrmCommand, mode: 'dry-run' | 'live'): Promise<CrmAgentResult> {
    const agent = this.findAgentForCommand(command.type)
    if (!agent) throw new Error(`No CRM agent for command: ${command.type}`)
    return agent.execute(command, mode)
  }
}
```

### Pattern 3: Dry-Run vs Live Tool Execution
**What:** In dry-run mode, generate realistic mock data instead of executing real tools. In live mode, execute against real Supabase with `test-` prefix on names.
**When to use:** All CRM agent tool executions in sandbox.

```typescript
// Mock data generator for dry-run mode
function generateMockResult(toolName: string, input: Record<string, unknown>): ToolExecution {
  const mockGenerators: Record<string, (input: Record<string, unknown>) => unknown> = {
    'crm.contact.create': (input) => ({
      success: true,
      data: {
        id: `mock-contact-${Date.now()}`,
        name: input.name,
        phone: input.phone,
        created_at: new Date().toISOString(),
      }
    }),
    'crm.order.create': (input) => ({
      success: true,
      data: {
        orderId: `mock-order-${Date.now()}`,
        contactId: input.contactId,
        status: 'pending',
        created_at: new Date().toISOString(),
      }
    }),
  }

  const generator = mockGenerators[toolName]
  return {
    name: toolName,
    input,
    result: generator ? generator(input) as any : { success: true, data: { id: `mock-${Date.now()}` } },
    durationMs: Math.floor(Math.random() * 200) + 50,
    timestamp: new Date().toISOString(),
  }
}

// In live mode, prefix test data
function prefixTestData(input: Record<string, unknown>): Record<string, unknown> {
  if (typeof input.name === 'string' && !input.name.startsWith('test-')) {
    return { ...input, name: `test-${input.name}` }
  }
  return input
}
```

### Pattern 4: Per-Model Token Tracking
**What:** Track input/output tokens separately per model (Haiku vs Sonnet) across all turns.
**When to use:** Token breakdown display in the Tokens tab.

```typescript
// Extended token info with model breakdown
interface ModelTokenUsage {
  model: string // 'claude-haiku-4-5' | 'claude-sonnet-4-5'
  inputTokens: number
  outputTokens: number
}

interface ExtendedTokenInfo {
  turnNumber: number
  totalTokens: number
  models: ModelTokenUsage[]
  timestamp: string
}

// Accumulate across all turns
function aggregateTokensByModel(turns: ExtendedTokenInfo[]): Map<string, ModelTokenUsage> {
  const totals = new Map<string, ModelTokenUsage>()
  for (const turn of turns) {
    for (const usage of turn.models) {
      const existing = totals.get(usage.model) ?? { model: usage.model, inputTokens: 0, outputTokens: 0 }
      existing.inputTokens += usage.inputTokens
      existing.outputTokens += usage.outputTokens
      totals.set(usage.model, existing)
    }
  }
  return totals
}
```

### Anti-Patterns to Avoid
- **Overcomplicating the panel layout:** Do NOT build a full window manager (like VS Code's docking). The user wants max 3 panels -- use a simple grid/flexbox layout where clicking a tab toggles visibility, NOT free-form floating windows.
- **Mixing CRM logic into Somnio:** The conversational agent (Somnio) must NOT know about CRM agents. It emits results (datos extraidos, pack seleccionado); the orchestrator decides what CRM agent to call.
- **Single token counter:** The existing `tokensUsed: number` loses model granularity. Always track `{ model, input, output }` tuples from the Claude API response.
- **Mutating state directly:** The current SandboxEngine mutates `currentState` by reference in `handleIngestMode`. New code should return new state objects, not mutate parameters.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Tab drag-and-drop reorder | Custom mouse/touch handlers | `@dnd-kit/sortable` + `horizontalListSortingStrategy` | Handles edge cases (keyboard nav, touch, a11y) that take weeks to build correctly |
| Resizable split panes | Custom resize handles with mouse events | `allotment` (already working) | Handles min/max sizes, snap, keyboard resize, SSR issues |
| Toggle switch UI | Custom checkbox styling | `@radix-ui/react-switch` (already installed) | Accessible, keyboard-navigable, consistent with project UI |
| Slider for timer config | Custom input range | `@radix-ui/react-slider` via shadcn `npx shadcn add slider` | Step, min, max, dual thumb, accessible |
| Multi-select dropdown | Custom checkbox list | Radix Select + custom multi-select pattern (project already uses similar patterns) | Keep consistent with existing header dropdowns |
| JSON mock generation | Manual JSON construction | Centralized mock generator keyed by tool name | Ensures consistency, easy to extend for new tools |

**Key insight:** The multi-panel layout is simpler than it seems -- it's NOT a docking system. It's a tab bar with toggle visibility (max 3 active) plus drag-to-reorder. The visible panels render in a CSS grid. Total custom code: ~100 lines for the panel container + ~80 lines for the sortable tab bar.

## Common Pitfalls

### Pitfall 1: DnD Context Conflicts
**What goes wrong:** Using `@dnd-kit` inside an `allotment` panel can conflict because allotment also handles drag events for resizing.
**Why it happens:** Both libraries listen to mouse/touch events on overlapping DOM elements.
**How to avoid:** Keep `DndContext` INSIDE the debug panel area (right side of allotment split), not wrapping the entire layout. The allotment resize handle and the dnd-kit sortable tabs should never overlap DOM-wise.
**Warning signs:** Drag to reorder tabs also triggers allotment resize, or vice versa.

### Pitfall 2: SSR with Allotment and DnD
**What goes wrong:** Next.js SSR crashes when importing allotment or dnd-kit because they access `window`/`document`.
**Why it happens:** Both libraries are client-only. The project already handles this for allotment via `dynamic(() => import(...), { ssr: false })`.
**How to avoid:** Keep the same dynamic import pattern. The `sandbox-split-panel.tsx` already does this correctly. Any new component using `@dnd-kit` inside the debug panel is already within a `'use client'` boundary, so no additional SSR handling needed as long as allotment remains dynamic-imported.
**Warning signs:** `ReferenceError: window is not defined` during build.

### Pitfall 3: Lost Token Model Information
**What goes wrong:** The `ClaudeClient` currently combines `input_tokens + output_tokens` into a single `tokensUsed` number and doesn't track which model was used.
**Why it happens:** The current API `{ result, tokensUsed }` loses the model and input/output breakdown.
**How to avoid:** Modify `ClaudeClient` return types to include `{ model, inputTokens, outputTokens }` alongside `tokensUsed`. Propagate this through `IntentDetector`, `SomnioOrchestrator`, and `SandboxEngine` up to `DebugTurn`. This is a deeper change that touches the data pipeline.
**Warning signs:** Tokens tab shows only totals, cannot distinguish Haiku vs Sonnet usage.

### Pitfall 4: CRM Agent Scope Creep
**What goes wrong:** Trying to build too many CRM agents in this phase. The CONTEXT.md says "se iran creando mas progresivamente".
**Why it happens:** Natural tendency to build the full CRM agent suite at once.
**How to avoid:** Build ONLY the Order Manager agent in this phase. Define the CRM agent interface/types and the orchestrator routing, but implement only one concrete agent. The architecture must support adding more agents later (registry pattern).
**Warning signs:** Planning tasks for "Edit Order agent", "Search Contact agent" etc. in this phase.

### Pitfall 5: Panel State Management Complexity
**What goes wrong:** Trying to sync panel visibility state through too many layers (URL params, localStorage, parent state).
**Why it happens:** Over-engineering persistence for a feature that explicitly does NOT persist between sessions.
**How to avoid:** Use simple `useState` in the debug panel container. Default layout on mount: Tools + Estado visible. No persistence. No URL params.
**Warning signs:** Adding localStorage, useSearchParams, or context providers for panel state.

### Pitfall 6: Breaking Existing Sandbox Functionality
**What goes wrong:** Refactoring the SandboxEngine for CRM agents breaks the existing Somnio flow.
**Why it happens:** The SandboxEngine is tightly coupled to SomnioOrchestrator currently.
**How to avoid:** Keep the existing SomnioEngine path intact. Add CRM agent support as an ADDITIONAL layer, not a replacement. The sandbox should work exactly as before when no CRM agents are selected.
**Warning signs:** Existing chat flow (intent detection, template sending, state transitions) stops working after changes.

## Code Examples

### Multi-Panel Container (max 3 visible)
```typescript
// Panel container that renders 1-3 panels in a grid
interface PanelContainerProps {
  visiblePanels: string[] // IDs of visible panels (max 3)
  debugTurns: DebugTurn[]
  state: SandboxState
  // ... other props
}

function PanelContainer({ visiblePanels, ...props }: PanelContainerProps) {
  const gridCols = visiblePanels.length === 1 ? 'grid-cols-1'
    : visiblePanels.length === 2 ? 'grid-cols-2'
    : 'grid-cols-3'

  return (
    <div className={cn('grid gap-2 h-full', gridCols)}>
      {visiblePanels.map(panelId => (
        <div key={panelId} className="overflow-auto border rounded-lg">
          <PanelContent id={panelId} {...props} />
        </div>
      ))}
    </div>
  )
}

function PanelContent({ id, ...props }: { id: string } & PanelContentProps) {
  switch (id) {
    case 'tools': return <ToolsTab {...props} />
    case 'state': return <StateTab {...props} />
    case 'intent': return <IntentTab {...props} />
    case 'tokens': return <TokensTab {...props} />
    case 'ingest': return <IngestTab {...props} />
    default: return null
  }
}
```

### Ingest Tab with Timer Presets
```typescript
// Timer presets from CONTEXT.md
const TIMER_PRESETS = [
  { label: 'Real', partial: 360, noData: 600 },      // 6min / 10min
  { label: 'Rapido', partial: 30, noData: 60 },       // 30s / 60s
  { label: 'Instantaneo', partial: 0, noData: 0 },    // 0s / 0s
] as const

function IngestTimerControls({ onTimerChange }: { onTimerChange: (partial: number, noData: number) => void }) {
  const [activePreset, setActivePreset] = useState(0)
  const [partialTimer, setPartialTimer] = useState(360)
  const [noDataTimer, setNoDataTimer] = useState(600)

  return (
    <div className="space-y-3">
      {/* Preset buttons using toggle-group */}
      <ToggleGroup type="single" value={String(activePreset)} onValueChange={v => {
        const idx = Number(v)
        setActivePreset(idx)
        const preset = TIMER_PRESETS[idx]
        setPartialTimer(preset.partial)
        setNoDataTimer(preset.noData)
        onTimerChange(preset.partial, preset.noData)
      }}>
        {TIMER_PRESETS.map((p, i) => (
          <ToggleGroupItem key={i} value={String(i)} className="text-xs">
            {p.label}
          </ToggleGroupItem>
        ))}
      </ToggleGroup>

      {/* Fine-tune sliders */}
      <div className="space-y-2">
        <label className="text-xs text-muted-foreground">Con datos: {partialTimer}s</label>
        <Slider value={[partialTimer]} onValueChange={([v]) => {
          setPartialTimer(v)
          setActivePreset(-1)
          onTimerChange(v, noDataTimer)
        }} min={0} max={600} step={10} />

        <label className="text-xs text-muted-foreground">Sin datos: {noDataTimer}s</label>
        <Slider value={[noDataTimer]} onValueChange={([v]) => {
          setNoDataTimer(v)
          setActivePreset(-1)
          onTimerChange(partialTimer, v)
        }} min={0} max={600} step={10} />
      </div>
    </div>
  )
}
```

### Dry-Run/Live Toggle per CRM Agent
```typescript
// Per-agent toggle state
interface CrmAgentState {
  agentId: string
  mode: 'dry-run' | 'live'
  enabled: boolean
}

function CrmAgentToggle({ agent, onModeChange }: { agent: CrmAgentState; onModeChange: (mode: 'dry-run' | 'live') => void }) {
  return (
    <div className="flex items-center gap-2 p-2 border rounded">
      <span className="text-sm flex-1">{agent.agentId}</span>
      <div className="flex items-center gap-1.5">
        <span className="text-xs text-muted-foreground">Dry</span>
        <Switch
          checked={agent.mode === 'live'}
          onCheckedChange={(checked) => onModeChange(checked ? 'live' : 'dry-run')}
        />
        <span className="text-xs text-muted-foreground">Live</span>
      </div>
    </div>
  )
}
```

### Extended DebugTurn with Model Token Breakdown
```typescript
// New token info structure
interface ModelTokenEntry {
  model: 'claude-haiku-4-5' | 'claude-sonnet-4-5'
  inputTokens: number
  outputTokens: number
}

interface ExtendedTokenInfo {
  turnNumber: number
  tokensUsed: number // Total (backward compatible)
  models: ModelTokenEntry[] // Per-model breakdown
  timestamp: string
}

// In ClaudeClient, return model info alongside tokens
async detectIntent(/* ... */): Promise<{
  result: IntentResult
  tokensUsed: number
  tokenDetail: ModelTokenEntry
}> {
  const response = await this.client.messages.create({ model: MODEL_MAP[model], /* ... */ })
  return {
    result: /* ... */,
    tokensUsed: response.usage.input_tokens + response.usage.output_tokens,
    tokenDetail: {
      model,
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens,
    }
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single debug tab visible | Multi-panel grid (max 3) | This phase | Can see Tools + Estado + Ingest simultaneously |
| Tools tab shows nothing (no real tools) | Tools tab shows dry-run simulated calls | This phase | Full tool visibility without DB writes |
| Single `tokensUsed` number | Per-model input/output breakdown | This phase | Can see Haiku vs Sonnet cost split |
| Monolithic SomnioEngine | Somnio (conversational) + CRM agents (data ops) | This phase | Testable separation, progressive agent addition |
| allotment v1.20.5 single split | allotment + @dnd-kit for tab reorder | This phase | IDE-like panel management |

**Deprecated/outdated:**
- `react-beautiful-dnd`: Unmaintained since 2022, does not support React 18+ strict mode or React 19. Use `@dnd-kit` instead (already in project).
- `react-resizable-panels` v2/v3 API: v4 renamed all components (PanelGroup->Group, PanelResizeHandle->Separator). If ever migrating from allotment, use v4 API directly.

## Open Questions

1. **How does ClaudeClient currently handle model identity in responses?**
   - What we know: `ClaudeClient.detectIntent()` receives a `model` param and returns `tokensUsed` (combined). The actual model used is in `MODEL_MAP[model]` but is NOT propagated back.
   - What's unclear: Whether the Anthropic SDK response includes the actual model used (it should in `response.model`).
   - Recommendation: Add `response.model` or the input `model` param to the return value. Verify `response.model` matches what was requested (it may differ due to MODEL_MAP aliasing -- currently both map to `claude-sonnet-4-20250514`).

2. **Order Manager 3 modes -- how exactly should they differ?**
   - What we know: User said "datos completos (flujo normal), solo datos sin promo, datos minimos (crear orden borrador)".
   - What's unclear: What "datos minimos" means in terms of required fields. Current OrderCreator requires nombre, telefono, direccion, ciudad, departamento.
   - Recommendation: Define modes as input validation levels: `full` (all 8 fields), `no_promo` (skip pack selection, default to 1x), `draft` (only nombre + telefono, rest optional). Plan this during planning phase.

3. **Multi-select CRM agent dropdown -- which shadcn pattern?**
   - What we know: Project uses Radix Select (single select). Multi-select is not natively supported by Radix.
   - What's unclear: Whether to use a Popover+Checkbox pattern or cmdk (Command palette, already installed v1.1.1).
   - Recommendation: Use Popover + Checkbox list pattern. The project already has both `@radix-ui/react-popover` and `@radix-ui/react-checkbox` installed. This is the standard shadcn approach for multi-select.

4. **Real-time ingest timer display in sandbox**
   - What we know: Ingest timers currently use Inngest events (server-side). In sandbox, the timer is not enforced.
   - What's unclear: Should the sandbox simulate the timer countdown visually? The user said "tiempo restante del timer" in the Ingest tab spec.
   - Recommendation: Use a client-side `setInterval` to show a countdown timer based on the configured timer values. When it reaches 0, trigger the ofrecer_promos transition automatically (simulating what Inngest would do in production).

## Sources

### Primary (HIGH confidence)
- Codebase analysis of all sandbox files, agent files, and types
- `package.json` dependencies (allotment 1.20.5, @dnd-kit/core 6.3.1, @dnd-kit/sortable 10.0.0)
- Existing `sandbox-split-panel.tsx` (allotment usage pattern)
- Existing `debug-tabs.tsx` (Radix UI Tabs pattern)
- Existing `claude-client.ts` (token tracking analysis)
- Existing `orchestrator.ts`, `somnio-orchestrator.ts`, `somnio-engine.ts`, `sandbox-engine.ts` (agent architecture)

### Secondary (MEDIUM confidence)
- [react-resizable-panels GitHub](https://github.com/bvaughn/react-resizable-panels) - v4.6.2 API analysis, conditional rendering support
- [react-resizable-panels DeepWiki](https://deepwiki.com/bvaughn/react-resizable-panels/6-examples-and-usage-patterns) - Advanced features documentation
- [shadcn/ui Resizable](https://ui.shadcn.com/docs/components/radix/resizable) - react-resizable-panels v4 wrapper
- [@dnd-kit documentation](https://docs.dndkit.com/presets/sortable) - Sortable preset API
- [shadcn-ui/ui resizable issues](https://github.com/shadcn-ui/ui/issues/9197) - v4 breaking changes confirmation

### Tertiary (LOW confidence)
- WebSearch results for "agent orchestrator pattern command handler CRM" - patterns from Azure Architecture Center and community articles

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All core libraries already installed and working in project. Only addition is @radix-ui/react-slider (shadcn slider component).
- Architecture: HIGH for panel layout (straightforward grid + dnd-kit), MEDIUM for CRM agent separation (well-designed pattern but first implementation).
- Pitfalls: HIGH - Identified from direct codebase analysis of existing coupling, SSR issues, and token tracking gaps.
- CRM agent interface: MEDIUM - Pattern is clear, but specific command routing logic will need refinement during planning.

**Research date:** 2026-02-07
**Valid until:** 2026-03-07 (30 days - stable stack, internal architecture)
