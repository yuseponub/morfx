---
phase: 11-shopify-integration
plan: 04
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - src/lib/shopify/connection-test.ts
  - src/app/actions/shopify.ts
autonomous: true

must_haves:
  truths:
    - "Admin can test Shopify connection before saving"
    - "Integration credentials are stored securely"
    - "Only workspace Owner can manage integrations"
  artifacts:
    - path: "src/lib/shopify/connection-test.ts"
      provides: "Shopify API connection test"
      exports: ["testShopifyConnection"]
    - path: "src/app/actions/shopify.ts"
      provides: "Server Actions for Shopify integration CRUD"
      exports: ["getShopifyIntegration", "saveShopifyIntegration", "deleteShopifyIntegration"]
  key_links:
    - from: "src/app/actions/shopify.ts"
      to: "src/lib/shopify/connection-test.ts"
      via: "import testShopifyConnection"
      pattern: "import.*testShopifyConnection"
---

<objective>
Create connection testing and Server Actions for Shopify integration management.

Purpose: Enable admin to configure, test, and manage Shopify integration credentials.
Output: Connection test utility and Server Actions for integration CRUD.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-shopify-integration/11-CONTEXT.md
@.planning/phases/11-shopify-integration/11-RESEARCH.md

# Existing Server Action patterns:
@src/app/actions/orders.ts
@src/app/actions/templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shopify connection test utility</name>
  <files>src/lib/shopify/connection-test.ts</files>
  <action>
First, install the Shopify SDK (only used for connection test, NOT for webhooks):
```bash
pnpm add @shopify/shopify-api
```

Create connection test utility:

```typescript
import { shopifyApi, ApiVersion, Session } from '@shopify/shopify-api'
import '@shopify/shopify-api/adapters/node'

/**
 * Result of testing Shopify connection.
 */
export interface ConnectionTestResult {
  success: boolean
  error?: string
  scopes?: string[]
  shopName?: string
}

/**
 * Tests Shopify connection by making a simple API call.
 * This verifies the credentials are valid and have required permissions.
 *
 * @param shopDomain - The shop domain (e.g., "mystore.myshopify.com")
 * @param accessToken - The Admin API access token
 * @param apiSecret - The API secret key (needed to initialize SDK)
 * @returns Test result with scopes if successful
 */
export async function testShopifyConnection(
  shopDomain: string,
  accessToken: string,
  apiSecret: string
): Promise<ConnectionTestResult> {
  // Normalize shop domain
  const normalizedDomain = normalizeShopDomain(shopDomain)
  if (!normalizedDomain) {
    return { success: false, error: 'Dominio de tienda invalido' }
  }

  try {
    // Initialize Shopify API client
    const shopify = shopifyApi({
      apiKey: 'not-used-for-custom-apps',
      apiSecretKey: apiSecret,
      hostName: normalizedDomain,
      apiVersion: ApiVersion.January25,
      isCustomStoreApp: true,
      adminApiAccessToken: accessToken,
    })

    // Create session for API calls
    const session = shopify.session.customAppSession(normalizedDomain)

    // Create REST client
    const client = new shopify.clients.Rest({ session })

    // Test with access_scopes endpoint (lightweight, always available)
    const response = await client.get<{
      access_scopes: Array<{ handle: string }>
    }>({
      path: 'oauth/access_scopes',
    })

    const scopes = response.body.access_scopes.map(s => s.handle)

    // Verify required scopes
    const requiredScopes = ['read_orders', 'read_customers']
    const missingScopes = requiredScopes.filter(s => !scopes.includes(s))

    if (missingScopes.length > 0) {
      return {
        success: false,
        error: `Permisos faltantes: ${missingScopes.join(', ')}. La app necesita: read_orders, read_customers`,
        scopes,
      }
    }

    // Get shop info for confirmation
    const shopResponse = await client.get<{
      shop: { name: string; domain: string }
    }>({
      path: 'shop',
    })

    return {
      success: true,
      scopes,
      shopName: shopResponse.body.shop.name,
    }
  } catch (error: unknown) {
    console.error('Shopify connection test failed:', error)

    // Parse common errors
    if (error instanceof Error) {
      if (error.message.includes('401')) {
        return { success: false, error: 'Access Token invalido o expirado' }
      }
      if (error.message.includes('404')) {
        return { success: false, error: 'Tienda no encontrada. Verifica el dominio.' }
      }
      if (error.message.includes('403')) {
        return { success: false, error: 'Acceso denegado. Verifica los permisos de la app.' }
      }
      return { success: false, error: error.message }
    }

    return { success: false, error: 'Error desconocido al conectar con Shopify' }
  }
}

/**
 * Normalizes shop domain to mystore.myshopify.com format.
 */
function normalizeShopDomain(input: string): string | null {
  if (!input || typeof input !== 'string') return null

  let domain = input.trim().toLowerCase()

  // Remove protocol if present
  domain = domain.replace(/^https?:\/\//, '')

  // Remove trailing slash
  domain = domain.replace(/\/$/, '')

  // Validate format
  // Accept: mystore.myshopify.com OR mystore (and add .myshopify.com)
  if (domain.endsWith('.myshopify.com')) {
    return domain
  }

  // If just store name provided, add .myshopify.com
  if (/^[a-z0-9][a-z0-9\-]*[a-z0-9]$/.test(domain) || /^[a-z0-9]$/.test(domain)) {
    return `${domain}.myshopify.com`
  }

  // Custom domains not supported for API access
  return null
}

/**
 * Exports normalize function for use elsewhere.
 */
export { normalizeShopDomain }
```

Key features:
- Uses official Shopify SDK for reliable API access
- Validates required scopes (read_orders, read_customers)
- Returns shop name for confirmation
- Error messages in Spanish (per project convention)
- Handles common errors (401, 403, 404)
  </action>
  <verify>Test manually if Shopify credentials available, otherwise verify compiles and error handling is comprehensive.</verify>
  <done>testShopifyConnection validates credentials and scopes. Returns shop name on success.</done>
</task>

<task type="auto">
  <name>Task 2: Server Actions for integration CRUD</name>
  <files>src/app/actions/shopify.ts</files>
  <action>
Create Server Actions following existing patterns:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { createAdminClient } from '@/lib/supabase/admin'
import { testShopifyConnection, normalizeShopDomain, ConnectionTestResult } from '@/lib/shopify/connection-test'
import type { ShopifyIntegration, ShopifyConfig, IntegrationFormData } from '@/lib/shopify/types'
import type { Pipeline, PipelineStage } from '@/lib/orders/types'

// ============================================================================
// GET OPERATIONS
// ============================================================================

/**
 * Gets the Shopify integration for the current workspace.
 * Returns null if no integration exists.
 */
export async function getShopifyIntegration(): Promise<ShopifyIntegration | null> {
  const supabase = await createClient()

  // Get current user and workspace
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return null

  const { data: member } = await supabase
    .from('workspace_members')
    .select('workspace_id')
    .eq('user_id', user.id)
    .single()

  if (!member) return null

  const { data: integration } = await supabase
    .from('integrations')
    .select('*')
    .eq('workspace_id', member.workspace_id)
    .eq('type', 'shopify')
    .single()

  return integration as ShopifyIntegration | null
}

/**
 * Gets webhook events for the Shopify integration (for debugging/status).
 */
export async function getWebhookEvents(limit: number = 20): Promise<{
  events: Array<{
    id: string
    external_id: string
    topic: string
    status: string
    error_message: string | null
    created_at: string
    processed_at: string | null
  }>
  stats: {
    total: number
    processed: number
    failed: number
    pending: number
  }
}> {
  const supabase = await createClient()

  const integration = await getShopifyIntegration()
  if (!integration) {
    return { events: [], stats: { total: 0, processed: 0, failed: 0, pending: 0 } }
  }

  // Get recent events
  const { data: events } = await supabase
    .from('webhook_events')
    .select('id, external_id, topic, status, error_message, created_at, processed_at')
    .eq('integration_id', integration.id)
    .order('created_at', { ascending: false })
    .limit(limit)

  // Get stats
  const { count: total } = await supabase
    .from('webhook_events')
    .select('*', { count: 'exact', head: true })
    .eq('integration_id', integration.id)

  const { count: processed } = await supabase
    .from('webhook_events')
    .select('*', { count: 'exact', head: true })
    .eq('integration_id', integration.id)
    .eq('status', 'processed')

  const { count: failed } = await supabase
    .from('webhook_events')
    .select('*', { count: 'exact', head: true })
    .eq('integration_id', integration.id)
    .eq('status', 'failed')

  return {
    events: events || [],
    stats: {
      total: total || 0,
      processed: processed || 0,
      failed: failed || 0,
      pending: (total || 0) - (processed || 0) - (failed || 0),
    },
  }
}

/**
 * Gets pipelines and stages for configuration dropdown.
 */
export async function getPipelinesForConfig(): Promise<Array<Pipeline & { stages: PipelineStage[] }>> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return []

  const { data: member } = await supabase
    .from('workspace_members')
    .select('workspace_id')
    .eq('user_id', user.id)
    .single()

  if (!member) return []

  const { data: pipelines } = await supabase
    .from('pipelines')
    .select(`
      *,
      stages:pipeline_stages(*)
    `)
    .eq('workspace_id', member.workspace_id)
    .order('name')

  return (pipelines || []).map(p => ({
    ...p,
    stages: (p.stages || []).sort((a: PipelineStage, b: PipelineStage) => a.position - b.position),
  }))
}

// ============================================================================
// WRITE OPERATIONS (Owner only)
// ============================================================================

/**
 * Tests Shopify connection without saving.
 */
export async function testConnection(formData: IntegrationFormData): Promise<ConnectionTestResult> {
  const normalized = normalizeShopDomain(formData.shop_domain)
  if (!normalized) {
    return { success: false, error: 'Dominio de tienda invalido' }
  }

  return testShopifyConnection(
    normalized,
    formData.access_token,
    formData.api_secret
  )
}

/**
 * Saves Shopify integration (create or update).
 * Only workspace Owner can perform this action.
 */
export async function saveShopifyIntegration(formData: IntegrationFormData): Promise<{
  success: boolean
  error?: string
  integration?: ShopifyIntegration
}> {
  const supabase = await createClient()
  const adminSupabase = createAdminClient()

  // Get current user
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autenticado' }
  }

  // Get workspace and verify Owner role
  const { data: member } = await supabase
    .from('workspace_members')
    .select('workspace_id, role')
    .eq('user_id', user.id)
    .single()

  if (!member || member.role !== 'owner') {
    return { success: false, error: 'Solo el Owner puede configurar integraciones' }
  }

  // Validate required fields
  if (!formData.shop_domain || !formData.access_token || !formData.api_secret) {
    return { success: false, error: 'Todos los campos de credenciales son requeridos' }
  }

  if (!formData.default_pipeline_id || !formData.default_stage_id) {
    return { success: false, error: 'Pipeline y etapa por defecto son requeridos' }
  }

  // Normalize shop domain
  const normalizedDomain = normalizeShopDomain(formData.shop_domain)
  if (!normalizedDomain) {
    return { success: false, error: 'Dominio de tienda invalido' }
  }

  // Test connection before saving
  const testResult = await testShopifyConnection(
    normalizedDomain,
    formData.access_token,
    formData.api_secret
  )

  if (!testResult.success) {
    return { success: false, error: testResult.error || 'Error de conexion' }
  }

  // Build config object
  const config: ShopifyConfig = {
    shop_domain: normalizedDomain,
    access_token: formData.access_token,
    api_secret: formData.api_secret,
    default_pipeline_id: formData.default_pipeline_id,
    default_stage_id: formData.default_stage_id,
    enable_fuzzy_matching: formData.enable_fuzzy_matching,
    product_matching: formData.product_matching,
  }

  // Check if integration exists
  const { data: existing } = await adminSupabase
    .from('integrations')
    .select('id')
    .eq('workspace_id', member.workspace_id)
    .eq('type', 'shopify')
    .single()

  let integration: ShopifyIntegration

  if (existing) {
    // Update existing
    const { data: updated, error } = await adminSupabase
      .from('integrations')
      .update({
        name: formData.name || `Shopify - ${testResult.shopName}`,
        config,
        is_active: true,
        updated_at: new Date().toISOString(),
      })
      .eq('id', existing.id)
      .select()
      .single()

    if (error) {
      console.error('Error updating integration:', error)
      return { success: false, error: 'Error al actualizar integracion' }
    }
    integration = updated as ShopifyIntegration
  } else {
    // Create new
    const { data: created, error } = await adminSupabase
      .from('integrations')
      .insert({
        workspace_id: member.workspace_id,
        type: 'shopify',
        name: formData.name || `Shopify - ${testResult.shopName}`,
        config,
        is_active: true,
      })
      .select()
      .single()

    if (error) {
      console.error('Error creating integration:', error)
      return { success: false, error: 'Error al crear integracion' }
    }
    integration = created as ShopifyIntegration
  }

  return { success: true, integration }
}

/**
 * Toggles integration active status.
 */
export async function toggleShopifyIntegration(isActive: boolean): Promise<{
  success: boolean
  error?: string
}> {
  const supabase = await createClient()
  const adminSupabase = createAdminClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autenticado' }
  }

  const { data: member } = await supabase
    .from('workspace_members')
    .select('workspace_id, role')
    .eq('user_id', user.id)
    .single()

  if (!member || member.role !== 'owner') {
    return { success: false, error: 'Solo el Owner puede modificar integraciones' }
  }

  const { error } = await adminSupabase
    .from('integrations')
    .update({ is_active: isActive, updated_at: new Date().toISOString() })
    .eq('workspace_id', member.workspace_id)
    .eq('type', 'shopify')

  if (error) {
    return { success: false, error: 'Error al actualizar integracion' }
  }

  return { success: true }
}

/**
 * Deletes Shopify integration.
 */
export async function deleteShopifyIntegration(): Promise<{
  success: boolean
  error?: string
}> {
  const supabase = await createClient()
  const adminSupabase = createAdminClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autenticado' }
  }

  const { data: member } = await supabase
    .from('workspace_members')
    .select('workspace_id, role')
    .eq('user_id', user.id)
    .single()

  if (!member || member.role !== 'owner') {
    return { success: false, error: 'Solo el Owner puede eliminar integraciones' }
  }

  const { error } = await adminSupabase
    .from('integrations')
    .delete()
    .eq('workspace_id', member.workspace_id)
    .eq('type', 'shopify')

  if (error) {
    return { success: false, error: 'Error al eliminar integracion' }
  }

  return { success: true }
}
```

Key behaviors:
- Only Owner can modify integrations (verified via workspace_members)
- Test connection before save (prevents invalid credentials)
- Uses admin client for writes (bypasses RLS for service operations)
- Supports both create and update flows
- Returns shop name in success response
  </action>
  <verify>`pnpm tsc --noEmit` passes. Review all actions enforce Owner-only access.</verify>
  <done>Server Actions provide complete CRUD for Shopify integration with Owner-only enforcement.</done>
</task>

</tasks>

<verification>
1. Connection test uses official Shopify SDK
2. Required scopes are validated
3. Server Actions enforce Owner-only access
4. Test connection before save prevents invalid credentials
5. All files compile without errors
</verification>

<success_criteria>
- Admin can test Shopify connection and see shop name
- Integration credentials are saved with proper validation
- Only workspace Owner can manage integrations
- Connection test validates required scopes
</success_criteria>

<output>
After completion, create `.planning/phases/11-shopify-integration/11-04-SUMMARY.md`
</output>
