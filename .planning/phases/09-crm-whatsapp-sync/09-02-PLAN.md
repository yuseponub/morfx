---
phase: 09-crm-whatsapp-sync
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/app/actions/tags.ts
  - src/app/actions/conversations.ts
autonomous: true

must_haves:
  truths:
    - "Tags can be added to conversations"
    - "Tags can be removed from conversations"
    - "Tag scope validation prevents adding order-only tags to conversations"
    - "Conversations query includes conversation-specific tags"
  artifacts:
    - path: "src/app/actions/conversations.ts"
      provides: "Conversation tag CRUD operations"
      exports: ["addTagToConversation", "removeTagFromConversation"]
    - path: "src/app/actions/tags.ts"
      provides: "Extended tag operations with scope"
      exports: ["createTag", "updateTag", "getTagsForScope"]
  key_links:
    - from: "addTagToConversation"
      to: "conversation_tags table"
      via: "supabase insert"
      pattern: "conversation_tags.*insert"
    - from: "getConversations"
      to: "conversation_tags"
      via: "nested select join"
      pattern: "conversation_tags.*tag:tags"
---

<objective>
Implement Server Actions for conversation tag management and extend tag queries.

Purpose: This plan adds the backend logic for adding/removing tags from conversations, validates tag scope, and extends the conversation queries to include conversation-specific tags alongside contact tags.

Output: Server Actions for conversation tag CRUD, tag scope validation, extended conversation queries with dual tag sources.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-crm-whatsapp-sync/09-CONTEXT.md
@.planning/phases/09-crm-whatsapp-sync/09-RESEARCH.md
@.planning/phases/09-crm-whatsapp-sync/09-01-SUMMARY.md

# Existing patterns to follow
@src/app/actions/contacts.ts
@src/app/actions/tags.ts
@src/app/actions/conversations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conversation tag operations to conversations.ts</name>
  <files>src/app/actions/conversations.ts</files>
  <action>
Add new Server Actions for managing conversation tags. Add these at the end of the file, before any closing comments:

```typescript
// ============================================================================
// CONVERSATION TAG OPERATIONS
// ============================================================================

/**
 * Add a tag to a conversation.
 * Validates that the tag scope allows WhatsApp usage.
 */
export async function addTagToConversation(
  conversationId: string,
  tagId: string
): Promise<ActionResult> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autenticado' }
  }

  // Validate tag exists and check scope
  const { data: tag, error: tagError } = await supabase
    .from('tags')
    .select('id, applies_to')
    .eq('id', tagId)
    .single()

  if (tagError || !tag) {
    return { error: 'Etiqueta no encontrada' }
  }

  // Check tag scope - 'orders' only tags cannot be added to conversations
  if (tag.applies_to === 'orders') {
    return { error: 'Esta etiqueta solo aplica a pedidos' }
  }

  // Insert the tag association
  const { error } = await supabase
    .from('conversation_tags')
    .insert({ conversation_id: conversationId, tag_id: tagId })

  if (error) {
    // Handle duplicate (tag already added) - not an error
    if (error.code === '23505') {
      return { success: true, data: undefined }
    }
    console.error('Error adding tag to conversation:', error)
    return { error: 'Error al agregar la etiqueta' }
  }

  revalidatePath('/whatsapp')
  return { success: true, data: undefined }
}

/**
 * Remove a tag from a conversation.
 */
export async function removeTagFromConversation(
  conversationId: string,
  tagId: string
): Promise<ActionResult> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autenticado' }
  }

  const { error } = await supabase
    .from('conversation_tags')
    .delete()
    .eq('conversation_id', conversationId)
    .eq('tag_id', tagId)

  if (error) {
    console.error('Error removing tag from conversation:', error)
    return { error: 'Error al quitar la etiqueta' }
  }

  revalidatePath('/whatsapp')
  return { success: true, data: undefined }
}

/**
 * Get tags for a specific conversation (conversation-specific only, not contact tags).
 */
export async function getConversationTags(
  conversationId: string
): Promise<Array<{ id: string; name: string; color: string }>> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return []
  }

  const { data, error } = await supabase
    .from('conversation_tags')
    .select('tag:tags(id, name, color)')
    .eq('conversation_id', conversationId)

  if (error) {
    console.error('Error fetching conversation tags:', error)
    return []
  }

  return (data || [])
    .map((item: { tag: { id: string; name: string; color: string } | null }) => item.tag)
    .filter((tag): tag is { id: string; name: string; color: string } => tag !== null)
}
```

Also update the getConversations function to include conversation_tags in the query. Find the existing select query and update it:

**Before:**
```typescript
.select(`
  *,
  contact:contacts(id, name, phone, address, city, tags:contact_tags(tag:tags(*)))
`)
```

**After:**
```typescript
.select(`
  *,
  contact:contacts(id, name, phone, address, city, tags:contact_tags(tag:tags(*))),
  conversation_tags:conversation_tags(tag:tags(*))
`)
```

Then update the transformation to separate contact tags (inherited) from conversation tags (direct):

Find the map transformation and update it:

```typescript
// Transform and apply client-side filters
let conversations = (data || []).map((conv) => {
  // Get tags from linked contact (inherited tags)
  const contactTags = conv.contact?.tags || []
  const inheritedTags = contactTags.map((t: { tag: { id: string; name: string; color: string } }) => t.tag) || []

  // Get conversation-specific tags (direct tags)
  const convTagsData = conv.conversation_tags || []
  const conversationTags = convTagsData.map((t: { tag: { id: string; name: string; color: string } }) => t.tag) || []

  // Remove nested tags from contact object
  const contact = conv.contact ? { ...conv.contact, tags: undefined } : null

  return {
    ...conv,
    contact,
    tags: conversationTags,      // Direct conversation tags
    contactTags: inheritedTags,  // Inherited from contact (for display)
    conversation_tags: undefined, // Clean up raw data
  }
}) as ConversationWithDetails[]
```

Do the same for getConversation (single conversation fetch).
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/app/actions/conversations.ts
```
  </verify>
  <done>
conversations.ts has addTagToConversation, removeTagFromConversation, getConversationTags functions.
getConversations and getConversation queries include conversation_tags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend tag operations with scope support</name>
  <files>src/app/actions/tags.ts</files>
  <action>
Update the tags.ts file to support the applies_to field and add scope-filtered queries.

1. **Update the tagSchema to include applies_to:**

Find the existing schema and add:
```typescript
const tagSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido'),
  color: z.string().regex(/^#[0-9a-fA-F]{6}$/, 'Color invalido').optional(),
  applies_to: z.enum(['whatsapp', 'orders', 'both']).optional(),
})
```

2. **Update createTag to accept applies_to:**

In the createTag function, update the raw parsing and insert:

```typescript
// Parse and validate input
const raw = {
  name: formData.get('name')?.toString() || '',
  color: formData.get('color')?.toString() || DEFAULT_TAG_COLOR,
  applies_to: formData.get('applies_to')?.toString() || 'both',
}

// ... in insert:
.insert({
  workspace_id: workspaceId,
  name: result.data.name,
  color: result.data.color || DEFAULT_TAG_COLOR,
  applies_to: result.data.applies_to || 'both',
})
```

3. **Update updateTag to allow changing applies_to:**

```typescript
const raw = {
  name: formData.get('name')?.toString() || '',
  color: formData.get('color')?.toString() || undefined,
  applies_to: formData.get('applies_to')?.toString() as 'whatsapp' | 'orders' | 'both' | undefined,
}

// In updates object:
const updates: { name?: string; color?: string; applies_to?: string } = {}
if (result.data.name) updates.name = result.data.name
if (result.data.color) updates.color = result.data.color
if (result.data.applies_to) updates.applies_to = result.data.applies_to
```

4. **Add getTagsForScope function:**

```typescript
/**
 * Get tags filtered by scope.
 * @param scope - 'whatsapp' returns tags with applies_to 'whatsapp' or 'both'
 *                'orders' returns tags with applies_to 'orders' or 'both'
 *                undefined returns all tags
 */
export async function getTagsForScope(
  scope?: 'whatsapp' | 'orders'
): Promise<Tag[]> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return []
  }

  let query = supabase
    .from('tags')
    .select('*')
    .order('name', { ascending: true })

  // Filter by scope
  if (scope === 'whatsapp') {
    query = query.in('applies_to', ['whatsapp', 'both'])
  } else if (scope === 'orders') {
    query = query.in('applies_to', ['orders', 'both'])
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching tags:', error)
    return []
  }

  return data || []
}
```

5. **Add revalidation paths for WhatsApp:**

Update revalidatePath calls to include '/whatsapp' path:

```typescript
revalidatePath('/crm/contactos')
revalidatePath('/whatsapp')
revalidatePath('/settings/tags')
```

Import Tag type if not already imported:
```typescript
import type { Tag } from '@/lib/types/database'
```
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/app/actions/tags.ts
```
  </verify>
  <done>
tags.ts includes applies_to in create/update operations and exports getTagsForScope function.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. addTagToConversation validates tag scope
3. getConversations returns both conversation tags and contact tags
4. getTagsForScope correctly filters by scope
</verification>

<success_criteria>
- Tags can be added to conversations via Server Action
- Tags can be removed from conversations via Server Action
- Order-only tags are rejected when adding to conversations
- Conversations query returns conversation_tags and contactTags separately
- getTagsForScope returns appropriate tags by scope
</success_criteria>

<output>
After completion, create `.planning/phases/09-crm-whatsapp-sync/09-02-SUMMARY.md`
</output>
