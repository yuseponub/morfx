---
phase: 17-crm-automations-engine
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/lib/automations/condition-evaluator.ts
  - src/lib/automations/variable-resolver.ts
autonomous: true

must_haves:
  truths:
    - "Condition evaluator correctly evaluates AND/OR groups with nested conditions"
    - "Variable resolver replaces {{path}} placeholders with context values"
    - "Both handle edge cases: null values, missing fields, empty groups"
  artifacts:
    - path: "src/lib/automations/condition-evaluator.ts"
      provides: "AND/OR condition group evaluator"
      exports: ["evaluateConditionGroup", "evaluateCondition"]
    - path: "src/lib/automations/variable-resolver.ts"
      provides: "Mustache-style {{variable}} template resolver"
      exports: ["resolveVariables", "resolveVariablesInObject"]
  key_links:
    - from: "src/lib/automations/condition-evaluator.ts"
      to: "src/lib/automations/types.ts"
      via: "imports ConditionGroup, Condition types"
      pattern: "import.*ConditionGroup.*from.*types"
    - from: "src/lib/automations/variable-resolver.ts"
      to: "src/lib/automations/types.ts"
      via: "imports TriggerContext type"
      pattern: "import.*TriggerContext.*from.*types"
---

<objective>
Implement the condition evaluator and variable resolver — the two pure-logic modules that power automation execution.

Purpose: The condition evaluator determines whether an automation should fire based on AND/OR condition groups. The variable resolver replaces {{variable}} placeholders in action parameters (message texts, task titles, webhook payloads) with actual trigger context data. These are dependency-free pure functions that the action executor and Inngest runner will use.

Output: Two TypeScript modules with pure functions.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-crm-automations-engine/17-CONTEXT.md
@.planning/phases/17-crm-automations-engine/17-RESEARCH.md
@src/lib/automations/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Condition evaluator with AND/OR group support</name>
  <files>src/lib/automations/condition-evaluator.ts</files>
  <action>
Create a recursive condition evaluator that processes ConditionGroup objects.

Import types from `./types` (ConditionGroup, Condition, ConditionOperator).

**Core function: `evaluateConditionGroup`**
```typescript
export function evaluateConditionGroup(
  group: ConditionGroup,
  context: Record<string, unknown>
): boolean
```
- If group.conditions is empty, return true (vacuous truth — no conditions = match all)
- Map each condition: if it has `logic` property, recurse into evaluateConditionGroup; otherwise evaluate as single Condition
- AND logic: every result must be true
- OR logic: at least one result must be true

**Core function: `evaluateCondition`**
```typescript
export function evaluateCondition(
  condition: Condition,
  context: Record<string, unknown>
): boolean
```

The `field` path uses dot notation to access nested context (e.g., `order.stage_id`). Use a `getNestedValue` helper.

**Operator implementations:**
- `equals`: strict equality (===) after string coercion for both sides
- `not_equals`: inverse of equals
- `contains`: string.includes() or array.includes() (check if value is array or string)
- `not_contains`: inverse of contains
- `in`: context value is in the condition value array
- `not_in`: inverse of in
- `gt`, `lt`, `gte`, `lte`: numeric comparison (parseFloat both sides)
- `exists`: context value is not null and not undefined
- `not_exists`: context value is null or undefined

**Edge cases:**
- Missing field in context: return false for all operators except `not_exists` (return true)
- Null value in context: same as missing for comparison operators
- Non-numeric values for gt/lt/gte/lte: return false
- Empty condition group: return true

**Helper: `getNestedValue`**
```typescript
function getNestedValue(obj: Record<string, unknown>, path: string): unknown
```
Split path by '.' and reduce into object. Return undefined if any intermediate value is null/undefined.

Export both `evaluateConditionGroup` and `evaluateCondition` for direct testing.
  </action>
  <verify>Write inline test cases in comments showing expected behavior:
- AND group with all true conditions = true
- AND group with one false condition = false
- OR group with one true condition = true
- Nested group: AND(OR(true, false), true) = true
- Empty group = true
- Missing field with 'exists' = false
- Contains on array = true when item present
Verify TypeScript compiles: `npx tsc --noEmit src/lib/automations/condition-evaluator.ts`</verify>
  <done>Condition evaluator handles all operators, nested AND/OR groups, null values, missing fields, and empty groups. Exported for use by automation runner.</done>
</task>

<task type="auto">
  <name>Task 2: Variable resolver with {{path}} template syntax</name>
  <files>src/lib/automations/variable-resolver.ts</files>
  <action>
Create a simple Mustache-style variable resolver for automation action parameters.

**Core function: `resolveVariables`**
```typescript
export function resolveVariables(
  template: string,
  context: Record<string, unknown>
): string
```
- Use regex `/\{\{([^}]+)\}\}/g` to find all `{{path}}` placeholders
- For each match, call `getNestedValue(context, path.trim())`
- If value found: replace with `String(value)`
- If value not found: leave the original `{{path}}` unchanged (don't crash on missing vars)
- Handle null/undefined: replace with empty string (not "null" or "undefined")

**Recursive object resolver: `resolveVariablesInObject`**
```typescript
export function resolveVariablesInObject(
  obj: Record<string, unknown>,
  context: Record<string, unknown>
): Record<string, unknown>
```
- Recursively walk object properties
- If value is string: apply resolveVariables
- If value is object: recurse
- If value is array: map over items and resolve each
- Otherwise (number, boolean, null): return as-is
- This is used for webhook payload templates and action params

**Helper: `getNestedValue`** (same pattern as condition-evaluator, or import from a shared location — since both files need it, define it in this file too or create a tiny shared util. Prefer duplicating the 5-line function to avoid an import chain.)

**Helper: `buildTriggerContext`**
```typescript
export function buildTriggerContext(
  eventData: Record<string, unknown>
): Record<string, unknown>
```
Maps flat event data into the nested variable namespace that templates use. For example:
- `eventData.contactName` -> `{ contacto: { nombre: eventData.contactName } }`
- `eventData.orderId` -> `{ orden: { id: eventData.orderId } }`
- `eventData.tagName` -> `{ tag: { nombre: eventData.tagName } }`
- `eventData.messageContent` -> `{ mensaje: { contenido: eventData.messageContent } }`
- `eventData.previousStageName` -> `{ orden: { stage_anterior: eventData.previousStageName } }`
- `eventData.newStageName` -> `{ orden: { stage_nuevo: eventData.newStageName } }`
- `eventData.pipelineName` -> `{ orden: { pipeline: eventData.pipelineName } }`
- `eventData.taskTitle` -> `{ tarea: { titulo: eventData.taskTitle } }`

This maps English camelCase event data to Spanish dot-path variables that users see in the builder. Keep the mapping explicit (not dynamic) for clarity.

All variable paths must match what's defined in VARIABLE_CATALOG in constants.ts.
  </action>
  <verify>Verify inline: resolveVariables("Hola {{contacto.nombre}}", { contacto: { nombre: "Juan" } }) returns "Hola Juan". Verify missing vars preserved: resolveVariables("{{foo}}", {}) returns "{{foo}}". Verify null handling: resolveVariables("{{x}}", { x: null }) returns "". TypeScript compiles.</verify>
  <done>Variable resolver handles string templates, recursive object templates, null values, missing variables, and builds trigger context from event data. All variable paths match VARIABLE_CATALOG.</done>
</task>

</tasks>

<verification>
1. evaluateConditionGroup correctly handles AND, OR, nested groups, empty groups
2. All condition operators work (equals, contains, in, gt, lt, exists, etc.)
3. resolveVariables replaces {{path}} with context values
4. resolveVariablesInObject handles nested objects and arrays
5. buildTriggerContext maps event data to Spanish variable namespaces
6. Both files compile without TypeScript errors
</verification>

<success_criteria>
- Condition evaluator evaluates nested AND/OR groups with all operators
- Variable resolver replaces template variables from trigger context
- Both handle edge cases without throwing (null, missing, empty)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/17-crm-automations-engine/17-02-SUMMARY.md`
</output>
