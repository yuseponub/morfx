---
phase: 16.1-engine-unification
plan: 02
type: execute
wave: 2
depends_on: ["16.1-01"]
files_modified:
  - src/lib/agents/somnio/somnio-agent.ts
autonomous: true
note: "Plan 02 does NOT depend on Plan 03 (adapters). SomnioAgent imports from engine/types.ts (Plan 01) for AgentSessionLike only. It does NOT import any adapter implementations. SomnioAgent is pure business logic that returns output signals — the UnifiedEngine in Plan 04 calls adapters based on those signals."

must_haves:
  truths:
    - "SomnioAgent.processMessage() contains the full business logic flow: ingest check, implicit yes, intent detection, orchestration, state updates, order signaling"
    - "handleIngestMode returns explicit result instead of mutating currentState parameter"
    - "checkImplicitYes returns explicit result instead of mutating currentState parameter"
    - "Mock session building preserves intentsVistos BEFORE current intent for primera_vez/siguientes detection"
    - "forceIntent logic (skip intent detection, skip templates on compra_confirmada) is in the agent, not in the engine"
  artifacts:
    - path: "src/lib/agents/somnio/somnio-agent.ts"
      provides: "SomnioAgent class with all business logic extracted from both engines"
      exports: ["SomnioAgent", "SomnioAgentInput", "SomnioAgentOutput"]
  key_links:
    - from: "src/lib/agents/somnio/somnio-agent.ts"
      to: "src/lib/agents/engine/types.ts"
      via: "imports AgentSessionLike, EngineAdapters"
      pattern: "import.*from.*engine/types"
    - from: "src/lib/agents/somnio/somnio-agent.ts"
      to: "src/lib/agents/somnio/somnio-orchestrator.ts"
      via: "uses orchestrator.orchestrate()"
      pattern: "orchestrator\\.orchestrate"
    - from: "src/lib/agents/somnio/somnio-agent.ts"
      to: "src/lib/agents/somnio/ingest-manager.ts"
      via: "uses ingestManager.handleMessage()"
      pattern: "ingestManager\\.handleMessage"
---

<objective>
Extract the shared Somnio business logic from both SandboxEngine and SomnioEngine into a single SomnioAgent class.

Purpose: This is the core of the unification — one source of truth for all flow logic (~950 lines). The UnifiedEngine will delegate to SomnioAgent for all business decisions.
Output: `src/lib/agents/somnio/somnio-agent.ts` with the full Somnio processing pipeline.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/16.1-engine-unification/16.1-CONTEXT.md
@.planning/phases/16.1-engine-unification/16.1-RESEARCH.md
@.planning/phases/16.1-engine-unification/16.1-01-SUMMARY.md

Critical source files:
@src/lib/sandbox/sandbox-engine.ts (reference implementation — ALL behavior must be preserved)
@src/lib/agents/somnio/somnio-engine.ts (production implementation — behavior to merge)
@src/lib/agents/engine/types.ts (adapter interfaces from Plan 01)
@src/lib/agents/somnio/somnio-orchestrator.ts (orchestrate() signature)
@src/lib/agents/somnio/ingest-manager.ts (handleMessage() signature)
@src/lib/agents/somnio/message-classifier.ts (classify() signature)
@src/lib/agents/somnio/data-extractor.ts (mergeExtractedData, hasCriticalData)
@src/lib/agents/somnio/config.ts (somnioAgentConfig)
@src/lib/agents/intent-detector.ts (detect() signature)
@src/lib/agents/registry.ts (agentRegistry.get())
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SomnioAgent class with full business logic</name>
  <files>src/lib/agents/somnio/somnio-agent.ts</files>
  <action>
Create `src/lib/agents/somnio/somnio-agent.ts` — the single source of truth for Somnio agent business logic.

**Architecture:** The SomnioAgent receives adapters and produces output. It orchestrates the Somnio-specific flow but delegates ALL I/O to adapters. The agent owns:
- Ingest mode handling (handleIngestMode)
- Implicit yes detection (checkImplicitYes)
- Intent detection (via IntentDetector)
- Orchestration (via SomnioOrchestrator)
- State update computation
- Order decision (shouldCreateOrder flag)
- Timer signal decisions
- Debug info collection

**Input type (SomnioAgentInput):**
```typescript
interface SomnioAgentInput {
  message: string
  session: AgentSessionLike      // From storage adapter
  history: { role: 'user' | 'assistant'; content: string }[]  // From storage adapter
  turnNumber: number
  forceIntent?: string
}
```

**Output type (SomnioAgentOutput):**
```typescript
interface SomnioAgentOutput {
  success: boolean
  // Messages to send (sandbox: display, production: WhatsApp)
  messages: string[]
  // Response templates from orchestrator (production needs these for MessageSequencer)
  templates?: Array<{ content: string; [key: string]: any }>
  // Orchestrator intent name (production needs for buildSequence)
  orchestratorIntent?: string
  // State updates to persist
  stateUpdates: {
    newMode?: string
    newIntentsVistos: string[]
    newTemplatesEnviados: string[]
    newDatosCapturados: Record<string, string>
    newPackSeleccionado: any
    newIngestStatus?: any  // IngestStatus for sandbox debug
  }
  // Order creation signal
  shouldCreateOrder: boolean
  orderData?: {
    datosCapturados: Record<string, string>
    packSeleccionado: any
  }
  // Timer signals accumulated during processing
  timerSignals: Array<{ type: 'start' | 'reevaluate' | 'cancel'; reason?: string }>
  // Token usage
  totalTokens: number
  tokenDetails: any[]  // ModelTokenEntry[]
  // Intent info for debug
  intentInfo?: any  // IntentInfo
  // Tools for debug
  tools: any[]  // ToolExecution[]
  // Error
  error?: { code: string; message: string }
}
```

**CRITICAL REFACTORING — State mutation pattern:**

Both SandboxEngine's handleIngestMode (line 539) and checkImplicitYes (line 653) intentionally MUTATE `currentState` as a communication channel. In SomnioAgent, refactor this to explicit return values:

```typescript
// Instead of mutating currentState.currentMode:
interface IngestModeResult {
  handled: boolean           // true = return early (silent), false = continue
  earlyReturn?: SomnioAgentOutput  // If handled=true, return this
  modeChanged?: string       // If ingest completed, new mode (e.g., 'ofrecer_promos')
  updatedData?: Record<string, string>  // Merged datos
  updatedIngestStatus?: any  // New IngestStatus
  timerSignal?: { type: 'start' | 'reevaluate' | 'cancel'; reason?: string }
}
```

After handleIngestMode returns, the main processMessage() consumes these results explicitly:

```typescript
async processMessage(input: SomnioAgentInput): Promise<SomnioAgentOutput> {
  let justCompletedIngest = false
  let currentMode = input.session.current_mode ?? 'bienvenida'
  let currentData = { ...input.session.state.datosCapturados }
  let currentIngestStatus = input.session.state.ingestStatus
  const timerSignals: Array<{ type: 'start' | 'reevaluate' | 'cancel'; reason?: string }> = []

  // --- Consume IngestModeResult ---
  if (currentMode === 'collecting_data') {
    const ingestResult: IngestModeResult = await this.handleIngestMode(input, currentMode, currentData)
    if (ingestResult.handled && ingestResult.earlyReturn) {
      return ingestResult.earlyReturn  // Silent accumulation — exit early
    }
    if (ingestResult.modeChanged) {
      justCompletedIngest = (ingestResult.modeChanged === 'ofrecer_promos')
      currentMode = ingestResult.modeChanged
    }
    if (ingestResult.updatedData) currentData = ingestResult.updatedData
    if (ingestResult.updatedIngestStatus) currentIngestStatus = ingestResult.updatedIngestStatus
    if (ingestResult.timerSignal) timerSignals.push(ingestResult.timerSignal)
  }

  // --- Consume ImplicitYesResult ---
  if (currentMode !== 'collecting_data' && currentMode !== 'ofrecer_promos') {
    const implicitResult: ImplicitYesResult = await this.checkImplicitYes(input, currentMode, currentData)
    if (implicitResult.handled && implicitResult.earlyReturn) {
      return implicitResult.earlyReturn  // Partial data transition — exit early
    }
    if (implicitResult.modeChanged) {
      justCompletedIngest = (implicitResult.modeChanged === 'ofrecer_promos')
      currentMode = implicitResult.modeChanged
    }
    if (implicitResult.updatedData) currentData = implicitResult.updatedData
    if (implicitResult.updatedIngestStatus) currentIngestStatus = implicitResult.updatedIngestStatus
    if (implicitResult.timerSignal) timerSignals.push(implicitResult.timerSignal)
  }

  // Continue with intent detection using justCompletedIngest, currentMode, currentData...
  // ...
}
```

This replaces the old mutation pattern where `currentState.currentMode = newMode` was set inside helper functions.

Same pattern for checkImplicitYes:
```typescript
interface ImplicitYesResult {
  handled: boolean
  earlyReturn?: SomnioAgentOutput
  modeChanged?: string
  updatedData?: Record<string, string>
  updatedIngestStatus?: any
  timerSignal?: { type: 'start' | 'reevaluate' | 'cancel'; reason?: string }
}
```

**Implementation flow (mirrors sandbox-engine.ts exactly, which is the reference):**

1. Get agent config from registry
2. Initialize tracking variables (tools, totalTokens, tokenDetails, ingestStatus, timerSignals)
3. **Check ingest mode** (if currentMode === 'collecting_data'):
   - Call handleIngestMode() — returns IngestModeResult
   - If `handled && earlyReturn`: return early (silent accumulation)
   - If `modeChanged === 'ofrecer_promos'`: set `justCompletedIngest = true`
4. **Check implicit yes** (if NOT collecting_data AND NOT ofrecer_promos):
   - Call checkImplicitYes() — returns ImplicitYesResult
   - If `handled && earlyReturn`: return (partial data, transition to collecting_data)
   - If `modeChanged === 'ofrecer_promos'`: set `justCompletedIngest = true`
5. **Detect intent** (or force):
   - If `justCompletedIngest || forceIntent`: build forced intent
   - Else: call IntentDetector.detect()
6. **Update intentsVistos** (add current intent if not present)
7. **Handle handoff** (if action === 'handoff')
8. **Build mock session** for orchestrator:
   - CRITICAL: Use intentsVistos BEFORE adding current intent (preserves primera_vez detection)
   - Build AgentSessionLike from session + current state overrides
9. **Orchestrate** via SomnioOrchestrator
   - Skip validation if forceIntent (pass `{ skipValidation: true }`)
10. **Build new state** from orchestrator result
11. **Timer signal decisions:**
    - 8b: Start timer on transition to collecting_data (no prior signal)
    - Two-step: If justCompletedIngest + ofrecer_promos -> cancel (from ingest) + start (promo timer)
    - Re-evaluate on any other mode transition
12. **Extract messages:**
    - Skip templates if forceIntent === 'compra_confirmada'
    - Collect response + template contents
13. **Signal order creation** if orchestratorResult.shouldCreateOrder
14. **Return SomnioAgentOutput** with all accumulated data

**What the agent does NOT do (adapter territory):**
- Read/write to DB (storage adapter)
- Send actual messages (messaging adapter)
- Create actual orders (orders adapter)
- Emit Inngest events (timer adapter)
- Build DebugTurn objects (debug adapter)

**Key imports:**
- `ClaudeClient` from '../claude-client'
- `IntentDetector` from '../intent-detector'
- `SomnioOrchestrator` from './somnio-orchestrator'
- `IngestManager` from './ingest-manager'
- `MessageClassifier` from './message-classifier'
- `mergeExtractedData, hasCriticalData` from './data-extractor'
- `somnioAgentConfig` from './config'
- `agentRegistry` from '../registry'
- `AgentSessionLike` from '../engine/types'

The class constructor creates all Somnio components (ClaudeClient, IntentDetector, SomnioOrchestrator, IngestManager, MessageClassifier). These are NOT injectable — they're direct dependencies per CONTEXT.md.

CRITICAL PRESERVATION LIST — verify each is present in the final code:
1. Ingest mode complete flow (datos/pregunta/mixto/irrelevante classification, silent accumulation)
2. Implicit yes (datos outside collecting_data → transition)
3. forceIntent (skip detection, 100% confidence, skip templates on compra_confirmada)
4. Timer signals (start on collecting_data entry, cancel+start on ingest complete→promos, reevaluate on other transitions)
5. IngestStatus tracking with timeline
6. Mock session intentsVistos ordering (BEFORE current intent)
7. State mutation refactored to explicit returns
8. Two-step timer signal pattern preserved via timerSignals array
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Grep for "currentState.currentMode =" in somnio-agent.ts — should NOT exist (mutation eliminated)
3. SomnioAgent exports processMessage, SomnioAgentInput, SomnioAgentOutput
  </verify>
  <done>SomnioAgent class contains all Somnio business logic. handleIngestMode and checkImplicitYes use explicit return values instead of state mutation. All 8 preservation items verified present.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. SomnioAgent.processMessage() handles all paths: silent ingest, implicit yes, forced intent, normal intent, handoff
3. No direct DB calls, no Inngest calls, no MessageSequencer calls in the agent
4. State mutation pattern refactored to explicit return values
5. Mock session builds intentsVistos BEFORE current intent
</verification>

<success_criteria>
- Single SomnioAgent class with ~400-600 lines of flow logic
- All 11 sandbox features preserved (per CONTEXT.md specifics list)
- No I/O operations in the agent (all delegated to adapters via output signals)
- Compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/16.1-engine-unification/16.1-02-SUMMARY.md`
</output>
