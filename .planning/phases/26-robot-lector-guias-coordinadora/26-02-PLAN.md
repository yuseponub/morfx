---
phase: 26-robot-lector-guias-coordinadora
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - robot-coordinadora/src/types/index.ts
  - robot-coordinadora/src/adapters/coordinadora-adapter.ts
  - robot-coordinadora/src/api/server.ts
  - src/inngest/functions/robot-orchestrator.ts
  - src/app/api/inngest/route.ts
  - src/app/api/webhooks/robot-callback/route.ts
autonomous: true

must_haves:
  truths:
    - "Robot service has a /api/buscar-guias endpoint that reads pedido->guide mappings from the portal"
    - "Inngest guide-lookup orchestrator dispatches to robot and waits for batch completion"
    - "Callback route distinguishes guide_lookup results and writes carrier_guide_number instead of tracking_number"
    - "Pendiente results (no guide found) are treated as success with null guide, counting toward completion"
  artifacts:
    - path: "robot-coordinadora/src/adapters/coordinadora-adapter.ts"
      provides: "buscarGuiasPorPedidos method"
      contains: "buscarGuiasPorPedidos"
    - path: "robot-coordinadora/src/api/server.ts"
      provides: "/api/buscar-guias endpoint"
      contains: "buscar-guias"
    - path: "src/inngest/functions/robot-orchestrator.ts"
      provides: "guideLookupOrchestrator function"
      contains: "guide-lookup-orchestrator"
    - path: "src/app/api/webhooks/robot-callback/route.ts"
      provides: "job_type-aware callback routing"
      contains: "guide_lookup"
  key_links:
    - from: "src/inngest/functions/robot-orchestrator.ts"
      to: "robot-coordinadora /api/buscar-guias"
      via: "HTTP POST dispatch"
      pattern: "buscar-guias"
    - from: "robot-coordinadora/src/api/server.ts"
      to: "src/app/api/webhooks/robot-callback/route.ts"
      via: "per-pedido callback with carrierGuideNumber"
      pattern: "callbackUrl"
    - from: "src/app/api/webhooks/robot-callback/route.ts"
      to: "src/lib/domain/robot-jobs.ts"
      via: "updateJobItemResult with guide data"
      pattern: "updateJobItemResult"
---

<objective>
Build the robot service endpoint for guide lookup, the Inngest orchestrator function, and extend the callback route to handle guide results.

Purpose: Connects the guide reading Playwright automation to the MorfX domain layer so that portal guide numbers flow back to CRM orders via the established callback pattern.
Output: New robot endpoint, new Inngest function, and extended callback route.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/26-robot-lector-guias-coordinadora/26-CONTEXT.md
@.planning/phases/26-robot-lector-guias-coordinadora/26-RESEARCH.md
@.planning/phases/26-robot-lector-guias-coordinadora/26-01-SUMMARY.md

@robot-coordinadora/src/api/server.ts
@robot-coordinadora/src/adapters/coordinadora-adapter.ts
@robot-coordinadora/src/types/index.ts
@src/inngest/functions/robot-orchestrator.ts
@src/app/api/inngest/route.ts
@src/app/api/webhooks/robot-callback/route.ts
@src/lib/domain/robot-jobs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Robot service — guide lookup endpoint and adapter method</name>
  <files>
    robot-coordinadora/src/types/index.ts
    robot-coordinadora/src/adapters/coordinadora-adapter.ts
    robot-coordinadora/src/api/server.ts
  </files>
  <action>
**In `robot-coordinadora/src/types/index.ts`:**

1. Add a new interface for guide lookup request:
   ```typescript
   /** Single pedido to look up in the guide lookup request */
   export interface GuideLookupItem {
     /** robot_job_items.id from MorfX */
     itemId: string
     /** orders.id from MorfX */
     orderId: string
     /** Coordinadora pedido number (stored in orders.tracking_number) */
     pedidoNumber: string
   }

   /** Incoming guide lookup request from MorfX (via Inngest orchestrator) */
   export interface GuideLookupRequest {
     workspaceId: string
     credentials: Credentials
     callbackUrl: string
     callbackSecret?: string
     jobId: string
     pedidoNumbers: GuideLookupItem[]
   }
   ```

2. Add a new interface for the guide lookup callback result:
   ```typescript
   /** Result reported back for guide lookup per pedido */
   export interface GuideLookupResult {
     itemId: string
     status: 'success' | 'error'
     /** The guide number found, or undefined if pendiente */
     trackingNumber?: string
     /** Whether guide was actually found or just pendiente */
     guideFound?: boolean
     errorType?: 'validation' | 'portal' | 'timeout' | 'unknown'
     errorMessage?: string
   }
   ```

**In `robot-coordinadora/src/adapters/coordinadora-adapter.ts`:**

Add a new public method `buscarGuiasPorPedidos()` to the `CoordinadoraAdapter` class. Place it after the `createGuia` method:

```typescript
/**
 * Navigate to the Coordinadora pedidos page and read the pedido->guide table.
 * Returns a Map of pedidoNumber -> guideNumber.
 * Loads the page once and reads all rows (batch optimized).
 */
async buscarGuiasPorPedidos(pedidoNumbers: string[]): Promise<Map<string, string>> {
  if (!this.page) {
    throw new Error(`${LOG_PREFIX} Cannot buscar guias: browser not initialized`)
  }

  console.log(`${LOG_PREFIX} Looking up guides for ${pedidoNumbers.length} pedidos`)

  const guiaMap = new Map<string, string>()

  try {
    // Navigate to the pedidos list page
    await this.page.goto('https://ff.coordinadora.com/panel/pedidos', {
      waitUntil: 'domcontentloaded',
      timeout: 30000,
    })

    // Wait for the table to render
    await this.page.waitForSelector('table tbody tr', {
      state: 'visible',
      timeout: 15000,
    })

    // Brief pause for full table population
    await this.page.waitForTimeout(2000)

    // Read all table rows
    const rows = await this.page.locator('table tbody tr').all()
    console.log(`${LOG_PREFIX} Found ${rows.length} rows in pedidos table`)

    // Build a Set of pedido numbers we're looking for (normalized)
    const targetPedidos = new Set(pedidoNumbers.map(p => p.trim()))

    for (const row of rows) {
      const cells = await row.locator('td').all()
      if (cells.length < 2) continue

      // Column 0 = pedido number, Column 1 = guide number
      const pedidoText = (await cells[0].textContent())?.trim() || ''
      const guiaText = (await cells[1].textContent())?.trim() || ''

      if (!pedidoText) continue

      // Check if this pedido is one we're looking for
      if (targetPedidos.has(pedidoText) && guiaText && guiaText !== '-' && guiaText !== 'N/A') {
        guiaMap.set(pedidoText, guiaText)
      }
    }

    console.log(`${LOG_PREFIX} Found guides for ${guiaMap.size}/${pedidoNumbers.length} pedidos`)
    return guiaMap
  } catch (err) {
    console.error(`${LOG_PREFIX} Error reading pedidos table:`, err)
    await this.takeScreenshot('buscar-guias-error')
    throw err
  }
}
```

IMPORTANT: The `takeScreenshot` method is already `private`. Change it to `protected` so it's accessible from subclasses if needed, OR since `buscarGuiasPorPedidos` is in the same class, `private` is fine. Keep it as `private` — it works since the method is within the same class.

**In `robot-coordinadora/src/api/server.ts`:**

1. Add imports for new types at the top: `GuideLookupRequest, GuideLookupResult` from `../types/index.js`.

2. Add a separate idempotency cache for guide lookup jobs:
   ```typescript
   const completedGuideLookups = new Map<string, { success: boolean; jobId: string }>()
   ```

3. Add a new endpoint `POST /api/buscar-guias` after the existing `POST /api/crear-pedidos-batch` endpoint:

   ```typescript
   app.post('/api/buscar-guias', (req: Request, res: Response) => {
     const body = req.body as Partial<GuideLookupRequest>

     // Validate required fields
     if (!body.workspaceId) {
       res.status(400).json({ success: false, error: 'Campo requerido: workspaceId' })
       return
     }
     if (!body.credentials || !body.credentials.username || !body.credentials.password) {
       res.status(400).json({ success: false, error: 'Campo requerido: credentials' })
       return
     }
     if (!body.callbackUrl) {
       res.status(400).json({ success: false, error: 'Campo requerido: callbackUrl' })
       return
     }
     if (!body.jobId) {
       res.status(400).json({ success: false, error: 'Campo requerido: jobId' })
       return
     }
     if (!body.pedidoNumbers || !Array.isArray(body.pedidoNumbers) || body.pedidoNumbers.length === 0) {
       res.status(400).json({ success: false, error: 'Campo requerido: pedidoNumbers (array no vacío)' })
       return
     }

     const { workspaceId, credentials, callbackUrl, callbackSecret, jobId, pedidoNumbers } = body as GuideLookupRequest

     // Idempotency cache
     const cached = completedGuideLookups.get(jobId)
     if (cached) {
       res.status(200).json(cached)
       return
     }

     // Workspace lock check
     if (isWorkspaceLocked(workspaceId)) {
       res.status(409).json({ success: false, error: 'Ya hay una operación en proceso para este workspace' })
       return
     }

     // Acknowledge immediately
     const response = { success: true, jobId }
     completedGuideLookups.set(jobId, response)
     res.status(200).json(response)

     // Process in background
     processGuideLookup(workspaceId, credentials, callbackUrl, callbackSecret, jobId, pedidoNumbers)
       .catch(err => console.error('[Server] Guide lookup fatal error:', err))
   })
   ```

4. Add the `processGuideLookup` background function AFTER the existing `processBatch` function:

   ```typescript
   async function processGuideLookup(
     workspaceId: string,
     credentials: { username: string; password: string },
     callbackUrl: string,
     callbackSecret: string | undefined,
     jobId: string,
     pedidoNumbers: GuideLookupItem[],
   ): Promise<void> {
     await withWorkspaceLock(workspaceId, async () => {
       const adapter = new CoordinadoraAdapter(credentials, workspaceId)

       try {
         await adapter.init()

         const loginSuccess = await adapter.login()
         if (!loginSuccess) {
           console.error(`[Server] Login failed for guide lookup, workspace ${workspaceId}`)
           for (const item of pedidoNumbers) {
             await reportResult(callbackUrl, {
               itemId: item.itemId,
               status: 'error',
               errorType: 'portal',
               errorMessage: 'Login fallido en el portal de Coordinadora',
             }, callbackSecret)
           }
           return
         }

         // Read the pedidos table once (batch optimized)
         const pedidoNumberStrings = pedidoNumbers.map(p => p.pedidoNumber)
         const guiaMap = await adapter.buscarGuiasPorPedidos(pedidoNumberStrings)

         // Report result for each pedido
         for (const item of pedidoNumbers) {
           const guia = guiaMap.get(item.pedidoNumber)

           const result: GuideLookupResult = {
             itemId: item.itemId,
             status: 'success',  // Always success — pendiente is not an error
             trackingNumber: guia || undefined,  // Reuse trackingNumber field for the guide
             guideFound: !!guia,
           }

           await reportResult(callbackUrl, result, callbackSecret)
         }

         console.log(`[Server] Guide lookup complete: ${guiaMap.size}/${pedidoNumbers.length} guides found`)
       } catch (err) {
         console.error(`[Server] Fatal guide lookup error for workspace ${workspaceId}:`, err)
         for (const item of pedidoNumbers) {
           await reportResult(callbackUrl, {
             itemId: item.itemId,
             status: 'error',
             errorType: 'unknown',
             errorMessage: 'Error fatal en la búsqueda de guías',
           }, callbackSecret).catch(() => {})
         }
       } finally {
         await adapter.close()
       }
     })
   }
   ```

Key design decisions:
- Guide lookup uses `status: 'success'` for ALL pedidos, whether a guide was found or not. This ensures the job counter increments and the job completes. The `trackingNumber` field is set to the guide number when found, or undefined/null when pendiente.
- NO per-order locking needed (guide lookup is a read operation, not a write).
- The `reportResult` helper already exists and is reused as-is.
- The workspace lock IS reused to prevent concurrent portal sessions (guide lookup and shipment creation use the same browser session).
  </action>
  <verify>
Run `cd robot-coordinadora && npx tsc --noEmit` to verify TypeScript compiles. If tsconfig is not set up for noEmit checking, verify the files parse correctly by reading them back.
  </verify>
  <done>
- Robot service has `/api/buscar-guias` endpoint
- CoordinadoraAdapter has `buscarGuiasPorPedidos()` method
- Types defined for guide lookup request and result
- Background processing with workspace lock and per-item callbacks
- Pendiente treated as success (counter increments, job completes)
  </done>
</task>

<task type="auto">
  <name>Task 2: Inngest guide-lookup orchestrator + callback route extension</name>
  <files>
    src/inngest/functions/robot-orchestrator.ts
    src/app/api/inngest/route.ts
    src/app/api/webhooks/robot-callback/route.ts
  </files>
  <action>
**In `src/inngest/functions/robot-orchestrator.ts`:**

Add a new Inngest function `guideLookupOrchestrator` AFTER the existing `robotOrchestrator` function. Follow the same pattern exactly:

```typescript
/**
 * Guide Lookup Orchestrator
 *
 * Dispatches a guide lookup job to the robot-coordinadora service via HTTP,
 * then waits for the batch_completed callback event with a dynamic timeout.
 *
 * retries: 0 — a retry would re-read the same portal data unnecessarily
 * and could cause duplicate callbacks. Consistent with robot-orchestrator.
 *
 * Timeout per pedido is shorter (10s vs 30s) since guide lookup reads one
 * page for all pedidos vs navigating per-order forms.
 */
const guideLookupOrchestrator = inngest.createFunction(
  {
    id: 'guide-lookup-orchestrator',
    retries: 0,
    onFailure: async ({ event }) => {
      const originalEvent = (event as any).data?.event
      const jobId = originalEvent?.data?.jobId as string | undefined
      const workspaceId = originalEvent?.data?.workspaceId as string | undefined
      const errorMessage = (event as any).data?.error?.message ?? 'Unknown error'

      console.error(`[guide-lookup-orchestrator] Function failed for job ${jobId}:`, errorMessage)

      if (jobId && workspaceId) {
        await updateJobStatus(
          { workspaceId, source: 'inngest-orchestrator' },
          { jobId, status: 'failed' }
        )
        console.log(`[guide-lookup-orchestrator] Marked job ${jobId} as failed via onFailure`)
      }
    },
  },
  { event: 'robot/guide-lookup.submitted' as any },
  async ({ event, step }) => {
    const { jobId, workspaceId, credentials, pedidoNumbers } = event.data

    console.log(`[guide-lookup-orchestrator] Starting job ${jobId} with ${pedidoNumbers.length} pedidos`)

    // Step 1: Mark job as processing
    await step.run('mark-processing', async () => {
      const result = await updateJobStatus(
        { workspaceId, source: 'inngest-orchestrator' },
        { jobId, status: 'processing' }
      )
      if (!result.success) {
        throw new Error(`Failed to mark job processing: ${result.error}`)
      }
    })

    // Step 2: Dispatch to robot service
    await step.run('dispatch-to-robot', async () => {
      const robotUrl = process.env.ROBOT_COORDINADORA_URL
      if (!robotUrl) throw new Error('ROBOT_COORDINADORA_URL env var not set')

      const callbackUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/robot-callback`
      const callbackSecret = process.env.ROBOT_CALLBACK_SECRET
      if (!callbackSecret) throw new Error('ROBOT_CALLBACK_SECRET env var not set')

      console.log(`[guide-lookup-orchestrator] Dispatching job ${jobId} to ${robotUrl}/api/buscar-guias`)

      const response = await fetch(`${robotUrl}/api/buscar-guias`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Callback-Secret': callbackSecret,
        },
        body: JSON.stringify({
          workspaceId,
          credentials,
          callbackUrl,
          callbackSecret,
          jobId,
          pedidoNumbers: pedidoNumbers.map((p: any) => ({
            itemId: p.itemId,
            orderId: p.orderId,
            pedidoNumber: p.pedidoNumber,
          })),
        }),
      })

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unknown error')
        throw new Error(`Robot service error ${response.status}: ${errorText}`)
      }

      return response.json()
    })

    // Step 3: Settle sleep
    await step.sleep('settle', '2s')

    // Step 4: Wait for batch completion
    // Timeout: shorter than shipment creation (10s per pedido + 3 min margin)
    // Guide lookup reads one page for all pedidos, so it's much faster.
    const timeoutMs = (pedidoNumbers.length * 10_000) + (3 * 60_000)

    console.log(`[guide-lookup-orchestrator] Waiting for batch completion (timeout: ${Math.round(timeoutMs / 1000)}s)`)

    const batchCompleted = await step.waitForEvent('wait-for-batch', {
      event: 'robot/job.batch_completed',
      timeout: `${timeoutMs}ms`,
      if: `async.data.jobId == "${jobId}"`,
    })

    if (!batchCompleted) {
      console.error(`[guide-lookup-orchestrator] Job ${jobId} timed out`)
      await step.run('mark-timeout-failed', async () => {
        await updateJobStatus(
          { workspaceId, source: 'inngest-orchestrator' },
          { jobId, status: 'failed' }
        )
      })
      return { status: 'failed', reason: 'timeout', jobId }
    }

    console.log(
      `[guide-lookup-orchestrator] Job ${jobId} completed: ${batchCompleted.data.successCount} success, ${batchCompleted.data.errorCount} errors`
    )

    return {
      status: 'completed',
      jobId,
      successCount: batchCompleted.data.successCount,
      errorCount: batchCompleted.data.errorCount,
    }
  }
)
```

Update the export to include both functions:
```typescript
export const robotOrchestratorFunctions = [robotOrchestrator, guideLookupOrchestrator]
```

**In `src/app/api/inngest/route.ts`:**

No changes needed — `robotOrchestratorFunctions` is already spread into the functions array, and we just added `guideLookupOrchestrator` to that array. Verify the import/spread is already correct.

**In `src/app/api/webhooks/robot-callback/route.ts`:**

The callback route needs to be extended to handle guide lookup results. There are TWO layers involved:

**Layer responsibilities (AUTHORITATIVE):**
- **Domain layer** (`updateJobItemResult` in Plan 01): Handles field routing internally — it fetches the parent job's `job_type` and routes `trackingNumber` to either `tracking_number` or `carrier_guide_number` on the order. The callback route does NOT need to know about field routing.
- **Callback route**: Needs parentJob.job_type ONLY to guard the `emitRobotCoordCompleted` trigger (which must NOT fire for guide_lookup jobs, since those emit `field.changed` from the domain layer instead).

**Changes:**

1. After looking up the item (section 3), add a MINIMAL supabase query for the `emitRobotCoordCompleted` guard ONLY:
   ```typescript
   // Minimal lookup: only for the emitRobotCoordCompleted guard below.
   // Field routing (tracking_number vs carrier_guide_number) is handled
   // entirely by the domain layer in updateJobItemResult.
   const { data: parentJob } = await supabase
     .from('robot_jobs')
     .select('job_type')
     .eq('id', item.job_id)
     .single()
   ```

2. The domain layer (`updateJobItemResult` from Plan 01) handles field routing internally — it fetches the parent job's `job_type` and decides whether to write `tracking_number` or `carrier_guide_number`. The callback route does NOT modify the `updateJobItemResult` call at all.

3. In section 5 (trigger emission), the existing code only fires `emitRobotCoordCompleted` for `status === 'success' && trackingNumber`. For guide_lookup jobs, `emitFieldChanged` fires automatically through `updateOrder` in the domain layer. So the trigger emission in the callback route must be SKIPPED for guide_lookup jobs:

   Change the condition in section 5 from:
   ```typescript
   if (status === 'success' && trackingNumber) {
   ```
   to:
   ```typescript
   if (status === 'success' && trackingNumber && parentJob?.job_type !== 'guide_lookup') {
   ```

   This ensures `emitRobotCoordCompleted` only fires for create_shipment callbacks (guide_lookup triggers fire through `updateOrder` -> `emitFieldChanged` in the domain layer).
  </action>
  <verify>
Run `npx tsc --noEmit` from the MorfX project root. No TypeScript errors. Verify the robot-coordinadora project also compiles with `cd robot-coordinadora && npx tsc --noEmit`.
  </verify>
  <done>
- guideLookupOrchestrator Inngest function created and registered
- Robot callback route extended with job_type-aware routing
- emitRobotCoordCompleted skipped for guide_lookup (field.changed fires from domain)
- Batch completion reuses existing robot/job.batch_completed event
  </done>
</task>

</tasks>

<verification>
1. Robot service has `/api/buscar-guias` endpoint with validation, idempotency, workspace locking
2. CoordinadoraAdapter.buscarGuiasPorPedidos() navigates to pedidos page and reads table
3. guideLookupOrchestrator is registered in Inngest serve route via the exports array
4. Callback route correctly distinguishes guide_lookup from create_shipment
5. All TypeScript compiles in both projects
6. No breaking changes to existing create_shipment flow
</verification>

<success_criteria>
- Robot service compiles and has the new endpoint
- Inngest guide-lookup orchestrator is registered
- Callback route routes guide results to carrier_guide_number field
- Pendiente (no guide) results count toward batch completion
</success_criteria>

<output>
After completion, create `.planning/phases/26-robot-lector-guias-coordinadora/26-02-SUMMARY.md`
</output>
