---
phase: 22-robot-coordinadora-service
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - robot-coordinadora/src/adapters/coordinadora-adapter.ts

autonomous: true

must_haves:
  truths:
    - "The adapter can log into ff.coordinadora.com using provided credentials"
    - "The adapter fills all 15+ form fields on the Coordinadora portal to create a shipment"
    - "The adapter detects success (SweetAlert2 success modal) and extracts the pedido number"
    - "The adapter detects failure (SweetAlert2 error modal) and extracts the error message"
    - "The adapter persists and reuses cookies per workspace to avoid re-login"
    - "The adapter handles MUI Autocomplete city selection using the proven type-wait-ArrowDown-Enter pattern"
  artifacts:
    - path: "robot-coordinadora/src/adapters/coordinadora-adapter.ts"
      provides: "Complete Playwright automation for Coordinadora portal"
      exports: ["CoordinadoraAdapter"]
      min_lines: 250
  key_links:
    - from: "robot-coordinadora/src/adapters/coordinadora-adapter.ts"
      to: "robot-coordinadora/src/types/index.ts"
      via: "import { PedidoInput, Credentials, GuiaResult }"
      pattern: "import.*PedidoInput.*from"
    - from: "CoordinadoraAdapter.login()"
      to: "ff.coordinadora.com"
      via: "Playwright page.goto + form fill"
      pattern: "ff\\.coordinadora\\.com"
    - from: "CoordinadoraAdapter.createGuia()"
      to: "Portal form fields"
      via: "Playwright fill/click/keyboard for each form field"
      pattern: "identificacion_destinatario"
---

<objective>
Port the CoordinadoraAdapter class from the existing robot source code to the new microservice. This is the core Playwright automation that logs into ff.coordinadora.com, fills shipment forms, submits orders, and detects success/failure via SweetAlert2 modals.

Purpose: This adapter is the most critical and proven piece of the robot. Its CSS selectors, form interaction patterns, and timing delays are battle-tested in production. Porting it faithfully (not rewriting) minimizes risk.

Output: A single CoordinadoraAdapter class that encapsulates ALL Playwright interaction with the Coordinadora portal.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/22-robot-coordinadora-service/22-CONTEXT.md
@.planning/phases/22-robot-coordinadora-service/22-RESEARCH.md
@.planning/phases/22-robot-coordinadora-service/22-01-SUMMARY.md

# Key reference: Types defined in Plan 01
# robot-coordinadora/src/types/index.ts -- PedidoInput, Credentials, GuiaResult
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CoordinadoraAdapter class scaffold with init, login, cookies, close, and helpers</name>
  <files>robot-coordinadora/src/adapters/coordinadora-adapter.ts</files>
  <action>
Create the CoordinadoraAdapter class that encapsulates all Playwright interaction with ff.coordinadora.com. This is a PORT of the existing proven robot code, NOT a rewrite. Follow the existing patterns faithfully.

**This task creates the class structure, init, login, session management, close, and helpers. Task 2 adds createGuia (form fill + result detection).**

**Class structure:**

```typescript
import { chromium, Browser, BrowserContext, Page } from 'playwright'
import { PedidoInput, Credentials, GuiaResult } from '../types/index.js'
import fs from 'fs'
import path from 'path'

export class CoordinadoraAdapter {
  private browser: Browser | null = null
  private context: BrowserContext | null = null
  private page: Page | null = null
  private credentials: Credentials
  private workspaceId: string
  private cookiesPath: string

  constructor(credentials: Credentials, workspaceId: string) {
    this.credentials = credentials
    this.workspaceId = workspaceId
    // Cookies scoped per workspace to prevent cross-contamination
    this.cookiesPath = path.join(process.cwd(), 'storage', 'sessions', `${workspaceId}-cookies.json`)
  }
```

**Methods to implement in this task:**

1. **async init()**: Launch Chromium headless with these args:
   - `--disable-dev-shm-usage` (prevents Docker /dev/shm OOM)
   - `--no-sandbox` (required in Docker)
   - `--disable-gpu`
   - Create browser context and page
   - Load saved cookies if they exist (per-workspace file)
   - Create `storage/sessions/` directory if it doesn't exist

2. **async login(): Promise<boolean>**:
   - Navigate to `https://ff.coordinadora.com`
   - Check if already logged in: if URL contains `/panel`, session is still valid, return true
   - If on login page: fill `input[name="usuario"]` with credentials.username, fill `input[name="clave"]` with credentials.password
   - Click `button:has-text("Ingresar")` (or button with type submit on the login form)
   - Wait for navigation (max 15 seconds)
   - If URL now contains `/panel`, login succeeded
   - Save cookies to disk (per-workspace file) using `context.cookies()`
   - Return true/false

3. **async navigateToForm()**: Navigate to `https://ff.coordinadora.com/panel/agregar_pedidos/coordinadora` and wait for the form to be ready (wait for `input[name="identificacion_destinatario"]` to be visible)

4. **async close()**: Close browser, context, page. ALWAYS call this in a try/finally. Set all references to null.

5. **private async saveCookies()**: Save `context.cookies()` to the per-workspace cookies file as JSON.

6. **private async loadCookies()**: If cookies file exists, read and call `context.addCookies()`.

7. **private async takeScreenshot(name: string)**: Save a screenshot to `storage/artifacts/${name}-${Date.now()}.png`. Used for debugging on errors. Create directory if needed.

8. **async createGuia(pedido: PedidoInput): Promise<GuiaResult>** -- Add a STUB that throws `new Error('Not implemented -- see Task 2')`. This allows the file to compile and satisfies the type contract while Task 2 fills in the real implementation.

**Error handling:**
- If login fails, take a screenshot and return false.

**Logging:**
- Console.log with prefix `[CoordinadoraAdapter]` for all significant actions
- Log: init, login attempt, login success/failure, close
- Log errors with full stack trace
  </action>
  <verify>
- `cd robot-coordinadora && npx tsc --noEmit` compiles without errors
- `grep "export class CoordinadoraAdapter" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds the class
- `grep "ff.coordinadora.com" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds the portal URL
- `grep "async login" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds the login method
- `grep "async close" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds the close method
- `grep "saveCookies" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds cookie persistence
  </verify>
  <done>
CoordinadoraAdapter class scaffold with init, login, cookie session persistence, close, screenshot helper, and a createGuia stub compiles cleanly. Ready for Task 2 to implement createGuia.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement createGuia method with form fill, MUI autocomplete, and SweetAlert2 detection</name>
  <files>robot-coordinadora/src/adapters/coordinadora-adapter.ts</files>
  <action>
Replace the createGuia stub from Task 1 with the full implementation. This is THE CRITICAL METHOD -- the core Playwright form automation.

**async createGuia(pedido: PedidoInput): Promise<GuiaResult>**:
   - Call `navigateToForm()` to ensure clean form state
   - Fill ALL form fields in order. Use the proven selectors:

     **Personal data fields:**
     - `input[name="identificacion_destinatario"]` -> pedido.identificacion
     - `input[name="nombre_destinatario"]` -> pedido.nombres
     - `input[name="apellido_destinatario"]` -> pedido.apellidos
     - `input[name="direccion_destinatario"]` -> pedido.direccion
     - `input[name="celular_destinatario"]` -> pedido.celular
     - `input[name="email_destinatario"]` -> pedido.email

     **City field (MUI Autocomplete -- CRITICAL PATTERN):**
     The city field uses Material-UI Autocomplete. You CANNOT just `.fill()` it. The proven pattern:
     ```typescript
     // Find the city input (MUI Autocomplete generates dynamic IDs)
     const cityInput = this.page.locator('input[id^="mui-"]').first()
     // OR: look for the autocomplete by role/label if mui-id is unreliable
     await cityInput.click()
     await cityInput.fill('')  // Clear first
     await cityInput.fill(pedido.ciudad) // Type the city name
     await this.page.waitForTimeout(1500)  // Wait for autocomplete dropdown
     await this.page.keyboard.press('ArrowDown')  // Select first option
     await this.page.waitForTimeout(300)
     await this.page.keyboard.press('Enter')  // Confirm selection
     await this.page.waitForTimeout(500)
     ```
     This is the EXACT pattern from the working robot. Do NOT simplify it.

     **Shipment data fields:**
     - `input[name="referencia"]` -> pedido.referencia
     - `input[name="unidades"]` -> String(pedido.unidades)
     - `input[name="valor_declarado"]` -> String(pedido.valorDeclarado)
     - `input[name="peso"]` -> String(pedido.peso)
     - `input[name="alto"]` -> String(pedido.alto)
     - `input[name="largo"]` -> String(pedido.largo)
     - `input[name="ancho"]` -> String(pedido.ancho)

     **COD (recaudo) field:**
     - If `pedido.esRecaudoContraentrega === true`:
       - Find the recaudo/COD toggle or checkbox and enable it
       - Set the COD amount: `input[name="valor_recaudo"]` -> String(pedido.totalConIva)

     **Submit:**
     - Click `button[type="submit"]` that has text "Enviar Pedido" (or the form submit button)
     - Wait 5 seconds for SweetAlert2 response (the portal does server-side validation)

     **Detect result (SweetAlert2):**
     - Check for `.swal2-success` (success modal) -> extract pedido number from modal text
     - Check for `.swal2-error` (error modal) -> extract error message from `.swal2-html-container` or `.swal2-content`
     - Click `.swal2-confirm` to close the modal
     - **CRITICAL:** Return `{ success: true, numeroPedido }` on success or `{ success: false, error }` on failure. The field name MUST be `numeroPedido` (matching the `GuiaResult` type in `types/index.ts`). Do NOT use `numeroGuia` -- the RESEARCH.md code examples use that name but the type contract says `numeroPedido`.

   **IMPORTANT NOTES ON SELECTORS:**
   - The exact selector names above come from the existing working robot code AND portal inspection.
   - Some selectors may use slightly different attribute names (e.g., `nombre_destinatario` vs `nombres_destinatario`). The RESEARCH.md documents the proven ones from the existing robot.
   - If the portal uses a different naming convention, the adapter MUST match the portal's actual field names. The form field names listed above are the BEST KNOWN values. They may need runtime adjustment (this is expected for portal automation).
   - Always use `page.waitForTimeout()` between form interactions. The portal is a React SPA with async state updates.
   - Use `fill('')` before `fill(value)` on each field to clear previous values (important when reusing the form for multiple orders).

**Error handling:**
- Wrap each form fill in try/catch. If a field fill fails, log the error and continue to the next field (some optional fields may not be present).
- If createGuia throws, return `{ success: false, error: message }` instead of letting the error propagate.
- If the SweetAlert2 modal doesn't appear within 10 seconds of submit, take a screenshot and return `{ success: false, error: 'Timeout esperando respuesta del portal' }`.

**Logging:**
- Console.log with prefix `[CoordinadoraAdapter]` for all significant actions
- Log: form fill start, field fill (field name), submit, result detected
- Log errors with full stack trace
  </action>
  <verify>
- `cd robot-coordinadora && npx tsc --noEmit` compiles without errors
- `grep "swal2-success" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds SweetAlert2 detection
- `grep "ArrowDown" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds the MUI Autocomplete pattern
- `grep "identificacion_destinatario" robot-coordinadora/src/adapters/coordinadora-adapter.ts` finds form selectors
- `grep "numeroPedido" robot-coordinadora/src/adapters/coordinadora-adapter.ts` confirms the adapter returns `numeroPedido` (matching GuiaResult type), NOT `numeroGuia`
- The file is at least 250 lines (this is a complex adapter)
  </verify>
  <done>
createGuia method fills all form fields (personal data, MUI city autocomplete, shipment data, COD), submits, detects SweetAlert2 success/error, and returns GuiaResult with the correct `numeroPedido` field name. All proven selectors and interaction patterns from the existing robot are preserved.
  </done>
</task>

</tasks>

<verification>
1. `cd robot-coordinadora && npx tsc --noEmit` passes with zero errors
2. CoordinadoraAdapter class exports from src/adapters/coordinadora-adapter.ts
3. login() method navigates to ff.coordinadora.com and uses proven selectors
4. createGuia() fills all form fields including MUI Autocomplete city selection
5. SweetAlert2 detection for both success and error modals is implemented
6. Cookie persistence is scoped per workspace ID
7. Browser cleanup (close) is implemented
</verification>

<success_criteria>
- Single CoordinadoraAdapter class encapsulates ALL Playwright interaction
- Login, form fill, submit, result detection, and cookie management are all implemented
- MUI Autocomplete city pattern uses the proven type-wait-ArrowDown-Enter sequence
- The adapter compiles with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-robot-coordinadora-service/22-02-SUMMARY.md`
</output>
