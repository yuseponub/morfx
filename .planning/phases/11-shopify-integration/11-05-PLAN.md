---
phase: 11-shopify-integration
plan: 05
type: execute
wave: 3
depends_on: ["11-03"]
files_modified:
  - src/app/api/webhooks/shopify/route.ts
autonomous: true

must_haves:
  truths:
    - "Webhook endpoint verifies HMAC before processing"
    - "Request body is read as text for HMAC verification"
    - "Endpoint responds 200 quickly (within 5 seconds)"
    - "Duplicate webhooks are handled gracefully"
  artifacts:
    - path: "src/app/api/webhooks/shopify/route.ts"
      provides: "Shopify webhook endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/webhooks/shopify/route.ts"
      to: "src/lib/shopify/hmac.ts"
      via: "import verifyShopifyHmac"
      pattern: "import.*verifyShopifyHmac"
    - from: "src/app/api/webhooks/shopify/route.ts"
      to: "src/lib/shopify/webhook-handler.ts"
      via: "import processShopifyWebhook"
      pattern: "import.*processShopifyWebhook"
---

<objective>
Create the Shopify webhook endpoint.

Purpose: Receive and process Shopify orders/create webhooks with proper security and error handling.
Output: Webhook route handler that verifies HMAC and delegates to webhook handler.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-shopify-integration/11-CONTEXT.md
@.planning/phases/11-shopify-integration/11-RESEARCH.md

# Existing webhook pattern:
@src/app/api/webhooks/whatsapp/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shopify webhook route handler</name>
  <files>src/app/api/webhooks/shopify/route.ts</files>
  <action>
Create webhook endpoint following existing WhatsApp pattern but with Shopify-specific HMAC verification:

```typescript
// ============================================================================
// Phase 11: Shopify Webhook Endpoint
// Receives webhook events from Shopify (orders/create)
// ============================================================================

import { NextRequest, NextResponse } from 'next/server'
import { createAdminClient } from '@/lib/supabase/admin'
import { verifyShopifyHmac } from '@/lib/shopify/hmac'
import { processShopifyWebhook } from '@/lib/shopify/webhook-handler'
import type { ShopifyOrderWebhook, ShopifyIntegration } from '@/lib/shopify/types'

// ============================================================================
// WEBHOOK EVENTS (POST)
// Receives order events from Shopify
// CRITICAL: Must verify HMAC BEFORE processing
// ============================================================================

export async function POST(request: NextRequest) {
  const startTime = Date.now()

  // Step 1: Get raw body as TEXT (critical for HMAC verification)
  // DO NOT use request.json() before HMAC verification
  const rawBody = await request.text()

  // Step 2: Get required headers
  const hmacHeader = request.headers.get('X-Shopify-Hmac-SHA256')
  const webhookId = request.headers.get('X-Shopify-Webhook-Id')
  const shopDomain = request.headers.get('X-Shopify-Shop-Domain')
  const topic = request.headers.get('X-Shopify-Topic')

  // Validate required headers
  if (!hmacHeader) {
    console.warn('Shopify webhook missing HMAC header')
    return NextResponse.json({ error: 'Missing HMAC' }, { status: 401 })
  }

  if (!webhookId) {
    console.warn('Shopify webhook missing webhook ID')
    return NextResponse.json({ error: 'Missing Webhook ID' }, { status: 400 })
  }

  if (!shopDomain) {
    console.warn('Shopify webhook missing shop domain')
    return NextResponse.json({ error: 'Missing Shop Domain' }, { status: 400 })
  }

  // Step 3: Find integration by shop domain
  const supabase = createAdminClient()

  const { data: integrations } = await supabase
    .from('integrations')
    .select('*')
    .eq('type', 'shopify')
    .eq('is_active', true)

  // Find integration matching this shop domain
  const integration = (integrations || []).find((int) => {
    const config = int.config as { shop_domain?: string }
    return config.shop_domain?.toLowerCase() === shopDomain.toLowerCase()
  }) as ShopifyIntegration | undefined

  if (!integration) {
    console.warn(`No active Shopify integration for shop: ${shopDomain}`)
    // Return 200 to prevent Shopify from retrying for unknown shops
    return NextResponse.json({ received: true, ignored: 'unknown_shop' }, { status: 200 })
  }

  // Step 4: Verify HMAC
  const apiSecret = integration.config.api_secret
  const isValid = verifyShopifyHmac(rawBody, hmacHeader, apiSecret)

  if (!isValid) {
    console.warn(`Invalid HMAC for shop: ${shopDomain}`)
    return NextResponse.json({ error: 'Invalid HMAC' }, { status: 401 })
  }

  // Step 5: Parse payload (safe now after HMAC verification)
  let payload: ShopifyOrderWebhook
  try {
    payload = JSON.parse(rawBody)
  } catch {
    console.error('Failed to parse Shopify webhook payload')
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 })
  }

  // Step 6: Only process orders/create topic
  if (topic !== 'orders/create') {
    console.log(`Ignoring Shopify webhook topic: ${topic}`)
    return NextResponse.json({ received: true, ignored: topic }, { status: 200 })
  }

  // Step 7: Process webhook SYNCHRONOUSLY
  // Shopify requires 200 response within 5 seconds, but processing should be fast
  try {
    const result = await processShopifyWebhook(payload, integration, webhookId)

    const duration = Date.now() - startTime
    console.log(`Shopify webhook processed in ${duration}ms: ${result.success ? 'success' : 'failed'}`)

    if (result.success) {
      return NextResponse.json({
        received: true,
        orderId: result.orderId,
        contactId: result.contactId,
        contactCreated: result.contactCreated,
        needsVerification: result.needsVerification,
      }, { status: 200 })
    } else {
      // Log error but return 200 to prevent immediate retry
      // Failed webhooks are logged and can be retried manually
      console.error('Shopify webhook processing failed:', result.error)
      return NextResponse.json({
        received: true,
        error: result.error,
      }, { status: 200 })
    }
  } catch (error) {
    console.error('Shopify webhook processing error:', error)
    // Still return 200 to prevent Shopify from hammering us with retries
    // The error is logged in webhook_events table
    return NextResponse.json({
      received: true,
      error: 'Processing failed',
    }, { status: 200 })
  }
}

// ============================================================================
// HEALTH CHECK (GET)
// Can be used to verify endpoint is reachable
// ============================================================================

export async function GET() {
  return NextResponse.json({
    status: 'ok',
    endpoint: 'shopify-webhook',
    timestamp: new Date().toISOString(),
  })
}
```

Key security measures:
1. **Raw body first**: Uses request.text() BEFORE any JSON parsing
2. **HMAC verification**: Validates signature before trusting payload
3. **Integration lookup**: Finds matching integration by shop domain
4. **Topic filtering**: Only processes orders/create
5. **Always 200**: Returns 200 even on error to prevent Shopify retries (errors are logged)

CRITICAL notes:
- DO NOT add middleware that parses request body before this route
- DO NOT use request.json() before HMAC verification
- Keep processing under 5 seconds (Shopify timeout)
  </action>
  <verify>Verify route compiles. Test with curl if possible: `curl -X GET /api/webhooks/shopify`.</verify>
  <done>Webhook endpoint verifies HMAC, finds integration by shop domain, and delegates to webhook handler.</done>
</task>

<task type="auto">
  <name>Task 2: Disable body parsing middleware for webhook route</name>
  <files>next.config.ts</files>
  <action>
Check if Next.js needs body parsing disabled for this route. In App Router, `request.text()` should work without additional config, but verify.

If needed, ensure no middleware intercepts the body before the route handler.

Check existing middleware.ts to ensure it doesn't parse body for /api/webhooks/* routes.

**If middleware.ts parses body globally:**
Add exclusion for webhook routes:
```typescript
// In middleware.ts matcher config
export const config = {
  matcher: [
    // ... existing matchers
    '/((?!api/webhooks/.*|_next/static|_next/image|favicon.ico).*)',
  ],
}
```

**If no changes needed:**
Document that App Router route handlers receive raw request by default.

This task may be a no-op if the existing setup already supports raw body access.
  </action>
  <verify>Test that webhook endpoint can read raw body. If curl available: send POST request and verify it doesn't error on body parsing.</verify>
  <done>Webhook route can read raw request body for HMAC verification. No middleware interference.</done>
</task>

</tasks>

<verification>
1. Webhook endpoint exists at /api/webhooks/shopify
2. HMAC verification happens before payload parsing
3. Integration lookup finds correct workspace by shop domain
4. Always returns 200 (errors logged, not exposed via HTTP status)
5. GET endpoint works for health check
</verification>

<success_criteria>
- Webhook endpoint receives Shopify orders/create events
- HMAC verification prevents unauthorized requests
- Payload is parsed only after successful verification
- Processing completes within 5 seconds
</success_criteria>

<output>
After completion, create `.planning/phases/11-shopify-integration/11-05-SUMMARY.md`
</output>
