---
phase: 18-domain-layer-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/domain/orders.ts
autonomous: true

must_haves:
  truths:
    - "createOrder domain function creates order + products + emits order.created trigger"
    - "updateOrder domain function updates fields + emits field.changed trigger"
    - "moveOrderToStage domain function moves stage + emits order.stage_changed trigger"
    - "deleteOrder domain function deletes order (no trigger currently defined for delete)"
    - "duplicateOrder domain function copies order to target pipeline + emits order.created trigger"
    - "addOrderTag/removeOrderTag domain functions manage tags + emit tag.assigned/tag.removed triggers"
  artifacts:
    - path: "src/lib/domain/orders.ts"
      provides: "7 order domain functions: createOrder, updateOrder, moveOrderToStage, deleteOrder, duplicateOrder, addOrderTag, removeOrderTag"
      exports: ["createOrder", "updateOrder", "moveOrderToStage", "deleteOrder", "duplicateOrder", "addOrderTag", "removeOrderTag"]
  key_links:
    - from: "src/lib/domain/orders.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "import emitOrderCreated, emitOrderStageChanged, emitFieldChanged, emitTagAssigned, emitTagRemoved"
      pattern: "import.*trigger-emitter"
    - from: "src/lib/domain/orders.ts"
      to: "src/lib/supabase/admin.ts"
      via: "import createAdminClient"
      pattern: "createAdminClient"
---

<objective>
Create all 7 order domain functions in `src/lib/domain/orders.ts`. Each function uses createAdminClient, filters by workspace_id, executes the mutation, and emits the corresponding trigger.

Purpose: Orders have the highest duplication (5 code paths). This is the first entity to migrate — it establishes the domain function pattern that all other entities will follow.

Output: `src/lib/domain/orders.ts` with 7 exported functions.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-domain-layer-foundation/18-CONTEXT.md
@.planning/phases/18-domain-layer-foundation/18-RESEARCH.md

Key reference files (READ THESE for existing logic):
@src/app/actions/orders.ts (server action implementations — primary source for createOrder, updateOrder, moveOrderToStage, deleteOrder, duplicateOrder logic)
@src/lib/tools/handlers/crm/index.ts (crm.order.create, crm.order.updateStatus handler logic)
@src/lib/automations/action-executor.ts (create_order, duplicate_order, change_stage action logic)
@src/lib/shopify/webhook-handler.ts (createOrderWithProducts logic)
@src/lib/agents/engine-adapters/production/orders.ts (OrderCreator create logic)
@src/lib/automations/trigger-emitter.ts (trigger emission signatures)
@src/lib/domain/types.ts (DomainContext, DomainResult)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create orders domain — create, update, move, delete</name>
  <files>src/lib/domain/orders.ts</files>
  <action>
Create `src/lib/domain/orders.ts` with the first 4 functions. Follow this pattern for EVERY function:
1. Import `createAdminClient` from `@/lib/supabase/admin`
2. Import relevant emit functions from `@/lib/automations/trigger-emitter`
3. Import `DomainContext`, `DomainResult` from `./types`
4. Each function receives `(ctx: DomainContext, params: {...})` and returns `Promise<DomainResult<T>>`
5. Each function calls `createAdminClient()`, filters by `workspace_id`, executes mutation, emits trigger

**createOrder(ctx, params):**
- Params: contactId, pipelineId, stageId?, closingDate?, description?, carrier?, trackingNumber?, shippingAddress?, shippingCity?, customFields?, products?: Array<{productId?, sku, title, unitPrice, quantity}>
- Logic: If no stageId, resolve first stage of pipeline (query pipeline_stages ordered by position ASC). Insert into orders table. If products, insert into order_products + recalculate total_value (sum of unitPrice * quantity) and update orders.total_value.
- Emit: `emitOrderCreated({ workspaceId, orderId, pipelineId, stageId, contactId, totalValue, cascadeDepth })`
- Return: `{ orderId: string, stageId: string }`
- IMPORTANT: Study `src/app/actions/orders.ts` createOrder for exact column names and product insert logic.

**updateOrder(ctx, params):**
- Params: orderId, contactId?, closingDate?, description?, carrier?, trackingNumber?, shippingAddress?, shippingCity?, customFields?, products?: same array (full replace)
- Logic: Read current order (to detect changes). Update order row. If products provided, delete existing order_products, insert new ones, recalculate total_value. For each changed field, emit `emitFieldChanged` with previousValue/newValue. If stage_id changes (via moveOrderToStage instead), that's a separate function.
- Emit: `emitFieldChanged` per changed field (compare old vs new values for shipping_address, shipping_city, description, carrier, tracking_number, contact_id, custom_fields changes)
- Return: `{ orderId: string }`
- IMPORTANT: Check if stage_id changed — if so, also emit `emitOrderStageChanged` (study existing server action behavior).

**moveOrderToStage(ctx, params):**
- Params: orderId, newStageId
- Logic: Read current order (to get previous stage_id, pipeline_id, contact_id). Update orders.stage_id. Also fetch stage names for trigger context.
- Emit: `emitOrderStageChanged({ workspaceId, orderId, previousStageId, newStageId, pipelineId, contactId, previousStageName, newStageName, pipelineName, contactName, contactPhone, cascadeDepth })`
- Return: `{ orderId: string, previousStageId: string, newStageId: string }`
- IMPORTANT: Study existing server action moveOrderToStage for the exact query that fetches stage/pipeline names.

**deleteOrder(ctx, params):**
- Params: orderId
- Logic: Verify order exists and belongs to workspace_id. Delete from orders (order_products cascade from FK). No trigger defined for order delete currently (Phase 17 didn't add one).
- Return: `{ orderId: string }`
  </action>
  <verify>File compiles: `npx tsc --noEmit src/lib/domain/orders.ts`. All 4 functions exported.</verify>
  <done>createOrder, updateOrder, moveOrderToStage, deleteOrder domain functions complete with trigger emission.</done>
</task>

<task type="auto">
  <name>Task 2: Complete orders domain — duplicate, tags</name>
  <files>src/lib/domain/orders.ts</files>
  <action>
Add 3 more functions to `src/lib/domain/orders.ts`:

**duplicateOrder(ctx, params):**
- Params: sourceOrderId, targetPipelineId, targetStageId?
- Logic: Read source order + its order_products + contact_id. If no targetStageId, resolve first stage of target pipeline. Create new order with same contact, description, products, etc. Set `source_order_id = sourceOrderId` on the new order. Copy products.
- Emit: `emitOrderCreated({ workspaceId, orderId: newOrderId, pipelineId: targetPipelineId, stageId, contactId, totalValue, sourceOrderId, cascadeDepth })`
- Return: `{ orderId: string, sourceOrderId: string }`
- IMPORTANT: Study `src/app/actions/orders.ts` duplicateOrder and action-executor duplicate_order for the exact duplication logic. Note the `source_order_id` column.

**addOrderTag(ctx, params):**
- Params: orderId, tagName
- Logic: Find tag by name + workspace_id (tags table). Find or create the tag if needed? No — lookup only, error if not found. Insert into order_tags (order_id, tag_id). Also fetch contact_id from the order for trigger context.
- Emit: `emitTagAssigned({ workspaceId, entityType: 'order', entityId: orderId, tagId, tagName, contactId, cascadeDepth })`
- Return: `{ orderId: string, tagId: string }`
- Handle duplicate insert gracefully (tag already assigned = success, not error). Use `.select().maybeSingle()` or handle 23505 conflict.

**removeOrderTag(ctx, params):**
- Params: orderId, tagName
- Logic: Find tag by name + workspace_id. Delete from order_tags where order_id + tag_id. Fetch contact_id for trigger context.
- Emit: `emitTagRemoved({ workspaceId, entityType: 'order', entityId: orderId, tagId, tagName, contactId, cascadeDepth })`
- Return: `{ orderId: string, tagId: string }`

After all 7 functions, update `src/lib/domain/index.ts` to uncomment/add `export * from './orders'`.
  </action>
  <verify>File compiles: `npx tsc --noEmit`. All 7 order functions exported. `src/lib/domain/index.ts` re-exports orders.</verify>
  <done>All 7 order domain functions complete. Domain barrel export includes orders.</done>
</task>

</tasks>

<verification>
1. `src/lib/domain/orders.ts` exports 7 functions: createOrder, updateOrder, moveOrderToStage, deleteOrder, duplicateOrder, addOrderTag, removeOrderTag
2. Every function uses `createAdminClient()` (never `createClient()`)
3. Every function filters by `ctx.workspaceId`
4. Every mutating function (except deleteOrder) emits its corresponding trigger
5. `src/lib/domain/index.ts` re-exports `./orders`
6. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- 7 order domain functions compile and follow the DomainContext/DomainResult contract
- Trigger emissions match the signatures in trigger-emitter.ts
- Business logic matches existing server actions (not simplified or lossy)
- createAdminClient used exclusively, workspace_id filtered on every query
</success_criteria>

<output>
After completion, create `.planning/phases/18-domain-layer-foundation/18-02-SUMMARY.md`
</output>
