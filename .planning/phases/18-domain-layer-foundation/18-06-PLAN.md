---
phase: 18-domain-layer-foundation
plan: 06
type: execute
wave: 3
depends_on: ["18-01"]
files_modified:
  - src/lib/domain/messages.ts
  - src/lib/domain/index.ts
  - src/app/actions/messages.ts
  - src/lib/tools/handlers/whatsapp/index.ts
  - src/lib/automations/action-executor.ts
  - src/lib/whatsapp/webhook-handler.ts
  - src/lib/agents/engine-adapters/production/messaging.ts
autonomous: true

must_haves:
  truths:
    - "sendTextMessage domain function sends message via 360dialog API + stores in DB"
    - "sendMediaMessage domain function sends media via 360dialog API + stores in DB"
    - "sendTemplateMessage domain function sends template via 360dialog API + stores in DB"
    - "receiveMessage domain function stores incoming message + emits whatsapp.message_received trigger"
    - "receiveMessage also checks for keyword matches and emits whatsapp.keyword_match trigger"
    - "All 4 message callers (server actions, tool handlers, action executor, engine adapter) use domain"
    - "whatsapp.keyword_match trigger is no longer dead — fires on matching incoming messages"
  artifacts:
    - path: "src/lib/domain/messages.ts"
      provides: "4 message domain functions"
      exports: ["sendTextMessage", "sendMediaMessage", "sendTemplateMessage", "receiveMessage"]
  key_links:
    - from: "src/lib/domain/messages.ts"
      to: "src/lib/whatsapp/api.ts"
      via: "import WhatsApp API functions for sending"
      pattern: "whatsapp/api"
    - from: "src/lib/domain/messages.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "import emitWhatsAppMessageReceived, emitWhatsAppKeywordMatch"
      pattern: "trigger-emitter"
---

<objective>
Create message domain functions, activate the dead keyword_match trigger, and wire all message callers to domain. This is a large plan covering both domain creation and caller wiring for the messages entity.

Purpose: Messages/WhatsApp have 5 code paths (server actions, tool handlers, action executor, engine adapter, webhook). None currently emit triggers for outbound messages. The webhook handler partially emits message_received but misses keyword_match. After this plan, every message operation goes through domain/ and keyword_match becomes active.

Output: `src/lib/domain/messages.ts` + 5 refactored caller files.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/18-domain-layer-foundation/18-RESEARCH.md

Key reference files (READ THESE):
@src/app/actions/messages.ts (server actions: sendMessage, sendMediaMessage, sendTemplateMessage)
@src/lib/tools/handlers/whatsapp/index.ts (whatsapp.message.send, whatsapp.template.send)
@src/lib/automations/action-executor.ts (send_whatsapp_text, send_whatsapp_template, send_whatsapp_media)
@src/lib/whatsapp/webhook-handler.ts (processIncomingMessage — message receive + store)
@src/lib/agents/engine-adapters/production/messaging.ts (ProductionMessagingAdapter — direct 360dialog)
@src/lib/whatsapp/api.ts (360dialog API functions — sendTextMessage, sendMediaMessage, etc.)
@src/lib/automations/trigger-emitter.ts (emitWhatsAppMessageReceived, emitWhatsAppKeywordMatch)
@src/lib/domain/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create messages domain functions + keyword match</name>
  <files>src/lib/domain/messages.ts, src/lib/domain/index.ts</files>
  <action>
Create `src/lib/domain/messages.ts` with 4 functions:

**sendTextMessage(ctx, params):**
- Params: conversationId, contactPhone, messageBody, whatsappAccountId (the 360dialog account/phone number ID for the workspace)
- Logic:
  1. Call WhatsApp API: `sendTextMessage` from `@/lib/whatsapp/api.ts` (the existing 360dialog wrapper). Need to pass the workspace's API key/config.
  2. Store message in messages table: type='text', direction='outbound', content=messageBody, conversation_id=conversationId, workspace_id=ctx.workspaceId
  3. Update conversation last_message_at timestamp
- No trigger for outbound messages currently (no send trigger defined in Phase 17). Just send + store.
- Return: `{ messageId: string, waMessageId?: string }` (waMessageId is the 360dialog message ID)
- IMPORTANT: Study `src/app/actions/messages.ts` sendMessage and `src/lib/whatsapp/api.ts` for exact API call signature and message storage columns.
- NOTE: The WhatsApp API needs the workspace's 360dialog credentials. Study how existing callers get the API key — likely from workspace config or whatsapp_config table.

**sendMediaMessage(ctx, params):**
- Params: conversationId, contactPhone, mediaUrl, caption?, mediaType ('image'|'video'|'document'|'audio'), whatsappAccountId
- Logic: Similar to sendTextMessage but using media API endpoint. Store with type=mediaType.
- Return: `{ messageId: string, waMessageId?: string }`

**sendTemplateMessage(ctx, params):**
- Params: conversationId, contactPhone, templateName, templateLanguage, variables?: Record<string, string>, whatsappAccountId
- Logic: Call template send API. Store with type='template', content=template name + variables.
- Return: `{ messageId: string, waMessageId?: string }`

**receiveMessage(ctx, params):**
- Params: conversationId, contactId, phone, messageContent, messageType ('text'|'image'|'video'|...), waMessageId, mediaUrl?, timestamp
- Logic:
  1. Store incoming message in messages table: direction='inbound', etc.
  2. Update conversation last_message_at
  3. Emit `emitWhatsAppMessageReceived({ workspaceId, conversationId, contactId, messageContent, phone, contactName, cascadeDepth })`
  4. **KEYWORD MATCH (activating dead trigger):**
     - Query active automations with `trigger_type = 'whatsapp.keyword_match'` for this workspace from automations table
     - For each matching automation, extract keywords from `trigger_config` (the automation's trigger configuration has a keywords field or similar)
     - Check if messageContent contains any of the configured keywords (case-insensitive)
     - For each match, emit `emitWhatsAppKeywordMatch({ workspaceId, conversationId, contactId, messageContent, phone, keywordMatched, cascadeDepth })`
  5. Return message data
- Return: `{ messageId: string }`
- IMPORTANT: Study `src/lib/whatsapp/webhook-handler.ts` processIncomingMessage for exact columns and existing message_received emission. The keyword match implementation is NEW — study `src/lib/automations/types.ts` and `src/lib/automations/constants.ts` for the trigger_config structure of keyword_match automations.
- NOTE on keywords: The TRIGGER_CATALOG in constants.ts defines whatsapp.keyword_match with config containing keyword matching. Study the exact config shape to know how keywords are stored in automations table.

Update `src/lib/domain/index.ts` to add `export * from './messages'`.
  </action>
  <verify>File compiles. 4 functions exported. receiveMessage has keyword match logic. Barrel export updated.</verify>
  <done>4 message domain functions created. Keyword match trigger activated in receiveMessage.</done>
</task>

<task type="auto">
  <name>Task 2: Wire all message callers to domain</name>
  <files>src/app/actions/messages.ts, src/lib/tools/handlers/whatsapp/index.ts, src/lib/automations/action-executor.ts, src/lib/whatsapp/webhook-handler.ts, src/lib/agents/engine-adapters/production/messaging.ts</files>
  <action>
**Refactor `src/app/actions/messages.ts`:**
1. Import domain message functions
2. `sendMessage`: Call `domainSendTextMessage(ctx, params)`. Keep auth + revalidatePath.
3. `sendMediaMessage`: Call `domainSendMediaMessage(ctx, params)`. Keep auth + revalidatePath.
4. `sendTemplateMessage`: Call `domainSendTemplateMessage(ctx, params)`. Keep auth + revalidatePath.
5. Remove any direct DB message inserts.

**Refactor `src/lib/tools/handlers/whatsapp/index.ts`:**
1. `whatsapp.message.send`: Call `domainSendTextMessage(ctx, params)`. Remove direct DB + API logic.
2. `whatsapp.template.send`: Call `domainSendTemplateMessage(ctx, params)`. Remove direct DB + API logic.
3. Keep read-only handlers (whatsapp.conversation.list, etc.) as-is for now (conversations migrated in Plan 09).
4. Build DomainContext: `{ workspaceId: context.workspaceId, source: 'tool-handler' }`

**Refactor `src/lib/automations/action-executor.ts`:**
1. `send_whatsapp_text`: Call domain.sendTextMessage instead of executeToolFromWebhook.
2. `send_whatsapp_template`: Call domain.sendTemplateMessage instead of executeToolFromWebhook.
3. `send_whatsapp_media`: Call domain.sendMediaMessage instead of direct sendMediaMessage from whatsapp/api. This action currently calls the API directly — now it goes through domain.
4. Build DomainContext: `{ workspaceId, source: 'automation', cascadeDepth }`

**Refactor `src/lib/whatsapp/webhook-handler.ts`:**
1. In `processIncomingMessage`: Replace direct message INSERT + trigger emission with `domainReceiveMessage(ctx, params)`.
2. Build DomainContext: `{ workspaceId, source: 'webhook' }`
3. REMOVE the inline `emitWhatsAppMessageReceived` call — domain handles it now.
4. Keep conversation creation/update logic for now (conversations migrated in Plan 09). Only the message storage + trigger emission moves to domain.
5. The keyword match check is now INSIDE domain.receiveMessage — no need for separate wiring.

**Refactor `src/lib/agents/engine-adapters/production/messaging.ts`:**
1. Import domain message functions
2. Build DomainContext: `{ workspaceId, source: 'adapter' }`
3. Replace direct 360dialog API calls with domain function calls
4. The adapter still handles message sequencing (delays between messages) — that's adapter-specific. But the actual send goes through domain.
  </action>
  <verify>TypeScript compiles. All 5 callers import from domain/messages. Webhook handler no longer has inline emitWhatsAppMessageReceived call. Action executor no longer imports sendMediaMessage from whatsapp/api directly for this action.</verify>
  <done>All message callers wired to domain. keyword_match trigger active. Messages entity 100% complete.</done>
</task>

</tasks>

<verification>
1. `src/lib/domain/messages.ts` exports 4 functions
2. `receiveMessage` has keyword match implementation (queries automations, checks keywords, emits per match)
3. All 5 callers (server actions, tool handlers, action executor, webhook handler, engine adapter) use domain
4. No duplicate message storage or trigger emission
5. `emitWhatsAppKeywordMatch` is called from domain.receiveMessage (no longer dead)
6. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- Every message operation goes through domain/messages.ts
- Incoming messages trigger both message_received AND keyword_match (when keywords configured)
- Bot message sends go through domain (enabling future send triggers if needed)
- 3 separate WhatsApp messaging code paths unified into 1
</success_criteria>

<output>
After completion, create `.planning/phases/18-domain-layer-foundation/18-06-SUMMARY.md`
</output>
