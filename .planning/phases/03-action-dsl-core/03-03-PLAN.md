---
phase: 03-action-dsl-core
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/tools/schemas/crm.tools.ts
  - src/lib/tools/schemas/whatsapp.tools.ts
  - src/lib/tools/handlers/crm/index.ts
  - src/lib/tools/handlers/whatsapp/index.ts
  - src/lib/tools/init.ts
  - src/instrumentation.ts
autonomous: true

must_haves:
  truths:
    - "CRM tool schemas are defined and registered"
    - "WhatsApp tool schemas are defined and registered"
    - "All tools have placeholder handlers that work in dry-run mode"
    - "Tool initialization loads all schemas on app startup"
  artifacts:
    - path: "src/lib/tools/schemas/crm.tools.ts"
      provides: "CRM tool schema definitions"
      exports: ["crmToolSchemas"]
    - path: "src/lib/tools/schemas/whatsapp.tools.ts"
      provides: "WhatsApp tool schema definitions"
      exports: ["whatsappToolSchemas"]
    - path: "src/lib/tools/init.ts"
      provides: "Tool initialization function"
      exports: ["initializeTools"]
    - path: "src/instrumentation.ts"
      provides: "Next.js instrumentation hook"
      exports: ["register"]
  key_links:
    - from: "src/lib/tools/init.ts"
      to: "src/lib/tools/registry.ts"
      via: "toolRegistry.register"
      pattern: "toolRegistry\\.register"
    - from: "src/instrumentation.ts"
      to: "src/lib/tools/init.ts"
      via: "initializeTools call"
      pattern: "initializeTools\\(\\)"
    - from: "src/lib/tools/handlers/crm/index.ts"
      to: "Phase 4 implementation"
      via: "handler replacement"
      pattern: "PHASE_4_CONTRACT: Replace placeholder handlers with real implementations. Do NOT create new handler files - modify this file directly."
    - from: "src/lib/tools/handlers/whatsapp/index.ts"
      to: "Phase 7 implementation"
      via: "handler replacement"
      pattern: "PHASE_7_CONTRACT: Replace placeholder handlers with real implementations. Do NOT create new handler files - modify this file directly."
---

<objective>
Define CRM and WhatsApp tool schemas with placeholder handlers, and create initialization to register them on app startup.

Purpose: Phase 3 creates the FRAMEWORK for tools, not the implementations. CRM tools are implemented in Phase 4, WhatsApp tools in Phase 7. This plan defines the schemas so the registry can list them and validate inputs, while handlers return dry-run-style previews.

Output: Complete tool schema definitions for CRM and WhatsApp operations, registered and discoverable.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-action-dsl-core/03-CONTEXT.md
@.planning/phases/03-action-dsl-core/03-RESEARCH.md
@.planning/phases/03-action-dsl-core/03-01-SUMMARY.md
@src/lib/tools/types.ts
@src/lib/tools/registry.ts
@src/lib/permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define CRM Tool Schemas</name>
  <files>src/lib/tools/schemas/crm.tools.ts</files>
  <action>
Create CRM tool schemas following MCP-compatible JSON Schema format:

```typescript
// src/lib/tools/schemas/crm.tools.ts
import type { ToolSchema } from '../types'

/**
 * CRM Tool Schemas
 *
 * These define the contract for CRM operations. Handlers are placeholders
 * until Phase 4 implementation.
 *
 * Naming convention: crm.{entity}.{action}
 * Entities: contact, order, tag
 * Actions: create, read, update, delete, list, search
 */

// ==================== CONTACT TOOLS ====================

export const crmContactCreate: ToolSchema = {
  name: 'crm.contact.create',
  description: 'Create a new contact in the workspace CRM. Requires name and phone at minimum.',

  inputSchema: {
    type: 'object',
    properties: {
      name: {
        type: 'string',
        minLength: 1,
        maxLength: 200,
        description: 'Full name of the contact'
      },
      phone: {
        type: 'string',
        pattern: '^\\+[1-9]\\d{1,14}$',
        description: 'Phone number with country code (E.164 format: +573001234567)'
      },
      email: {
        type: 'string',
        format: 'email',
        description: 'Email address (optional)'
      },
      address: {
        type: 'string',
        maxLength: 500,
        description: 'Physical address (optional)'
      },
      city: {
        type: 'string',
        maxLength: 100,
        description: 'City name (optional)'
      },
      tags: {
        type: 'array',
        items: { type: 'string' },
        description: 'Initial tags to apply (optional)'
      },
      notes: {
        type: 'string',
        maxLength: 2000,
        description: 'Initial notes (optional)'
      }
    },
    required: ['name', 'phone'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      contactId: { type: 'string' },
      created: { type: 'boolean' }
    },
    required: ['contactId', 'created']
  },

  metadata: {
    module: 'crm',
    entity: 'contact',
    action: 'create',
    reversible: false,
    requiresApproval: false,
    sideEffects: ['creates_record'],
    permissions: ['contacts.create']
  }
}

export const crmContactUpdate: ToolSchema = {
  name: 'crm.contact.update',
  description: 'Update an existing contact. Only provided fields are updated.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact to update'
      },
      name: {
        type: 'string',
        minLength: 1,
        maxLength: 200,
        description: 'New name (optional)'
      },
      phone: {
        type: 'string',
        pattern: '^\\+[1-9]\\d{1,14}$',
        description: 'New phone number (optional)'
      },
      email: {
        type: ['string', 'null'],
        format: 'email',
        description: 'New email (optional, null to clear)'
      },
      address: {
        type: ['string', 'null'],
        maxLength: 500,
        description: 'New address (optional, null to clear)'
      },
      city: {
        type: ['string', 'null'],
        maxLength: 100,
        description: 'New city (optional, null to clear)'
      }
    },
    required: ['contactId'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      contactId: { type: 'string' },
      updated: { type: 'boolean' },
      changedFields: { type: 'array', items: { type: 'string' } }
    },
    required: ['contactId', 'updated']
  },

  metadata: {
    module: 'crm',
    entity: 'contact',
    action: 'update',
    reversible: true,
    requiresApproval: false,
    sideEffects: ['updates_record'],
    permissions: ['contacts.edit']
  }
}

export const crmContactDelete: ToolSchema = {
  name: 'crm.contact.delete',
  description: 'Delete a contact from the workspace. This is a soft delete.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact to delete'
      }
    },
    required: ['contactId'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      contactId: { type: 'string' },
      deleted: { type: 'boolean' }
    },
    required: ['contactId', 'deleted']
  },

  metadata: {
    module: 'crm',
    entity: 'contact',
    action: 'delete',
    reversible: true,
    requiresApproval: false,
    sideEffects: ['deletes_record'],
    permissions: ['contacts.delete']
  }
}

export const crmContactRead: ToolSchema = {
  name: 'crm.contact.read',
  description: 'Get a contact by ID with full details.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact to retrieve'
      }
    },
    required: ['contactId'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      contact: { type: 'object' }
    },
    required: ['contact']
  },

  metadata: {
    module: 'crm',
    entity: 'contact',
    action: 'read',
    reversible: false,
    requiresApproval: false,
    sideEffects: [],
    permissions: ['contacts.view']
  }
}

export const crmContactList: ToolSchema = {
  name: 'crm.contact.list',
  description: 'List contacts with optional filtering and pagination.',

  inputSchema: {
    type: 'object',
    properties: {
      page: {
        type: 'integer',
        minimum: 1,
        default: 1,
        description: 'Page number (default: 1)'
      },
      pageSize: {
        type: 'integer',
        minimum: 1,
        maximum: 100,
        default: 20,
        description: 'Items per page (default: 20, max: 100)'
      },
      search: {
        type: 'string',
        description: 'Search in name, phone, email'
      },
      tags: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter by tags (AND logic)'
      },
      sortBy: {
        type: 'string',
        enum: ['name', 'created_at', 'updated_at'],
        default: 'created_at',
        description: 'Sort field'
      },
      sortOrder: {
        type: 'string',
        enum: ['asc', 'desc'],
        default: 'desc',
        description: 'Sort order'
      }
    },
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      contacts: { type: 'array', items: { type: 'object' } },
      total: { type: 'integer' },
      page: { type: 'integer' },
      pageSize: { type: 'integer' },
      totalPages: { type: 'integer' }
    },
    required: ['contacts', 'total', 'page', 'pageSize', 'totalPages']
  },

  metadata: {
    module: 'crm',
    entity: 'contact',
    action: 'list',
    reversible: false,
    requiresApproval: false,
    sideEffects: [],
    permissions: ['contacts.view']
  }
}

// ==================== TAG TOOLS ====================

export const crmTagAdd: ToolSchema = {
  name: 'crm.tag.add',
  description: 'Add a tag to a contact. Creates the tag if it does not exist.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact'
      },
      tag: {
        type: 'string',
        minLength: 1,
        maxLength: 50,
        pattern: '^[a-zA-Z0-9_-]+$',
        description: 'Tag name (alphanumeric, dashes, underscores)'
      }
    },
    required: ['contactId', 'tag'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      contactId: { type: 'string' },
      tag: { type: 'string' },
      added: { type: 'boolean' },
      alreadyHadTag: { type: 'boolean' }
    },
    required: ['contactId', 'tag', 'added']
  },

  metadata: {
    module: 'crm',
    entity: 'tag',
    action: 'add',
    reversible: true,
    requiresApproval: false,
    sideEffects: ['updates_record'],
    permissions: ['contacts.edit']
  }
}

export const crmTagRemove: ToolSchema = {
  name: 'crm.tag.remove',
  description: 'Remove a tag from a contact.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact'
      },
      tag: {
        type: 'string',
        description: 'Tag name to remove'
      }
    },
    required: ['contactId', 'tag'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      contactId: { type: 'string' },
      tag: { type: 'string' },
      removed: { type: 'boolean' },
      hadTag: { type: 'boolean' }
    },
    required: ['contactId', 'tag', 'removed']
  },

  metadata: {
    module: 'crm',
    entity: 'tag',
    action: 'remove',
    reversible: true,
    requiresApproval: false,
    sideEffects: ['updates_record'],
    permissions: ['contacts.edit']
  }
}

// ==================== ORDER TOOLS ====================

export const crmOrderCreate: ToolSchema = {
  name: 'crm.order.create',
  description: 'Create a new order linked to a contact.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact placing the order'
      },
      products: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            quantity: { type: 'integer', minimum: 1 },
            price: { type: 'number', minimum: 0 }
          },
          required: ['name', 'quantity', 'price']
        },
        minItems: 1,
        description: 'List of products in the order'
      },
      shippingAddress: {
        type: 'string',
        description: 'Shipping address'
      },
      notes: {
        type: 'string',
        maxLength: 2000,
        description: 'Order notes (optional)'
      }
    },
    required: ['contactId', 'products'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      orderId: { type: 'string' },
      created: { type: 'boolean' },
      total: { type: 'number' }
    },
    required: ['orderId', 'created', 'total']
  },

  metadata: {
    module: 'crm',
    entity: 'order',
    action: 'create',
    reversible: false,
    requiresApproval: false,
    sideEffects: ['creates_record'],
    permissions: ['orders.create']
  }
}

export const crmOrderUpdateStatus: ToolSchema = {
  name: 'crm.order.updateStatus',
  description: 'Update the status of an order (move through pipeline stages).',

  inputSchema: {
    type: 'object',
    properties: {
      orderId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the order'
      },
      status: {
        type: 'string',
        description: 'New status (pipeline stage)'
      }
    },
    required: ['orderId', 'status'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      orderId: { type: 'string' },
      previousStatus: { type: 'string' },
      newStatus: { type: 'string' },
      updated: { type: 'boolean' }
    },
    required: ['orderId', 'newStatus', 'updated']
  },

  metadata: {
    module: 'crm',
    entity: 'order',
    action: 'updateStatus',
    reversible: true,
    requiresApproval: false,
    sideEffects: ['updates_record', 'triggers_sync'],
    permissions: ['orders.edit']
  }
}

// Export all CRM tool schemas
export const crmToolSchemas: ToolSchema[] = [
  crmContactCreate,
  crmContactUpdate,
  crmContactDelete,
  crmContactRead,
  crmContactList,
  crmTagAdd,
  crmTagRemove,
  crmOrderCreate,
  crmOrderUpdateStatus
]
```

Total: 9 CRM tools covering contacts, tags, and orders.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/tools/schemas/crm.tools.ts`
Count schemas: `crmToolSchemas.length === 9`
  </verify>
  <done>9 CRM tool schemas defined with proper JSON Schema validation rules.</done>
</task>

<task type="auto">
  <name>Task 2: Define WhatsApp Tool Schemas</name>
  <files>src/lib/tools/schemas/whatsapp.tools.ts</files>
  <action>
Create WhatsApp tool schemas:

```typescript
// src/lib/tools/schemas/whatsapp.tools.ts
import type { ToolSchema } from '../types'

/**
 * WhatsApp Tool Schemas
 *
 * These define the contract for WhatsApp operations. Handlers are placeholders
 * until Phase 7 implementation.
 *
 * Naming convention: whatsapp.{entity}.{action}
 * Entities: message, template, conversation
 * Actions: send, list, read, assign
 */

// ==================== MESSAGE TOOLS ====================

export const whatsappMessageSend: ToolSchema = {
  name: 'whatsapp.message.send',
  description: 'Send a WhatsApp message to a contact (within 24h window). Use whatsapp.template.send for outside the window.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact to message (must have phone)'
      },
      message: {
        type: 'string',
        minLength: 1,
        maxLength: 4096,
        description: 'Message text to send'
      },
      replyToMessageId: {
        type: 'string',
        description: 'ID of message to reply to (optional)'
      }
    },
    required: ['contactId', 'message'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      messageId: { type: 'string' },
      sent: { type: 'boolean' },
      timestamp: { type: 'string' }
    },
    required: ['messageId', 'sent']
  },

  metadata: {
    module: 'whatsapp',
    entity: 'message',
    action: 'send',
    reversible: false,
    requiresApproval: false,
    sideEffects: ['sends_message', 'updates_conversation'],
    permissions: ['whatsapp.send']
  }
}

export const whatsappMessageList: ToolSchema = {
  name: 'whatsapp.message.list',
  description: 'List messages in a conversation with pagination.',

  inputSchema: {
    type: 'object',
    properties: {
      conversationId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the conversation'
      },
      limit: {
        type: 'integer',
        minimum: 1,
        maximum: 100,
        default: 50,
        description: 'Number of messages to return (default: 50)'
      },
      before: {
        type: 'string',
        description: 'Return messages before this message ID'
      },
      after: {
        type: 'string',
        description: 'Return messages after this message ID'
      }
    },
    required: ['conversationId'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      messages: { type: 'array', items: { type: 'object' } },
      hasMore: { type: 'boolean' }
    },
    required: ['messages', 'hasMore']
  },

  metadata: {
    module: 'whatsapp',
    entity: 'message',
    action: 'list',
    reversible: false,
    requiresApproval: false,
    sideEffects: [],
    permissions: ['whatsapp.view']
  }
}

// ==================== TEMPLATE TOOLS ====================

export const whatsappTemplateSend: ToolSchema = {
  name: 'whatsapp.template.send',
  description: 'Send a pre-approved WhatsApp template message. Works outside 24h window.',

  inputSchema: {
    type: 'object',
    properties: {
      contactId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the contact to message'
      },
      templateName: {
        type: 'string',
        description: 'Name of the approved template'
      },
      templateParams: {
        type: 'object',
        description: 'Parameters to fill template placeholders',
        additionalProperties: { type: 'string' }
      },
      language: {
        type: 'string',
        default: 'es',
        description: 'Template language code (default: es)'
      }
    },
    required: ['contactId', 'templateName'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      messageId: { type: 'string' },
      sent: { type: 'boolean' },
      templateUsed: { type: 'string' }
    },
    required: ['messageId', 'sent']
  },

  metadata: {
    module: 'whatsapp',
    entity: 'template',
    action: 'send',
    reversible: false,
    requiresApproval: false,
    sideEffects: ['sends_message', 'updates_conversation'],
    permissions: ['whatsapp.send']
  }
}

export const whatsappTemplateList: ToolSchema = {
  name: 'whatsapp.template.list',
  description: 'List available pre-approved WhatsApp templates for the workspace.',

  inputSchema: {
    type: 'object',
    properties: {
      status: {
        type: 'string',
        enum: ['approved', 'pending', 'rejected'],
        description: 'Filter by template status'
      }
    },
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      templates: { type: 'array', items: { type: 'object' } }
    },
    required: ['templates']
  },

  metadata: {
    module: 'whatsapp',
    entity: 'template',
    action: 'list',
    reversible: false,
    requiresApproval: false,
    sideEffects: [],
    permissions: ['whatsapp.view']
  }
}

// ==================== CONVERSATION TOOLS ====================

export const whatsappConversationList: ToolSchema = {
  name: 'whatsapp.conversation.list',
  description: 'List WhatsApp conversations (inbox) with filtering.',

  inputSchema: {
    type: 'object',
    properties: {
      status: {
        type: 'string',
        enum: ['open', 'closed', 'all'],
        default: 'open',
        description: 'Filter by conversation status'
      },
      assignedTo: {
        type: 'string',
        format: 'uuid',
        description: 'Filter by assigned agent (optional)'
      },
      unassignedOnly: {
        type: 'boolean',
        default: false,
        description: 'Show only unassigned conversations'
      },
      page: {
        type: 'integer',
        minimum: 1,
        default: 1
      },
      pageSize: {
        type: 'integer',
        minimum: 1,
        maximum: 50,
        default: 20
      }
    },
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      conversations: { type: 'array', items: { type: 'object' } },
      total: { type: 'integer' },
      page: { type: 'integer' },
      totalPages: { type: 'integer' }
    },
    required: ['conversations', 'total']
  },

  metadata: {
    module: 'whatsapp',
    entity: 'conversation',
    action: 'list',
    reversible: false,
    requiresApproval: false,
    sideEffects: [],
    permissions: ['whatsapp.view']
  }
}

export const whatsappConversationAssign: ToolSchema = {
  name: 'whatsapp.conversation.assign',
  description: 'Assign a conversation to an agent.',

  inputSchema: {
    type: 'object',
    properties: {
      conversationId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the conversation'
      },
      agentId: {
        type: ['string', 'null'],
        format: 'uuid',
        description: 'ID of the agent to assign (null to unassign)'
      }
    },
    required: ['conversationId', 'agentId'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      conversationId: { type: 'string' },
      previousAgent: { type: ['string', 'null'] },
      newAgent: { type: ['string', 'null'] },
      assigned: { type: 'boolean' }
    },
    required: ['conversationId', 'assigned']
  },

  metadata: {
    module: 'whatsapp',
    entity: 'conversation',
    action: 'assign',
    reversible: true,
    requiresApproval: false,
    sideEffects: ['updates_record'],
    permissions: ['whatsapp.send'] // Managers+ can assign
  }
}

export const whatsappConversationClose: ToolSchema = {
  name: 'whatsapp.conversation.close',
  description: 'Close a conversation (mark as resolved).',

  inputSchema: {
    type: 'object',
    properties: {
      conversationId: {
        type: 'string',
        format: 'uuid',
        description: 'ID of the conversation to close'
      },
      resolution: {
        type: 'string',
        maxLength: 500,
        description: 'Resolution note (optional)'
      }
    },
    required: ['conversationId'],
    additionalProperties: false
  },

  outputSchema: {
    type: 'object',
    properties: {
      conversationId: { type: 'string' },
      closed: { type: 'boolean' },
      closedAt: { type: 'string' }
    },
    required: ['conversationId', 'closed']
  },

  metadata: {
    module: 'whatsapp',
    entity: 'conversation',
    action: 'close',
    reversible: true,
    requiresApproval: false,
    sideEffects: ['updates_record'],
    permissions: ['whatsapp.send']
  }
}

// Export all WhatsApp tool schemas
export const whatsappToolSchemas: ToolSchema[] = [
  whatsappMessageSend,
  whatsappMessageList,
  whatsappTemplateSend,
  whatsappTemplateList,
  whatsappConversationList,
  whatsappConversationAssign,
  whatsappConversationClose
]
```

Total: 7 WhatsApp tools covering messages, templates, and conversations.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/tools/schemas/whatsapp.tools.ts`
Count schemas: `whatsappToolSchemas.length === 7`
  </verify>
  <done>7 WhatsApp tool schemas defined with proper JSON Schema validation rules.</done>
</task>

<task type="auto">
  <name>Task 3: Create Placeholder Handlers and Initialization</name>
  <files>
    src/lib/tools/handlers/crm/index.ts
    src/lib/tools/handlers/whatsapp/index.ts
    src/lib/tools/init.ts
  </files>
  <action>
Create placeholder handlers and the initialization file that registers all tools:

**1. CRM Placeholder Handlers:**
```typescript
// src/lib/tools/handlers/crm/index.ts
import type { ToolHandler, ExecutionContext } from '../../types'

/**
 * CRM Tool Handlers (Placeholders)
 *
 * These are placeholder implementations that return dry-run style outputs.
 * Real implementations come in Phase 4.
 *
 * PHASE_4_CONTRACT: Replace placeholder handlers with real implementations.
 * Do NOT create new handler files - modify this file directly.
 * The registry in init.ts imports from this file.
 *
 * All handlers follow the pattern:
 * - dryRun=true: Return preview of what would happen
 * - dryRun=false: Return "Not implemented" until Phase 4
 */

type PlaceholderOutput = {
  _placeholder: true
  _message: string
  [key: string]: unknown
}

function createPlaceholder(toolName: string, previewOutput: Record<string, unknown>): ToolHandler {
  return async (input: unknown, context: ExecutionContext, dryRun: boolean): Promise<PlaceholderOutput> => {
    if (dryRun) {
      return {
        _placeholder: true,
        _message: `[DRY RUN] Would execute ${toolName}`,
        ...previewOutput
      }
    }

    // Real execution not implemented yet
    return {
      _placeholder: true,
      _message: `Tool ${toolName} not implemented yet. Coming in Phase 4.`,
      ...previewOutput
    }
  }
}

// Export handlers for each CRM tool
export const crmHandlers: Record<string, ToolHandler> = {
  'crm.contact.create': createPlaceholder('crm.contact.create', {
    contactId: 'placeholder-contact-id',
    created: true
  }),

  'crm.contact.update': createPlaceholder('crm.contact.update', {
    contactId: 'placeholder-contact-id',
    updated: true,
    changedFields: ['name', 'phone']
  }),

  'crm.contact.delete': createPlaceholder('crm.contact.delete', {
    contactId: 'placeholder-contact-id',
    deleted: true
  }),

  'crm.contact.read': createPlaceholder('crm.contact.read', {
    contact: {
      id: 'placeholder-contact-id',
      name: 'Placeholder Contact',
      phone: '+573001234567'
    }
  }),

  'crm.contact.list': createPlaceholder('crm.contact.list', {
    contacts: [],
    total: 0,
    page: 1,
    pageSize: 20,
    totalPages: 0
  }),

  'crm.tag.add': createPlaceholder('crm.tag.add', {
    contactId: 'placeholder-contact-id',
    tag: 'placeholder-tag',
    added: true,
    alreadyHadTag: false
  }),

  'crm.tag.remove': createPlaceholder('crm.tag.remove', {
    contactId: 'placeholder-contact-id',
    tag: 'placeholder-tag',
    removed: true,
    hadTag: true
  }),

  'crm.order.create': createPlaceholder('crm.order.create', {
    orderId: 'placeholder-order-id',
    created: true,
    total: 0
  }),

  'crm.order.updateStatus': createPlaceholder('crm.order.updateStatus', {
    orderId: 'placeholder-order-id',
    previousStatus: 'pending',
    newStatus: 'processing',
    updated: true
  })
}
```

**2. WhatsApp Placeholder Handlers:**
```typescript
// src/lib/tools/handlers/whatsapp/index.ts
import type { ToolHandler, ExecutionContext } from '../../types'

/**
 * WhatsApp Tool Handlers (Placeholders)
 *
 * Real implementations come in Phase 7.
 *
 * PHASE_7_CONTRACT: Replace placeholder handlers with real implementations.
 * Do NOT create new handler files - modify this file directly.
 * The registry in init.ts imports from this file.
 */

type PlaceholderOutput = {
  _placeholder: true
  _message: string
  [key: string]: unknown
}

function createPlaceholder(toolName: string, previewOutput: Record<string, unknown>): ToolHandler {
  return async (input: unknown, context: ExecutionContext, dryRun: boolean): Promise<PlaceholderOutput> => {
    if (dryRun) {
      return {
        _placeholder: true,
        _message: `[DRY RUN] Would execute ${toolName}`,
        ...previewOutput
      }
    }

    return {
      _placeholder: true,
      _message: `Tool ${toolName} not implemented yet. Coming in Phase 7.`,
      ...previewOutput
    }
  }
}

export const whatsappHandlers: Record<string, ToolHandler> = {
  'whatsapp.message.send': createPlaceholder('whatsapp.message.send', {
    messageId: 'placeholder-message-id',
    sent: true,
    timestamp: new Date().toISOString()
  }),

  'whatsapp.message.list': createPlaceholder('whatsapp.message.list', {
    messages: [],
    hasMore: false
  }),

  'whatsapp.template.send': createPlaceholder('whatsapp.template.send', {
    messageId: 'placeholder-message-id',
    sent: true,
    templateUsed: 'placeholder-template'
  }),

  'whatsapp.template.list': createPlaceholder('whatsapp.template.list', {
    templates: []
  }),

  'whatsapp.conversation.list': createPlaceholder('whatsapp.conversation.list', {
    conversations: [],
    total: 0,
    page: 1,
    totalPages: 0
  }),

  'whatsapp.conversation.assign': createPlaceholder('whatsapp.conversation.assign', {
    conversationId: 'placeholder-conversation-id',
    previousAgent: null,
    newAgent: 'placeholder-agent-id',
    assigned: true
  }),

  'whatsapp.conversation.close': createPlaceholder('whatsapp.conversation.close', {
    conversationId: 'placeholder-conversation-id',
    closed: true,
    closedAt: new Date().toISOString()
  })
}
```

**3. Tool Initialization:**
```typescript
// src/lib/tools/init.ts
import { toolRegistry } from './registry'
import { crmToolSchemas } from './schemas/crm.tools'
import { whatsappToolSchemas } from './schemas/whatsapp.tools'
import { crmHandlers } from './handlers/crm'
import { whatsappHandlers } from './handlers/whatsapp'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('tools-init')

let initialized = false

/**
 * Initialize the Tool Registry with all available tools
 *
 * Call this once at app startup via instrumentation.ts (see Task 4)
 */
export function initializeTools(): void {
  if (initialized) {
    logger.warn({ event: 'tools_already_initialized' })
    return
  }

  const startTime = Date.now()

  // Register CRM tools
  for (const schema of crmToolSchemas) {
    const handler = crmHandlers[schema.name]
    if (!handler) {
      logger.error({
        event: 'missing_handler',
        tool_name: schema.name,
        module: 'crm'
      })
      continue
    }
    toolRegistry.register(schema, handler)
  }

  // Register WhatsApp tools
  for (const schema of whatsappToolSchemas) {
    const handler = whatsappHandlers[schema.name]
    if (!handler) {
      logger.error({
        event: 'missing_handler',
        tool_name: schema.name,
        module: 'whatsapp'
      })
      continue
    }
    toolRegistry.register(schema, handler)
  }

  initialized = true

  logger.info({
    event: 'tools_initialized',
    total_tools: toolRegistry.size,
    crm_tools: crmToolSchemas.length,
    whatsapp_tools: whatsappToolSchemas.length,
    duration_ms: Date.now() - startTime
  })
}

/**
 * Check if tools are initialized
 */
export function areToolsInitialized(): boolean {
  return initialized
}

/**
 * Reset initialization (for testing)
 */
export function resetToolsInitialization(): void {
  initialized = false
}
```

This provides:
- Placeholder handlers that work in dry-run mode
- Clear messaging about implementation status
- Single initialization entry point
- Logging for debugging
  </action>
  <verify>
```typescript
import { initializeTools } from '@/lib/tools/init'
import { toolRegistry } from '@/lib/tools/registry'

initializeTools()
console.log('Registered tools:', toolRegistry.size) // Should be 16
console.log('CRM tools:', toolRegistry.listToolsByModule('crm').length) // Should be 9
console.log('WhatsApp tools:', toolRegistry.listToolsByModule('whatsapp').length) // Should be 7
```
  </verify>
  <done>16 tools registered (9 CRM + 7 WhatsApp) with placeholder handlers.</done>
</task>

<task type="auto">
  <name>Task 4: Create Instrumentation Hook for App Startup</name>
  <files>src/instrumentation.ts</files>
  <action>
Create the Next.js instrumentation hook to call initializeTools() on app startup:

```typescript
// src/instrumentation.ts
/**
 * Next.js Instrumentation Hook
 *
 * This file is automatically loaded by Next.js on server startup.
 * See: https://nextjs.org/docs/app/building-your-application/optimizing/instrumentation
 *
 * We use this to initialize the Tool Registry once at startup,
 * rather than lazy-loading on first request.
 */

export async function register() {
  // Only run on server (not edge runtime for middleware)
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    // Dynamic import to avoid issues with client bundles
    const { initializeTools } = await import('@/lib/tools/init')

    console.log('[instrumentation] Initializing tool registry...')
    initializeTools()
    console.log('[instrumentation] Tool registry initialized')
  }
}
```

**Also verify next.config.js has instrumentation enabled** (it is by default in Next.js 15+, but verify):

The instrumentation.ts file must be in the src/ directory (or root if no src/).

This ensures:
- Tools are registered ONCE at server startup
- No race conditions with first API request
- Registry is ready before any API calls arrive
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Check logs for "[instrumentation] Tool registry initialized"
3. Call GET /api/v1/tools - should return 16 tools immediately (no lazy init)
  </verify>
  <done>initializeTools() is called on app startup via Next.js instrumentation hook.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new files
2. `initializeTools()` registers 16 tools
3. `toolRegistry.listTools()` returns all 16 schemas
4. `toolRegistry.listToolsByModule('crm')` returns 9 tools
5. `toolRegistry.listToolsByModule('whatsapp')` returns 7 tools
6. Validation works: invalid input to crm.contact.create throws ValidationError
7. Dry-run execution returns placeholder output with `_placeholder: true`
8. Dev server logs show "[instrumentation] Tool registry initialized" on startup
</verification>

<success_criteria>
- 9 CRM tool schemas defined (contact CRUD, tags, orders)
- 7 WhatsApp tool schemas defined (messages, templates, conversations)
- All tools have placeholder handlers
- initializeTools() registers all 16 tools
- Validation works against JSON Schemas
- Dry-run mode returns preview outputs
- Tools are initialized at app startup via instrumentation.ts
</success_criteria>

<output>
After completion, create `.planning/phases/03-action-dsl-core/03-03-SUMMARY.md`
</output>
