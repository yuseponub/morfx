---
phase: 09-crm-whatsapp-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260203000001_crm_whatsapp_sync.sql
  - src/lib/types/database.ts
  - src/lib/orders/stage-phases.ts
autonomous: true

must_haves:
  truths:
    - "conversation_tags table exists with proper RLS policies"
    - "tags table has applies_to field with default 'both'"
    - "Auto-tag trigger adds 'Cliente' tag when order reaches 'Ganado'"
    - "Stage-to-phase mapping available for order status indicators"
  artifacts:
    - path: "supabase/migrations/20260203000001_crm_whatsapp_sync.sql"
      provides: "Database schema for conversation tags and tag scope"
      contains: "CREATE TABLE conversation_tags"
    - path: "src/lib/orders/stage-phases.ts"
      provides: "Order phase mapping for UI indicators"
      exports: ["OrderPhase", "STAGE_TO_PHASE", "PHASE_INDICATORS", "getOrderPhase"]
    - path: "src/lib/types/database.ts"
      provides: "Extended Tag type with applies_to field"
      contains: "applies_to"
  key_links:
    - from: "migration"
      to: "tags table"
      via: "ALTER TABLE adds applies_to column"
      pattern: "ALTER TABLE tags ADD COLUMN applies_to"
---

<objective>
Create the database foundation for CRM-WhatsApp synchronization.

Purpose: This plan establishes the schema changes needed for bidirectional tag sync (conversation_tags table, tag scope field) and automatic business logic (auto-tag Cliente on Ganado). It also creates the stage-to-phase mapping utility for order status display in WhatsApp.

Output: Migration file with conversation_tags table, RLS policies, tags.applies_to field, auto-tag trigger. Stage-phases utility for frontend use.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-crm-whatsapp-sync/09-CONTEXT.md
@.planning/phases/09-crm-whatsapp-sync/09-RESEARCH.md

# Existing patterns
@supabase/migrations/20260129000001_contacts_and_tags.sql
@supabase/migrations/20260129000003_orders_foundation.sql
@src/lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration for conversation_tags and tag scope</name>
  <files>supabase/migrations/20260203000001_crm_whatsapp_sync.sql</files>
  <action>
Create a migration file with the following components:

1. **Add applies_to column to tags table:**
```sql
-- Tag scope: 'whatsapp' (only conversations), 'orders' (only orders), 'both' (default)
ALTER TABLE tags ADD COLUMN applies_to TEXT NOT NULL DEFAULT 'both'
  CHECK (applies_to IN ('whatsapp', 'orders', 'both'));
```

2. **Create conversation_tags junction table:**
```sql
CREATE TABLE conversation_tags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT timezone('America/Bogota', NOW()),
  UNIQUE(conversation_id, tag_id)
);

CREATE INDEX idx_conversation_tags_conversation ON conversation_tags(conversation_id);
CREATE INDEX idx_conversation_tags_tag ON conversation_tags(tag_id);
```

3. **Enable RLS and create policies for conversation_tags:**
```sql
ALTER TABLE conversation_tags ENABLE ROW LEVEL SECURITY;

-- SELECT: workspace member via parent conversation
CREATE POLICY "conversation_tags_access_select"
  ON conversation_tags FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM conversations
      WHERE conversations.id = conversation_tags.conversation_id
      AND is_workspace_member(conversations.workspace_id)
    )
  );

-- INSERT: workspace member via parent conversation
CREATE POLICY "conversation_tags_access_insert"
  ON conversation_tags FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM conversations
      WHERE conversations.id = conversation_tags.conversation_id
      AND is_workspace_member(conversations.workspace_id)
    )
  );

-- DELETE: workspace member via parent conversation
CREATE POLICY "conversation_tags_access_delete"
  ON conversation_tags FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM conversations
      WHERE conversations.id = conversation_tags.conversation_id
      AND is_workspace_member(conversations.workspace_id)
    )
  );
```

4. **Create auto-tag trigger for Cliente on Ganado:**
```sql
-- Function to auto-tag contact as "Cliente" when order reaches "Ganado" stage
CREATE OR REPLACE FUNCTION auto_tag_cliente_on_ganado()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  cliente_tag_id UUID;
BEGIN
  -- Only process if stage changed
  IF OLD.stage_id = NEW.stage_id THEN
    RETURN NEW;
  END IF;

  -- Check if new stage is a closed/won stage named "Ganado"
  IF NEW.contact_id IS NOT NULL THEN
    -- Check if the new stage is "Ganado" (closed and named Ganado)
    IF EXISTS (
      SELECT 1 FROM pipeline_stages
      WHERE id = NEW.stage_id
        AND is_closed = true
        AND LOWER(name) = 'ganado'
    ) THEN
      -- Find "Cliente" tag in this workspace (create if not exists)
      SELECT id INTO cliente_tag_id
      FROM tags
      WHERE workspace_id = NEW.workspace_id
        AND LOWER(name) = 'cliente';

      -- If tag exists, add to contact (idempotent)
      IF cliente_tag_id IS NOT NULL THEN
        INSERT INTO contact_tags (contact_id, tag_id)
        VALUES (NEW.contact_id, cliente_tag_id)
        ON CONFLICT (contact_id, tag_id) DO NOTHING;
      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- Attach trigger to orders table
CREATE TRIGGER orders_auto_tag_cliente
  AFTER UPDATE ON orders
  FOR EACH ROW
  EXECUTE FUNCTION auto_tag_cliente_on_ganado();
```

5. **Enable Realtime for conversation_tags:**
```sql
-- Enable Realtime replication for conversation_tags (for sync updates)
ALTER PUBLICATION supabase_realtime ADD TABLE conversation_tags;
```

Use America/Bogota timezone for all timestamps. Follow existing migration patterns from the codebase.
  </action>
  <verify>
Check migration file syntax is valid SQL. Verify:
- conversation_tags table has proper structure
- RLS policies reference is_workspace_member function
- Trigger function handles NULL checks properly
- applies_to column has CHECK constraint
  </verify>
  <done>
Migration file exists with conversation_tags table, RLS policies, applies_to column, and auto-tag trigger for Ganado->Cliente.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stage-to-phase mapping utility</name>
  <files>src/lib/orders/stage-phases.ts</files>
  <action>
Create a utility file that maps order pipeline stages to display phases for the WhatsApp UI.

```typescript
// ============================================================================
// Order Stage to Phase Mapping
// Maps pipeline stages to simplified display phases for WhatsApp conversation UI
// ============================================================================

/**
 * Simplified order phase for display in conversation list.
 * - pending: Needs attention (missing info, unconfirmed)
 * - confirmed: Ready to ship
 * - transit: In shipping process
 * - lost: Failed/returned order
 * - won: Completed successfully (no indicator shown)
 */
export type OrderPhase = 'pending' | 'confirmed' | 'transit' | 'lost' | 'won'

/**
 * Map stage names to phases.
 * Stage names are case-insensitive (converted to lowercase for lookup).
 *
 * Grouped by business meaning:
 * - Pending: Customer needs to confirm, missing info
 * - Confirmed: Order confirmed, ready for fulfillment
 * - Transit: In shipping process (any carrier status)
 * - Lost: Failed delivery, returned, cancelled
 * - Won: Successfully delivered and paid
 */
export const STAGE_TO_PHASE: Record<string, OrderPhase> = {
  // Pending info group - needs attention
  'nuevo': 'pending',
  'falta info': 'pending',
  'falta confirmar': 'pending',
  'pendiente': 'pending',
  'por confirmar': 'pending',

  // Confirmed group - ready for fulfillment
  'confirmado': 'confirmed',
  'en proceso': 'confirmed',
  'por despachar': 'confirmed',
  'listo para envio': 'confirmed',
  'preparando': 'confirmed',

  // Transit group - in shipping
  'despachado': 'transit',
  'enviado': 'transit',
  'en reparto': 'transit',
  'en camino': 'transit',
  'novedad': 'transit',
  'en transito': 'transit',

  // Lost group - failed
  'perdido': 'lost',
  'devuelto': 'lost',
  'cancelado': 'lost',
  'rechazado': 'lost',
  'no entregado': 'lost',

  // Won group - success
  'ganado': 'won',
  'entregado': 'won',
  'completado': 'won',
}

/**
 * Phase display indicators for the conversation list.
 * Emojis chosen for:
 * - Small visual footprint
 * - Clear meaning at a glance
 * - Subtle, not distracting
 */
export const PHASE_INDICATORS: Record<OrderPhase, { emoji: string; label: string; color: string }> = {
  pending: {
    emoji: '\u23F3',  // Hourglass (waiting/pending)
    label: 'Pendiente',
    color: '#f59e0b', // Amber
  },
  confirmed: {
    emoji: '\u2705',  // Check mark (confirmed)
    label: 'Confirmado',
    color: '#22c55e', // Green
  },
  transit: {
    emoji: '\uD83D\uDE9A',  // Delivery truck
    label: 'En transito',
    color: '#3b82f6', // Blue
  },
  lost: {
    emoji: '\u274C',  // Red X (failed)
    label: 'Perdido',
    color: '#ef4444', // Red
  },
  won: {
    emoji: '',  // No indicator for won orders
    label: '',
    color: '',
  },
}

/**
 * Get the phase for a given stage name.
 * Falls back to 'pending' for unknown stages.
 *
 * @param stageName - The pipeline stage name
 * @returns The order phase
 */
export function getOrderPhase(stageName: string): OrderPhase {
  const normalized = stageName.toLowerCase().trim()
  return STAGE_TO_PHASE[normalized] || 'pending'
}

/**
 * Check if an order phase should show an indicator.
 * Won orders don't show indicators (success = no visual noise).
 */
export function shouldShowIndicator(phase: OrderPhase): boolean {
  return phase !== 'won'
}
```

The emoji characters used:
- Hourglass: Unicode 23F3
- Check mark: Unicode 2705
- Truck: Unicode 1F69A (surrogate pair D83D DE9A)
- Red X: Unicode 274C

This provides consistent phase mapping across the application.
  </action>
  <verify>
Run TypeScript compilation check:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/orders/stage-phases.ts
```
  </verify>
  <done>
Stage-phases utility exists with OrderPhase type, STAGE_TO_PHASE mapping, PHASE_INDICATORS, and getOrderPhase function.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Tag type in database types</name>
  <files>src/lib/types/database.ts</files>
  <action>
Update the Tag interface in database.ts to include the new applies_to field.

Find the existing Tag interface and add the applies_to field:

```typescript
export interface Tag {
  id: string
  workspace_id: string
  name: string
  color: string
  applies_to: 'whatsapp' | 'orders' | 'both'  // NEW: Tag scope
  created_at: string
}
```

Also add a new TagScope type for reuse:

```typescript
/**
 * Tag scope determines where a tag can be applied.
 * - 'whatsapp': Only on conversations
 * - 'orders': Only on orders
 * - 'both': On both conversations and orders (default)
 */
export type TagScope = 'whatsapp' | 'orders' | 'both'
```

The Tag interface should be updated in place, preserving existing fields.
  </action>
  <verify>
Run TypeScript compilation check:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit
```
Verify no type errors related to Tag.applies_to.
  </verify>
  <done>
Tag interface includes applies_to field, TagScope type is exported.
  </done>
</task>

</tasks>

<verification>
1. Migration file is syntactically valid SQL
2. TypeScript compiles without errors
3. Stage-phases utility exports all required symbols
4. Tag type has applies_to field
</verification>

<success_criteria>
- conversation_tags table schema defined with proper RLS
- tags.applies_to column added with CHECK constraint
- auto_tag_cliente_on_ganado trigger created
- Stage-to-phase mapping utility ready for use
- Tag type updated with applies_to field
</success_criteria>

<output>
After completion, create `.planning/phases/09-crm-whatsapp-sync/09-01-SUMMARY.md`
</output>
