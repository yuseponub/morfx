---
phase: 03-action-dsl-core
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/middleware.ts
  - src/lib/auth/api-key.ts
  - src/app/api/v1/tools/route.ts
  - src/app/api/v1/tools/[toolName]/route.ts
autonomous: true

user_setup:
  - service: api_keys
    why: "External API access requires API keys stored in database"
    env_vars: []
    dashboard_config:
      - task: "API keys are created via MorfX UI (Phase 10) or manually in database"
        location: "Supabase Dashboard -> api_keys table"

must_haves:
  truths:
    - "External systems can invoke tools via POST /api/v1/tools/{toolName}"
    - "API key authentication validates against api_keys table"
    - "listTools endpoint returns all available tools"
    - "Invalid API key returns 401 Unauthorized"
    - "Invalid inputs return 400 with validation errors"
  artifacts:
    - path: "src/lib/auth/api-key.ts"
      provides: "API key validation utility"
      exports: ["validateApiKey", "hashApiKey"]
    - path: "src/app/api/v1/tools/route.ts"
      provides: "List tools endpoint"
      exports: ["GET"]
    - path: "src/app/api/v1/tools/[toolName]/route.ts"
      provides: "Dynamic tool invocation endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/auth/api-key.ts"
      via: "validateApiKey call"
      pattern: "validateApiKey"
    - from: "src/app/api/v1/tools/[toolName]/route.ts"
      to: "src/lib/tools/executor.ts"
      via: "executeTool call"
      pattern: "executeTool"
---

<objective>
Create the external API layer for tool invocation with API key authentication.

Purpose: This enables external systems (AI agents, n8n, webhooks) to discover and invoke tools programmatically. The API is the bridge between Action DSL and the outside world.

Output: Working API endpoints for tool discovery and invocation with secure API key authentication.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-action-dsl-core/03-CONTEXT.md
@.planning/phases/03-action-dsl-core/03-RESEARCH.md
@.planning/phases/03-action-dsl-core/03-02-SUMMARY.md
@.planning/phases/03-action-dsl-core/03-03-SUMMARY.md
@src/lib/tools/registry.ts
@src/lib/tools/executor.ts
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API Key Validation Utility</name>
  <files>src/lib/auth/api-key.ts</files>
  <action>
Create the API key validation utility that checks keys against the database:

```typescript
// src/lib/auth/api-key.ts
import { createClient } from '@supabase/supabase-js'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('api-key')

/**
 * API Key validation result
 */
export interface ApiKeyValidation {
  valid: boolean
  workspaceId?: string
  permissions?: string[]
  error?: string
}

/**
 * Hash an API key for storage/comparison
 *
 * We use SHA-256 for API keys (not bcrypt) because:
 * 1. API keys are random, not user-chosen (no dictionary attacks)
 * 2. We need fast comparison for every request
 * 3. Keys are long (32+ chars) so brute force is impractical
 *
 * For user passwords, use bcrypt instead.
 */
export async function hashApiKey(key: string): Promise<string> {
  const encoder = new TextEncoder()
  const data = encoder.encode(key)
  const hashBuffer = await crypto.subtle.digest('SHA-256', data)
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('')
}

/**
 * Generate a new API key with prefix
 *
 * Format: mfx_{random 32 chars}
 * Example: mfx_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
 */
export function generateApiKey(): { key: string; prefix: string } {
  const randomBytes = crypto.getRandomValues(new Uint8Array(24))
  const randomPart = Array.from(randomBytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
    .substring(0, 32)

  const key = `mfx_${randomPart}`
  const prefix = key.substring(0, 8) // "mfx_a1b2"

  return { key, prefix }
}

/**
 * Validate an API key against the database
 *
 * This function is Edge Runtime compatible (uses fetch, not Node.js-only APIs)
 */
export async function validateApiKey(apiKey: string): Promise<ApiKeyValidation> {
  try {
    // Validate format
    if (!apiKey.startsWith('mfx_') || apiKey.length < 36) {
      return { valid: false, error: 'Invalid API key format' }
    }

    // Hash the key
    const keyHash = await hashApiKey(apiKey)

    // Query database (using service role for validation)
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY

    if (!supabaseUrl || !supabaseServiceKey) {
      logger.error({ event: 'missing_supabase_config' })
      return { valid: false, error: 'Server configuration error' }
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    const { data, error } = await supabase
      .from('api_keys')
      .select('workspace_id, permissions, expires_at')
      .eq('key_hash', keyHash)
      .eq('revoked', false)
      .single()

    if (error || !data) {
      logger.debug({
        event: 'api_key_not_found',
        prefix: apiKey.substring(0, 8)
      })
      return { valid: false, error: 'Invalid API key' }
    }

    // Check expiration
    if (data.expires_at && new Date(data.expires_at) < new Date()) {
      logger.debug({
        event: 'api_key_expired',
        prefix: apiKey.substring(0, 8)
      })
      return { valid: false, error: 'API key expired' }
    }

    // Update last_used_at (fire and forget)
    supabase
      .from('api_keys')
      .update({ last_used_at: new Date().toISOString() })
      .eq('key_hash', keyHash)
      .then(() => {})
      .catch(() => {})

    logger.debug({
      event: 'api_key_validated',
      prefix: apiKey.substring(0, 8),
      workspace_id: data.workspace_id
    })

    return {
      valid: true,
      workspaceId: data.workspace_id,
      permissions: data.permissions || []
    }
  } catch (err) {
    logger.error({
      event: 'api_key_validation_error',
      error: err instanceof Error ? err.message : 'Unknown error'
    })
    return { valid: false, error: 'Validation error' }
  }
}

/**
 * Extract API key from Authorization header
 */
export function extractApiKey(authHeader: string | null): string | null {
  if (!authHeader) return null
  if (!authHeader.startsWith('Bearer ')) return null
  return authHeader.substring(7)
}
```

Key design decisions:
- SHA-256 for API keys (fast, secure for random keys)
- Edge Runtime compatible (uses Web Crypto API)
- Prefix format (mfx_xxxx...) for easy identification
- Updates last_used_at on successful validation
  </action>
  <verify>
```typescript
import { generateApiKey, hashApiKey, validateApiKey } from '@/lib/auth/api-key'

// Test key generation
const { key, prefix } = generateApiKey()
console.log('Generated key:', key)
console.log('Prefix:', prefix)
// Key should start with "mfx_" and be ~40 chars

// Test hashing
const hash = await hashApiKey(key)
console.log('Hash:', hash)
// Hash should be 64 chars hex

// Test validation (should fail - no key in DB)
const result = await validateApiKey(key)
console.log('Validation:', result)
// Should return { valid: false, error: 'Invalid API key' }
```
  </verify>
  <done>API key validation utility works with Edge Runtime and SHA-256 hashing.</done>
</task>

<task type="auto">
  <name>Task 2: Update Middleware for API Key Authentication</name>
  <files>src/middleware.ts</files>
  <action>
Update the EXISTING middleware to ADD API key authentication for /api/v1/tools routes.

**IMPORTANT: This is a MERGE, not a replacement.**
- The existing middleware already has `updateSession` for auth
- ADD the API key check BEFORE the existing session logic
- The /api/v1/tools routes should use API key auth
- All other routes continue using the existing session auth

Read the current middleware.ts first, then add the API tools block at the beginning of the function:

```typescript
// src/middleware.ts
import { type NextRequest, NextResponse } from 'next/server'
import { updateSession } from '@/lib/supabase/middleware'
import { validateApiKey, extractApiKey } from '@/lib/auth/api-key'

export async function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname

  // ==================== API TOOL ROUTES (NEW - ADD THIS BLOCK) ====================
  // Handle /api/v1/tools/* with API key authentication
  // This runs BEFORE the existing session logic
  if (pathname.startsWith('/api/v1/tools')) {
    const authHeader = request.headers.get('authorization')
    const apiKey = extractApiKey(authHeader)

    if (!apiKey) {
      return NextResponse.json(
        { error: 'Missing API key', code: 'MISSING_API_KEY' },
        { status: 401 }
      )
    }

    const validation = await validateApiKey(apiKey)

    if (!validation.valid) {
      return NextResponse.json(
        { error: validation.error || 'Invalid API key', code: 'INVALID_API_KEY' },
        { status: 401 }
      )
    }

    // Pass workspace context to route handlers via headers
    const response = NextResponse.next()
    response.headers.set('x-workspace-id', validation.workspaceId!)
    response.headers.set('x-permissions', JSON.stringify(validation.permissions || []))
    response.headers.set('x-api-key-prefix', apiKey.substring(0, 8))

    return response
  }

  // ==================== EXISTING SESSION AUTH (KEEP AS-IS) ====================
  // Handle session for all other routes (existing behavior from Phase 1-2)
  // DO NOT MODIFY THIS PART - it handles user authentication for the web app
  return await updateSession(request)
}

// Keep the existing matcher config unchanged
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

**Merge strategy:**
1. Add import for `validateApiKey, extractApiKey`
2. Add the /api/v1/tools block at the START of the middleware function
3. Keep all existing code (updateSession call, config matcher) unchanged
4. The existing session handling remains the fallback for all non-API routes
  </action>
  <verify>
1. Start dev server
2. `curl http://localhost:3020/api/v1/tools` - should return 401 "Missing API key"
3. `curl -H "Authorization: Bearer invalid" http://localhost:3020/api/v1/tools` - should return 401 "Invalid API key"
4. Visit http://localhost:3020/login - should still work (existing session auth)
5. Visit http://localhost:3020/dashboard - should still redirect to login if not authenticated
  </verify>
  <done>Middleware validates API keys for /api/v1/tools routes while preserving existing session auth.</done>
</task>

<task type="auto">
  <name>Task 3: Create Tool API Endpoints</name>
  <files>
    src/app/api/v1/tools/route.ts
    src/app/api/v1/tools/[toolName]/route.ts
  </files>
  <action>
Create the API endpoints for tool discovery and invocation:

**1. List Tools Endpoint:**
```typescript
// src/app/api/v1/tools/route.ts
import { NextResponse } from 'next/server'
import { toolRegistry } from '@/lib/tools/registry'
import { initializeTools, areToolsInitialized } from '@/lib/tools/init'

/**
 * GET /api/v1/tools
 *
 * List all available tools (MCP-compatible discovery endpoint)
 *
 * Query params:
 * - module: Filter by module (crm, whatsapp, system)
 * - permission: Filter by required permission
 *
 * Response:
 * {
 *   tools: ToolSchema[],
 *   total: number
 * }
 */
export async function GET(request: Request) {
  // Ensure tools are initialized
  if (!areToolsInitialized()) {
    initializeTools()
  }

  const { searchParams } = new URL(request.url)
  const moduleFilter = searchParams.get('module')
  const permissionFilter = searchParams.get('permission')

  let tools = toolRegistry.listTools()

  // Apply filters
  if (moduleFilter) {
    tools = tools.filter((t) => t.metadata.module === moduleFilter)
  }

  if (permissionFilter) {
    tools = tools.filter((t) => t.metadata.permissions.includes(permissionFilter))
  }

  return NextResponse.json({
    tools,
    total: tools.length
  })
}
```

**2. Execute Tool Endpoint:**
```typescript
// src/app/api/v1/tools/[toolName]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { executeTool, ValidationError, PermissionError } from '@/lib/tools/executor'
import { toolRegistry } from '@/lib/tools/registry'
import { initializeTools, areToolsInitialized } from '@/lib/tools/init'
import type { ExecutionContext } from '@/lib/tools/types'

/**
 * POST /api/v1/tools/{toolName}
 *
 * Execute a tool
 *
 * Request body:
 * {
 *   inputs: object,      // Tool-specific inputs
 *   dry_run?: boolean    // If true, validate and simulate only
 * }
 *
 * Headers (set by middleware):
 * - x-workspace-id: Workspace ID from API key
 * - x-permissions: JSON array of permissions
 * - x-api-key-prefix: Key prefix for logging
 *
 * Response (success):
 * {
 *   execution_id: string,
 *   status: 'success' | 'dry_run',
 *   outputs: object,
 *   duration_ms: number
 * }
 *
 * Response (error):
 * {
 *   error: string,
 *   code: string,
 *   details?: object
 * }
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ toolName: string }> }
) {
  // Ensure tools are initialized
  if (!areToolsInitialized()) {
    initializeTools()
  }

  try {
    const { toolName } = await params

    // Validate tool exists
    if (!toolRegistry.hasTool(toolName)) {
      return NextResponse.json(
        {
          error: `Unknown tool: ${toolName}`,
          code: 'UNKNOWN_TOOL',
          available_tools: toolRegistry.listTools().map((t) => t.name)
        },
        { status: 404 }
      )
    }

    // Parse request body
    let body: { inputs?: unknown; dry_run?: boolean }
    try {
      body = await request.json()
    } catch {
      return NextResponse.json(
        { error: 'Invalid JSON body', code: 'INVALID_JSON' },
        { status: 400 }
      )
    }

    const { inputs = {}, dry_run = false } = body

    // Extract context from middleware headers
    const workspaceId = request.headers.get('x-workspace-id')
    const permissionsHeader = request.headers.get('x-permissions')
    const apiKeyPrefix = request.headers.get('x-api-key-prefix')

    if (!workspaceId) {
      return NextResponse.json(
        { error: 'Missing workspace context', code: 'MISSING_CONTEXT' },
        { status: 500 }
      )
    }

    // Build execution context
    const context: ExecutionContext = {
      userId: null, // API calls don't have user ID
      workspaceId,
      requestContext: {
        ip: request.headers.get('x-forwarded-for') ||
            request.headers.get('x-real-ip') ||
            'unknown',
        userAgent: request.headers.get('user-agent') || 'unknown',
        source: 'api'
      }
    }

    // Execute tool
    const result = await executeTool(toolName, inputs, {
      dryRun: dry_run,
      context
    })

    // Return result
    if (result.status === 'error') {
      return NextResponse.json(
        {
          error: result.error?.message || 'Tool execution failed',
          code: 'EXECUTION_ERROR',
          execution_id: result.id
        },
        { status: 500 }
      )
    }

    return NextResponse.json({
      execution_id: result.id,
      status: result.status,
      outputs: result.outputs,
      duration_ms: result.durationMs
    })
  } catch (error) {
    // Handle validation errors
    if (error instanceof ValidationError) {
      return NextResponse.json(
        {
          error: 'Validation failed',
          code: 'VALIDATION_ERROR',
          details: error.errors
        },
        { status: 400 }
      )
    }

    // Handle permission errors
    if (error instanceof PermissionError) {
      return NextResponse.json(
        {
          error: error.message,
          code: 'PERMISSION_DENIED'
        },
        { status: 403 }
      )
    }

    // Log unexpected errors
    console.error('Tool API error:', error)

    return NextResponse.json(
      {
        error: 'Internal server error',
        code: 'INTERNAL_ERROR'
      },
      { status: 500 }
    )
  }
}

/**
 * GET /api/v1/tools/{toolName}
 *
 * Get tool schema/documentation
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ toolName: string }> }
) {
  if (!areToolsInitialized()) {
    initializeTools()
  }

  const { toolName } = await params

  if (!toolRegistry.hasTool(toolName)) {
    return NextResponse.json(
      { error: `Unknown tool: ${toolName}`, code: 'UNKNOWN_TOOL' },
      { status: 404 }
    )
  }

  const tools = toolRegistry.listTools()
  const tool = tools.find((t) => t.name === toolName)

  return NextResponse.json({ tool })
}
```

The API provides:
- GET /api/v1/tools - List all tools (discovery)
- GET /api/v1/tools?module=crm - Filter by module
- GET /api/v1/tools/{name} - Get single tool schema
- POST /api/v1/tools/{name} - Execute a tool
  </action>
  <verify>
Test with curl (need valid API key in DB first):

```bash
# 1. Insert test API key in Supabase (via dashboard or SQL)
# key: mfx_testkey123456789012345678901234
# key_hash: (hash of above)
# workspace_id: (your workspace UUID)

# 2. List tools
curl -H "Authorization: Bearer mfx_testkey..." http://localhost:3020/api/v1/tools
# Should return { tools: [...], total: 16 }

# 3. Get single tool
curl -H "Authorization: Bearer mfx_testkey..." http://localhost:3020/api/v1/tools/crm.contact.create
# Should return tool schema

# 4. Execute with dry-run
curl -X POST -H "Authorization: Bearer mfx_testkey..." \
  -H "Content-Type: application/json" \
  -d '{"inputs": {"name": "Test", "phone": "+573001234567"}, "dry_run": true}' \
  http://localhost:3020/api/v1/tools/crm.contact.create
# Should return { execution_id, status: "dry_run", outputs: {...} }

# 5. Validation error
curl -X POST -H "Authorization: Bearer mfx_testkey..." \
  -H "Content-Type: application/json" \
  -d '{"inputs": {"name": "Test"}}' \
  http://localhost:3020/api/v1/tools/crm.contact.create
# Should return 400 with validation errors (missing phone)
```
  </verify>
  <done>API endpoints work for tool discovery and invocation with proper error handling.</done>
</task>

</tasks>

<verification>
1. API key validation works (invalid key returns 401)
2. GET /api/v1/tools returns all 16 tools
3. GET /api/v1/tools?module=crm returns 9 CRM tools
4. GET /api/v1/tools/crm.contact.create returns schema
5. POST with dry_run=true returns status "dry_run"
6. POST with invalid inputs returns 400 with validation details
7. POST to unknown tool returns 404
8. Executions are logged to tool_executions table
9. Existing web app auth still works (login, dashboard, etc.)
</verification>

<success_criteria>
- API key validation rejects invalid/expired keys
- listTools endpoint returns all registered tools
- Tool execution works with dry-run mode
- Validation errors return detailed error messages
- All executions are logged to database
- Middleware correctly passes workspace context
- Existing session auth is preserved for web app routes
</success_criteria>

<output>
After completion, create `.planning/phases/03-action-dsl-core/03-04-SUMMARY.md`
</output>
