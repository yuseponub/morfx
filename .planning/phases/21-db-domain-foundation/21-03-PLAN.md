---
phase: 21-db-domain-foundation
plan: 03
type: execute
wave: 2
depends_on: ["21-01", "21-02"]
files_modified:
  - src/lib/logistics/constants.ts
  - src/lib/domain/carrier-coverage.ts
  - src/lib/domain/carrier-configs.ts
autonomous: true

must_haves:
  truths:
    - "Given a city name and department, validateCity returns whether Coordinadora covers it and whether COD is available"
    - "Department name variants (full name, abbreviations, accent variants) all resolve to the correct Coordinadora abbreviation"
    - "normalizeText removes accents, uppercases, and trims -- matching the robot's normalization logic exactly"
    - "Workspace admin can upsert carrier credentials via domain function"
    - "getCarrierConfig returns credentials for a workspace+carrier pair, or null if not configured"
  artifacts:
    - path: "src/lib/logistics/constants.ts"
      provides: "DEPARTMENT_ABBREVIATIONS mapping, normalizeText utility, mapDepartmentToAbbrev function"
      exports: ["DEPARTMENT_ABBREVIATIONS", "normalizeText", "mapDepartmentToAbbrev"]
    - path: "src/lib/domain/carrier-coverage.ts"
      provides: "validateCity, validateCities (batch), getCoverageStats domain functions"
      exports: ["validateCity", "validateCities", "getCoverageStats"]
    - path: "src/lib/domain/carrier-configs.ts"
      provides: "getCarrierConfig, upsertCarrierConfig domain functions"
      exports: ["getCarrierConfig", "upsertCarrierConfig"]
  key_links:
    - from: "src/lib/domain/carrier-coverage.ts"
      to: "src/lib/logistics/constants.ts"
      via: "imports normalizeText, mapDepartmentToAbbrev"
      pattern: "import.*from.*logistics/constants"
    - from: "src/lib/domain/carrier-coverage.ts"
      to: "carrier_coverage table"
      via: "supabase.from('carrier_coverage') query"
      pattern: "from\\('carrier_coverage'\\)"
    - from: "src/lib/domain/carrier-configs.ts"
      to: "carrier_configs table"
      via: "supabase.from('carrier_configs') query"
      pattern: "from\\('carrier_configs'\\)"
---

<objective>
Create logistics constants (department mapping, text normalization) and domain functions for city validation and carrier configuration.

Purpose: The constants module provides the department abbreviation mapping (35+ entries from the existing robot codebase) and text normalization -- these are shared across all carrier-related domain functions. The carrier-coverage domain provides city validation (the core operation for order dispatch). The carrier-configs domain provides CRUD for workspace carrier credentials. Together, these enable Phase 22 (robot service) to validate cities and Phase 23 (orchestrator) to retrieve credentials.

Output: Three TypeScript files: logistics constants, carrier-coverage domain module, carrier-configs domain module.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/21-db-domain-foundation/21-CONTEXT.md
@.planning/phases/21-db-domain-foundation/21-RESEARCH.md

# Domain layer patterns
@src/lib/domain/types.ts
@src/lib/domain/client-activation.ts
@src/lib/domain/orders.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logistics constants module</name>
  <files>src/lib/logistics/constants.ts</files>
  <action>
Create `src/lib/logistics/constants.ts` with ZERO imports from project files (same pattern as domain/types.ts -- prevents circular deps).

1. **normalizeText function:**
   ```typescript
   /**
    * Normalize text for city/department matching.
    * Mirrors the robot's normalization: uppercase + remove diacritics + trim.
    */
   export function normalizeText(text: string): string {
     return text
       .toUpperCase()
       .normalize('NFD')
       .replace(/[\u0300-\u036f]/g, '')
       .trim()
   }
   ```

2. **DEPARTMENT_ABBREVIATIONS constant:**
   A Record<string, string> mapping normalized department names to Coordinadora abbreviations. Include ALL entries from the robot's MAPEO_DEPARTAMENTOS (35+ entries) plus common variants.

   Must include at minimum:
   - AMAZONAS -> AMAZ
   - ANTIOQUIA -> ANT
   - ARAUCA -> ARAU
   - ATLANTICO -> ATL
   - BOGOTA -> C/MARCA
   - BOGOTA D.C. -> C/MARCA
   - BOGOTA, D.C. -> C/MARCA
   - DISTRITO CAPITAL -> C/MARCA
   - BOLIVAR -> BOL
   - BOYACA -> BOY
   - CALDAS -> CDAS
   - CAQUETA -> CAQ
   - CASANARE -> C/NARE
   - CAUCA -> CAU
   - CESAR -> CES
   - CHOCO -> CHOCO
   - CORDOBA -> CORD
   - CUNDINAMARCA -> C/MARCA
   - GUAINIA -> GUAI
   - GUAVIARE -> G/VIARE
   - GUAJIRA -> GUAJ
   - LA GUAJIRA -> GUAJ
   - HUILA -> HLA
   - MAGDALENA -> MG/LENA
   - META -> META
   - NARINO -> NAR
   - NORTE DE SANTANDER -> N/STDER
   - PUTUMAYO -> P/MAYO
   - QUINDIO -> QDIO
   - RISARALDA -> RS
   - SAN ANDRES -> S/ANDRES
   - SAN ANDRES Y PROVIDENCIA -> S/ANDRES
   - SANTANDER -> STDER
   - SUCRE -> SUCRE
   - TOLIMA -> TOL
   - VALLE DEL CAUCA -> VALLE
   - VALLE -> VALLE
   - VAUPES -> V/PES
   - VICHADA -> VICH
   - CIUDAD DE MEXICO -> CMX (Mexican cross-border)
   - ESTADO DE MEXICO -> MEX (Mexican cross-border)

   Keys MUST be normalized (uppercase, no accents) since they'll be compared against normalizeText() output.

3. **mapDepartmentToAbbrev function:**
   ```typescript
   /**
    * Map a department name (full or variant) to Coordinadora's abbreviation.
    * Returns null if no mapping found.
    */
   export function mapDepartmentToAbbrev(department: string): string | null {
     const normalized = normalizeText(department)
     return DEPARTMENT_ABBREVIATIONS[normalized] || null
   }
   ```

4. **PedidoInput interface** (TypeScript version of the robot's PedidoInput):
   ```typescript
   /**
    * Payload shape sent to the Coordinadora robot for order creation.
    * Mirrors robot-coordinadora's PedidoInput interface.
    */
   export interface PedidoInput {
     identificacion: string
     nombres: string
     apellidos: string
     direccion: string
     ciudad: string          // Coordinadora city format: "CITY (DEPT)"
     departamento: string    // Department abbreviation
     celular: string
     email: string
     referencia: string      // Order reference / name
     unidades: number
     totalConIva: number
     valorDeclarado: number
     esRecaudoContraentrega: boolean
     peso: number
     alto: number
     largo: number
     ancho: number
   }
   ```

**Critical:** This file must have ZERO imports from `@/lib/domain/`, `@/lib/supabase/`, or any other project module. It's a pure constants/utils file.
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/logistics/constants.ts` or verify no TypeScript errors.
Verify file has zero imports from project modules (only standard library used).
Verify DEPARTMENT_ABBREVIATIONS has at least 38 entries.
Verify normalizeText('Bogota D.C.') would produce 'BOGOTA D.C.' and mapDepartmentToAbbrev('Bogota D.C.') would return 'C/MARCA'.
  </verify>
  <done>
logistics/constants.ts exports normalizeText, DEPARTMENT_ABBREVIATIONS (38+ entries), mapDepartmentToAbbrev, and PedidoInput interface. Zero project imports. All department variants from the robot's MAPEO_DEPARTAMENTOS are included plus Mexican cross-border departments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create carrier-coverage domain module</name>
  <files>src/lib/domain/carrier-coverage.ts</files>
  <action>
Create `src/lib/domain/carrier-coverage.ts` following the exact domain module pattern from `orders.ts` and `client-activation.ts`.

The module provides city validation against the carrier_coverage table. This is the core lookup that determines whether an order can be dispatched to Coordinadora.

1. **Header comment** following the exact style of orders.ts:
   ```typescript
   // ============================================================================
   // Domain Layer -- Carrier Coverage
   // City validation against carrier coverage tables.
   // Uses createAdminClient (bypass RLS, workspace isolation not needed for reference data).
   // ============================================================================
   ```

2. **Imports:**
   ```typescript
   import { createAdminClient } from '@/lib/supabase/admin'
   import { normalizeText, mapDepartmentToAbbrev } from '@/lib/logistics/constants'
   import type { DomainContext, DomainResult } from './types'
   ```

3. **ValidateCity function** -- single city validation:
   ```typescript
   export interface ValidateCityParams {
     city: string
     department: string
     carrier?: string  // defaults to 'coordinadora'
   }

   export interface ValidateCityResult {
     isValid: boolean
     coordinadoraCity: string | null  // exact format: "MEDELLIN (ANT)"
     supportsCod: boolean
   }

   export async function validateCity(
     ctx: DomainContext,
     params: ValidateCityParams
   ): Promise<DomainResult<ValidateCityResult>>
   ```

   Implementation:
   - Default carrier to 'coordinadora'
   - normalizeText(params.city) to get normalized city
   - mapDepartmentToAbbrev(params.department) to get dept abbreviation
   - If dept abbreviation is null, return { success: true, data: { isValid: false, coordinadoraCity: null, supportsCod: false } }
   - Query carrier_coverage: `.from('carrier_coverage').select('city_coordinadora, supports_cod').eq('carrier', carrier).eq('city_name', normalizedCity).eq('department_abbrev', deptAbbrev).eq('is_active', true).single()`
   - If no match, return isValid: false
   - If match, return isValid: true with city_coordinadora and supports_cod
   - Wrap in try/catch, return DomainResult error on exception

4. **ValidateCities function** -- batch validation for multiple orders:
   ```typescript
   export interface ValidateCitiesParams {
     cities: Array<{ city: string; department: string; orderId?: string }>
     carrier?: string
   }

   export interface CityValidationItem {
     city: string
     department: string
     orderId?: string
     isValid: boolean
     coordinadoraCity: string | null
     supportsCod: boolean
     departmentAbbrev: string | null
   }

   export async function validateCities(
     ctx: DomainContext,
     params: ValidateCitiesParams
   ): Promise<DomainResult<{ results: CityValidationItem[]; validCount: number; invalidCount: number }>>
   ```

   Implementation:
   - For each city in params.cities, compute normalizedCity and deptAbbrev
   - Batch query: fetch ALL active coverage entries for the carrier in a single query (`.from('carrier_coverage').select('city_coordinadora, city_name, department_abbrev, supports_cod').eq('carrier', carrier).eq('is_active', true)`)
   - Build a lookup Map from `${city_name}|${department_abbrev}` to coverage row
   - For each input city, look up in the Map
   - Return results array with per-city validation + summary counts
   - This avoids N+1 queries for batch validation

5. **getCoverageStats function** -- summary statistics:
   ```typescript
   export async function getCoverageStats(
     ctx: DomainContext,
     carrier?: string
   ): Promise<DomainResult<{ totalCities: number; codCities: number; activeCities: number }>>
   ```

   Implementation: Simple count queries against carrier_coverage table.

**Key patterns to follow:**
- Use `createAdminClient()` (bypass RLS -- reference tables have no RLS anyway, but admin client is the domain standard)
- Every function returns `Promise<DomainResult<T>>`
- try/catch with `err instanceof Error ? err.message : String(err)` pattern
- ctx parameter is present for consistency even though reference tables don't need workspace_id
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/domain/carrier-coverage.ts` or check build succeeds.
Verify file imports from '@/lib/logistics/constants' and '@/lib/domain/types'.
Verify exports: validateCity, validateCities, getCoverageStats.
Verify validateCity queries carrier_coverage table with normalized city + dept abbreviation.
Verify validateCities uses batch query (single DB call, not N calls).
  </verify>
  <done>
carrier-coverage.ts exports validateCity (single), validateCities (batch with Map lookup), and getCoverageStats. All functions follow DomainResult pattern with createAdminClient(). City validation uses normalizeText + mapDepartmentToAbbrev from logistics constants. Batch validation uses single DB query with in-memory Map for O(1) lookups.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create carrier-configs domain module</name>
  <files>src/lib/domain/carrier-configs.ts</files>
  <action>
Create `src/lib/domain/carrier-configs.ts` following the pattern from `client-activation.ts` (workspace config CRUD).

1. **Header comment** following codebase style.

2. **Imports:**
   ```typescript
   import { createAdminClient } from '@/lib/supabase/admin'
   import type { DomainContext, DomainResult } from './types'
   ```

3. **CarrierConfig type:**
   ```typescript
   export interface CarrierConfig {
     id: string
     workspace_id: string
     carrier: string
     portal_username: string | null
     portal_password: string | null
     is_enabled: boolean
     created_at: string
     updated_at: string
   }
   ```

4. **getCarrierConfig function:**
   ```typescript
   export async function getCarrierConfig(
     ctx: DomainContext,
     carrier?: string
   ): Promise<DomainResult<CarrierConfig | null>>
   ```

   Implementation:
   - Default carrier to 'coordinadora'
   - Query: `.from('carrier_configs').select('*').eq('workspace_id', ctx.workspaceId).eq('carrier', carrier).single()`
   - If error code is PGRST116 (not found), return { success: true, data: null }
   - If other error, return { success: false, error: message }
   - If found, return { success: true, data: config }

5. **upsertCarrierConfig function:**
   ```typescript
   export interface UpsertCarrierConfigParams {
     carrier?: string
     portalUsername?: string | null
     portalPassword?: string | null
     isEnabled?: boolean
   }

   export async function upsertCarrierConfig(
     ctx: DomainContext,
     params: UpsertCarrierConfigParams
   ): Promise<DomainResult<CarrierConfig>>
   ```

   Implementation:
   - Default carrier to 'coordinadora'
   - Check existing: getCarrierConfig(ctx, carrier)
   - If not exists: INSERT with workspace_id, carrier, and provided params
   - If exists: UPDATE with provided params (only non-undefined fields)
   - Return the upserted row
   - Follow the exact pattern from `upsertClientActivationConfig` in client-activation.ts

6. **getCarrierCredentials function** (convenience for robot dispatch):
   ```typescript
   export interface CarrierCredentials {
     username: string
     password: string
   }

   export async function getCarrierCredentials(
     ctx: DomainContext,
     carrier?: string
   ): Promise<DomainResult<CarrierCredentials>>
   ```

   Implementation:
   - Call getCarrierConfig
   - If null or not enabled, return error: 'Carrier no configurado o deshabilitado'
   - If username or password is null, return error: 'Credenciales incompletas'
   - Return { username, password }

**Key patterns:**
- Use `createAdminClient()` with explicit workspace_id filter
- PGRST116 error code handling for "not found" (same as client-activation.ts)
- Return DomainResult throughout
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/domain/carrier-configs.ts` or check build succeeds.
Verify file imports from '@/lib/supabase/admin' and '@/lib/domain/types'.
Verify exports: getCarrierConfig, upsertCarrierConfig, getCarrierCredentials, CarrierConfig type.
Verify getCarrierConfig handles PGRST116 error code.
Verify upsertCarrierConfig follows the exact pattern from client-activation.ts.
  </verify>
  <done>
carrier-configs.ts exports getCarrierConfig (read), upsertCarrierConfig (create/update), getCarrierCredentials (convenience for robot dispatch). All functions follow DomainResult pattern with createAdminClient() and explicit workspace_id filtering. PGRST116 "not found" handled correctly. Follows client-activation.ts pattern exactly.
  </done>
</task>

</tasks>

<verification>
1. `src/lib/logistics/constants.ts` exists with zero project imports, exports normalizeText, DEPARTMENT_ABBREVIATIONS, mapDepartmentToAbbrev, PedidoInput
2. `src/lib/domain/carrier-coverage.ts` exports validateCity, validateCities, getCoverageStats
3. `src/lib/domain/carrier-configs.ts` exports getCarrierConfig, upsertCarrierConfig, getCarrierCredentials
4. All domain functions return DomainResult<T> and use createAdminClient()
5. validateCities uses batch query with Map (not N+1 queries)
6. mapDepartmentToAbbrev handles all 38+ department variants
7. TypeScript compiles without errors: `npx tsc --noEmit`
</verification>

<success_criteria>
- City validation works: given "Medellin" + "Antioquia", validateCity returns isValid: true with coordinadoraCity: "MEDELLIN (ANT)"
- Unknown city returns isValid: false
- Department variants resolve correctly (e.g., "Bogota D.C." -> C/MARCA, "Valle del Cauca" -> VALLE)
- Batch validation processes multiple cities in a single DB call
- Carrier config CRUD follows established domain patterns
- Credential retrieval validates config is enabled and complete before returning
</success_criteria>

<output>
After completion, create `.planning/phases/21-db-domain-foundation/21-03-SUMMARY.md`
</output>
