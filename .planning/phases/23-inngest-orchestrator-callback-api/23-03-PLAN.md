---
phase: 23-inngest-orchestrator-callback-api
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/app/api/webhooks/robot-callback/route.ts
  - src/lib/domain/robot-jobs.ts
  - robot-coordinadora/src/api/server.ts
  - robot-coordinadora/src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "When robot reports a successful order result, the callback API updates the job item, updates the order carrier+tracking via domain, and fires robot.coord.completed trigger"
    - "When robot reports a failed order result, the callback API updates the job item status and error fields only (no automation trigger)"
    - "When all items in a batch complete, the callback API emits robot/job.batch_completed to Inngest"
    - "Duplicate callback results for the same item are handled idempotently (skip if already in terminal state)"
    - "Callback authentication uses shared secret via x-callback-secret header with timing-safe comparison"
    - "Robot service forwards the callback secret header in its per-order callback requests"
  artifacts:
    - path: "src/app/api/webhooks/robot-callback/route.ts"
      provides: "POST handler for per-order callback results from robot"
      exports: ["POST"]
    - path: "src/lib/domain/robot-jobs.ts"
      provides: "Idempotency guard in updateJobItemResult + carrier update on success"
      contains: "item.status === 'success' || item.status === 'error'"
    - path: "robot-coordinadora/src/api/server.ts"
      provides: "reportResult forwards x-callback-secret header"
      contains: "X-Callback-Secret"
    - path: "robot-coordinadora/src/types/index.ts"
      provides: "callbackSecret optional field in BatchRequest"
      contains: "callbackSecret"
  key_links:
    - from: "src/app/api/webhooks/robot-callback/route.ts"
      to: "src/lib/domain/robot-jobs.ts"
      via: "updateJobItemResult domain call"
      pattern: "updateJobItemResult"
    - from: "src/app/api/webhooks/robot-callback/route.ts"
      to: "src/lib/domain/orders.ts"
      via: "updateOrder for carrier field (indirect via robot-jobs domain)"
      pattern: "updateOrder"
    - from: "src/app/api/webhooks/robot-callback/route.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "emitRobotCoordCompleted on success"
      pattern: "emitRobotCoordCompleted"
    - from: "src/app/api/webhooks/robot-callback/route.ts"
      to: "src/inngest/client.ts"
      via: "inngest.send robot/job.batch_completed when batch done"
      pattern: "robot/job\\.batch_completed"
    - from: "robot-coordinadora/src/api/server.ts"
      to: "src/app/api/webhooks/robot-callback/route.ts"
      via: "HTTP POST with x-callback-secret header"
      pattern: "X-Callback-Secret"
---

<objective>
Create the callback API route that receives per-order results from the robot service, routes updates through the domain layer, fires automation triggers on success, and signals batch completion to the orchestrator. Also patch the domain layer with an idempotency guard and patch the robot service to forward the callback secret header.

Purpose: This is the "return path" -- the robot sends results here, and MorfX translates them into CRM updates and automation triggers. Without this, robot results would be lost.
Output: Callback API route, domain idempotency guard, robot server patch.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-inngest-orchestrator-callback-api/23-RESEARCH.md
@.planning/phases/23-inngest-orchestrator-callback-api/23-01-SUMMARY.md

# Key reference files
@src/lib/domain/robot-jobs.ts
@src/lib/domain/orders.ts
@src/lib/automations/trigger-emitter.ts
@src/inngest/client.ts
@src/inngest/events.ts
@src/app/api/webhooks/shopify/route.ts
@robot-coordinadora/src/api/server.ts
@robot-coordinadora/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add idempotency guard to updateJobItemResult and update carrier on success</name>
  <files>src/lib/domain/robot-jobs.ts</files>
  <action>
Modify `updateJobItemResult` in `src/lib/domain/robot-jobs.ts`:

**1. Idempotency guard** -- After fetching the item and verifying workspace (around line 262), add a check BEFORE the update:

```typescript
// Idempotency guard: skip if item is already in a terminal state
if (item.status === 'success' || item.status === 'error') {
  console.log(`[robot-jobs] Item ${params.itemId} already in terminal state (${item.status}), skipping update`)
  return {
    success: true,
    data: { itemId: params.itemId, orderId: item.order_id },
  }
}
```

Insert this AFTER the workspace verification block (after `if (jobData.workspace_id !== ctx.workspaceId)`) and BEFORE the `// Update item with result` section.

Note: The existing `updateJobItemResult` already fetches the item. We need `item.status` in the select. Check the select query -- it currently selects `id, job_id, order_id, robot_jobs!inner(workspace_id)`. Add `status` to the select:

Change:
```typescript
.select('id, job_id, order_id, robot_jobs!inner(workspace_id)')
```
To:
```typescript
.select('id, job_id, order_id, status, robot_jobs!inner(workspace_id)')
```

**2. Update carrier on success** -- The existing code already calls `updateOrder` with `trackingNumber` on success (line 286-291). Add the `carrier` field to that call:

Change:
```typescript
if (params.status === 'success' && params.trackingNumber) {
  await updateOrder(ctx, {
    orderId: item.order_id,
    trackingNumber: params.trackingNumber,
  })
}
```
To:
```typescript
if (params.status === 'success' && params.trackingNumber) {
  await updateOrder(ctx, {
    orderId: item.order_id,
    trackingNumber: params.trackingNumber,
    carrier: 'COORDINADORA',
  })
}
```

Verify that `updateOrder` accepts a `carrier` param. Check the UpdateOrderParams type in `src/lib/domain/orders.ts`. If `carrier` is not already a param, this is handled through the generic field update. If it IS already a param, just pass it. If not, use the same field update pattern the domain already uses.

**IMPORTANT:** Do NOT change the job auto-completion logic (success_count + error_count >= total_items). This must stay as-is since the callback API uses it to detect batch completion.
  </action>
  <verify>Run `npx tsc --noEmit` -- no TypeScript errors. Read updateJobItemResult and verify: the item select includes 'status', the idempotency guard returns early if status is success/error, and carrier 'COORDINADORA' is passed to updateOrder on success.</verify>
  <done>updateJobItemResult has idempotency guard (skips items in terminal state), selects status in the item query, and passes carrier: 'COORDINADORA' to updateOrder on success.</done>
</task>

<task type="auto">
  <name>Task 2: Create callback API route</name>
  <files>src/app/api/webhooks/robot-callback/route.ts</files>
  <action>
Create `src/app/api/webhooks/robot-callback/route.ts` as a Next.js API route.

**Structure:**

```typescript
// ============================================================================
// Phase 23: Inngest Orchestrator + Callback API â€” Robot Callback Route
// Receives per-order results from robot-coordinadora service.
// Routes updates through domain layer, fires automation triggers,
// and signals batch completion to orchestrator via Inngest event.
//
// Auth: Shared secret via x-callback-secret header (timing-safe comparison)
// Pattern: Follows existing webhook patterns (Shopify, WhatsApp)
// ============================================================================

import { NextRequest, NextResponse } from 'next/server'
import crypto from 'crypto'
import { updateJobItemResult } from '@/lib/domain/robot-jobs'
import { emitRobotCoordCompleted } from '@/lib/automations/trigger-emitter'
import { inngest } from '@/inngest/client'
import { createAdminClient } from '@/lib/supabase/admin'
```

**POST handler:**

1. **Verify callback authentication:**
```typescript
function verifyCallbackSecret(received: string | null, expected: string): boolean {
  if (!received) return false
  try {
    return crypto.timingSafeEqual(
      Buffer.from(received),
      Buffer.from(expected)
    )
  } catch {
    return false
  }
}

export async function POST(request: NextRequest) {
  // 1. Auth check
  const secret = request.headers.get('x-callback-secret')
  const expectedSecret = process.env.ROBOT_CALLBACK_SECRET
  if (!expectedSecret || !verifyCallbackSecret(secret, expectedSecret)) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }
```

2. **Parse payload** -- Body is a `BatchItemResult` from robot:
```typescript
  const body = await request.json()
  const { itemId, status, trackingNumber, errorType, errorMessage } = body

  if (!itemId || !status) {
    return NextResponse.json({ error: 'Missing itemId or status' }, { status: 400 })
  }
```

3. **Look up item to get workspace context** -- Query robot_job_items -> robot_jobs to get workspace_id:
```typescript
  const supabase = createAdminClient()
  const { data: item, error: lookupError } = await supabase
    .from('robot_job_items')
    .select('id, job_id, order_id, robot_jobs!inner(workspace_id, total_items, success_count, error_count)')
    .eq('id', itemId)
    .single()

  if (lookupError || !item) {
    console.error(`[robot-callback] Item not found: ${itemId}`, lookupError?.message)
    return NextResponse.json({ error: 'Item not found' }, { status: 404 })
  }

  const jobData = item.robot_jobs as unknown as {
    workspace_id: string
    total_items: number
    success_count: number
    error_count: number
  }
  const workspaceId = jobData.workspace_id
```

4. **Call domain layer: updateJobItemResult** -- This handles idempotency guard, item update, order update, and counter aggregation:
```typescript
  const ctx = { workspaceId, source: 'robot-callback' }
  const result = await updateJobItemResult(ctx, {
    itemId,
    status,
    trackingNumber,
    errorType,
    errorMessage,
  })

  if (!result.success) {
    console.error(`[robot-callback] Domain update failed for item ${itemId}: ${result.error}`)
    return NextResponse.json({ error: result.error }, { status: 500 })
  }
```

5. **On success: fire automation trigger** -- Load order + contact for rich trigger context:
```typescript
  if (status === 'success' && trackingNumber) {
    try {
      // Enrich with order + contact data for trigger context
      const { data: order } = await supabase
        .from('orders')
        .select(`
          id, name, total_value, description,
          shipping_address, shipping_city, shipping_department,
          contacts:contact_id (id, name, phone, email)
        `)
        .eq('id', item.order_id)
        .eq('workspace_id', workspaceId)
        .single()

      if (order) {
        const contact = Array.isArray(order.contacts) ? order.contacts[0] : order.contacts
        await emitRobotCoordCompleted({
          workspaceId,
          orderId: order.id,
          orderName: order.name || order.description || undefined,
          trackingNumber,
          carrier: 'COORDINADORA',
          contactId: contact?.id ?? null,
          contactName: contact?.name ?? undefined,
          contactPhone: contact?.phone ?? undefined,
          contactEmail: contact?.email ?? undefined,
          orderValue: order.total_value ?? undefined,
          shippingCity: order.shipping_city ?? undefined,
          shippingAddress: order.shipping_address ?? undefined,
          shippingDepartment: order.shipping_department ?? undefined,
        })
      }
    } catch (err) {
      // Trigger emission failure should NOT fail the callback
      console.error(`[robot-callback] Trigger emission failed for item ${itemId}:`, err)
    }
  }
```

6. **Check if all items done -> emit batch_completed** -- Re-read the job counters AFTER the domain update (updateJobItemResult already incremented them):
```typescript
  // Re-read job counters after domain update
  const { data: updatedJob } = await supabase
    .from('robot_jobs')
    .select('success_count, error_count, total_items, status')
    .eq('id', item.job_id)
    .single()

  if (updatedJob) {
    const allDone = (updatedJob.success_count + updatedJob.error_count) >= updatedJob.total_items
    if (allDone) {
      try {
        // MUST await inngest.send in serverless (Vercel can terminate early)
        await (inngest.send as any)({
          name: 'robot/job.batch_completed',
          data: {
            jobId: item.job_id,
            workspaceId,
            successCount: updatedJob.success_count,
            errorCount: updatedJob.error_count,
          },
        })
        console.log(`[robot-callback] Batch completed: job ${item.job_id} (${updatedJob.success_count} success, ${updatedJob.error_count} error)`)
      } catch (err) {
        console.error(`[robot-callback] Failed to emit batch_completed:`, err)
      }
    }
  }

  return NextResponse.json({ received: true })
}
```

**CRITICAL PATTERNS:**
- ALWAYS `await` inngest.send (Vercel serverless termination risk)
- Use `(inngest.send as any)` for type assertion (project standard)
- Trigger emission errors are caught and logged, never thrown
- Return 200 even if trigger fails (the domain update succeeded)
  </action>
  <verify>Run `npx tsc --noEmit` -- no TypeScript errors. Read the route file and verify: auth uses crypto.timingSafeEqual, domain calls are awaited, inngest.send is awaited with type assertion, trigger is emitted on success only, batch_completed is emitted when all items done.</verify>
  <done>Callback API route exists at /api/webhooks/robot-callback with: timing-safe auth, domain-first updates, automation trigger on success, batch_completed Inngest event when all items done, proper error handling.</done>
</task>

<task type="auto">
  <name>Task 3: Patch robot service to forward callback secret</name>
  <files>
    robot-coordinadora/src/api/server.ts
    robot-coordinadora/src/types/index.ts
  </files>
  <action>
**1. robot-coordinadora/src/types/index.ts** -- Add optional `callbackSecret` field to `BatchRequest`:

```typescript
export interface BatchRequest {
  workspaceId: string
  credentials: Credentials
  callbackUrl: string
  /** Shared secret to include in callback headers for authentication */
  callbackSecret?: string
  jobId: string
  orders: OrderInput[]
}
```

**2. robot-coordinadora/src/api/server.ts** -- Modify `reportResult` function to accept and forward the callback secret:

Change the function signature:
```typescript
async function reportResult(
  callbackUrl: string,
  result: BatchItemResult,
  callbackSecret?: string
): Promise<void> {
```

Update the fetch call to include the header:
```typescript
const headers: Record<string, string> = { 'Content-Type': 'application/json' }
if (callbackSecret) {
  headers['X-Callback-Secret'] = callbackSecret
}

await fetch(callbackUrl, {
  method: 'POST',
  headers,
  body: JSON.stringify(result),
})
```

**3. Update all `reportResult` call sites** in server.ts to pass `callbackSecret`:

In the `processBatch` function, the `callbackUrl` parameter is already available. Add `callbackSecret` as a parameter:

```typescript
async function processBatch(
  workspaceId: string,
  credentials: { username: string; password: string },
  callbackUrl: string,
  callbackSecret: string | undefined,
  orders: OrderInput[],
): Promise<void> {
```

Update ALL calls to `reportResult` within `processBatch` to pass `callbackSecret` as the third argument. There are multiple call sites:
- Login failure (reports all orders as error)
- Per-order lock skip
- Successful order result
- Per-order catch error
- Fatal batch error (reports remaining orders)

Also update the pre-validation section in the POST handler that calls `reportResult` (the city validation rejection around line 152).

In the POST handler, extract `callbackSecret` from the request body:
```typescript
const { workspaceId, credentials, callbackUrl, callbackSecret, jobId, orders } = body as BatchRequest
```

Pass `callbackSecret` to `processBatch`:
```typescript
processBatch(workspaceId, credentials, callbackUrl, callbackSecret, validOrders).catch(err => {
  console.error('[Server] Unhandled batch processing error:', err)
})
```

And pass it to the pre-validation `reportResult` call:
```typescript
reportResult(callbackUrl, {
  itemId: order.itemId,
  status: 'error',
  errorType: 'validation',
  errorMessage: 'Ciudad vacia o no proporcionada',
}, callbackSecret).catch(() => {})
```
  </action>
  <verify>Run `cd robot-coordinadora && npx tsc --noEmit` -- no TypeScript errors. Grep for 'X-Callback-Secret' in server.ts -- header is added to reportResult. Grep for 'callbackSecret' in server.ts -- parameter is passed through all call sites. Grep for 'callbackSecret' in types/index.ts -- field exists in BatchRequest.</verify>
  <done>Robot service's reportResult function includes X-Callback-Secret header when callbackSecret is provided. BatchRequest type has optional callbackSecret field. All reportResult call sites pass the secret through.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in both the main project and robot-coordinadora
2. `grep -r 'idempotency' src/lib/domain/robot-jobs.ts` shows the guard comment/logic
3. `grep -r 'COORDINADORA' src/lib/domain/robot-jobs.ts` shows carrier update in updateOrder call
4. `grep -r 'x-callback-secret' src/app/api/webhooks/robot-callback/route.ts` shows auth check
5. `grep -r 'batch_completed' src/app/api/webhooks/robot-callback/route.ts` shows Inngest event emission
6. `grep -r 'emitRobotCoordCompleted' src/app/api/webhooks/robot-callback/route.ts` shows trigger emission
7. `grep -r 'X-Callback-Secret' robot-coordinadora/src/api/server.ts` shows header forwarding
8. `grep -r 'callbackSecret' robot-coordinadora/src/types/index.ts` shows field in BatchRequest
</verification>

<success_criteria>
- Callback API authenticates requests with timing-safe secret comparison
- Per-order results are processed through the domain layer (updateJobItemResult)
- Successful orders get carrier set to COORDINADORA and trigger robot.coord.completed
- Failed orders only update job item status (no trigger)
- Duplicate callbacks are handled idempotently (domain guard skips terminal items)
- Batch completion signal (robot/job.batch_completed) is emitted when all items finish
- Robot service forwards callback secret header in all callback requests
- TypeScript compiles without errors in both projects
</success_criteria>

<output>
After completion, create `.planning/phases/23-inngest-orchestrator-callback-api/23-03-SUMMARY.md`
</output>
