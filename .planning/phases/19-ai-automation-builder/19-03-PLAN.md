---
phase: 19-ai-automation-builder
plan: 03
type: execute
wave: 2
depends_on: ["19-01", "19-02"]
files_modified:
  - src/app/api/builder/chat/route.ts
  - src/lib/builder/session-store.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/builder/chat returns a streaming response with AI SDK data protocol"
    - "Route extracts workspace_id from cookies and passes to all tools"
    - "Route loads and saves chat messages to builder_sessions table"
    - "Route uses maxSteps: 5 to limit multi-step tool calls"
  artifacts:
    - path: "src/app/api/builder/chat/route.ts"
      provides: "AI SDK streaming endpoint with tools and workspace context"
      exports: ["POST"]
      min_lines: 60
    - path: "src/lib/builder/session-store.ts"
      provides: "CRUD functions for builder_sessions table"
      exports: ["createSession", "updateSession", "getSession", "getSessions", "deleteSession"]
      min_lines: 80
  key_links:
    - from: "src/app/api/builder/chat/route.ts"
      to: "src/lib/builder/tools.ts"
      via: "createBuilderTools(ctx)"
      pattern: "createBuilderTools"
    - from: "src/app/api/builder/chat/route.ts"
      to: "src/lib/builder/system-prompt.ts"
      via: "buildSystemPrompt(workspaceId)"
      pattern: "buildSystemPrompt"
    - from: "src/app/api/builder/chat/route.ts"
      to: "src/lib/builder/session-store.ts"
      via: "session persistence on each turn"
      pattern: "updateSession|createSession"
---

<objective>
Create the AI SDK streaming API route for the builder chat and the session persistence layer. The route handles POST requests with messages, streams responses via Claude, and saves conversation state to the database.

Purpose: Wire the agent brain (system prompt + tools) to a streaming endpoint the frontend can consume via useChat.
Output: Working API route at /api/builder/chat, session store for persistence.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-ai-automation-builder/19-01-PLAN.md
@.planning/phases/19-ai-automation-builder/19-02-PLAN.md
@src/lib/supabase/server.ts
@src/lib/supabase/admin.ts
@src/lib/builder/types.ts
@src/lib/builder/tools.ts
@src/lib/builder/system-prompt.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session store for builder_sessions persistence</name>
  <files>src/lib/builder/session-store.ts</files>
  <action>
    Create `src/lib/builder/session-store.ts` that exports CRUD functions for the `builder_sessions` table.

    Use `createAdminClient()` from `@/lib/supabase/admin` to bypass RLS (the API route validates auth separately).

    Functions:

    1. `createSession(workspaceId: string, userId: string, title?: string)`: Insert new session with empty messages array. Return the created session (id, created_at, etc.).

    2. `getSession(sessionId: string, workspaceId: string)`: Get a single session by ID, filtered by workspace_id for security. Return null if not found.

    3. `getSessions(workspaceId: string, userId: string, limit?: number)`: Get sessions for a user in a workspace, ordered by updated_at DESC. Default limit 20. Return lightweight list: id, title, created_at, updated_at, automations_created length.

    4. `updateSession(sessionId: string, workspaceId: string, data: { messages?: unknown[], title?: string, automations_created?: string[] })`: Update session fields. Only update fields that are provided (not undefined). The workspace_id filter ensures no cross-workspace updates.

    5. `deleteSession(sessionId: string, workspaceId: string)`: Delete a session. Only the workspace filter is needed (RLS + admin client).

    6. `addAutomationToSession(sessionId: string, workspaceId: string, automationId: string)`: Appends an automation ID to the automations_created array. Use Supabase `array_append` or read-modify-write pattern.

    All functions handle errors gracefully, logging to console and returning null/false on failure.

    Type the return values using BuilderSession from `@/lib/builder/types.ts`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports 6 functions
    - All queries use createAdminClient with workspace_id filter
  </verify>
  <done>
    - 6 session store functions exported
    - All use createAdminClient for DB access
    - All filter by workspace_id for isolation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create the streaming API route</name>
  <files>src/app/api/builder/chat/route.ts</files>
  <action>
    Create `src/app/api/builder/chat/route.ts` with a POST handler.

    The route:

    1. **Auth + Workspace extraction**:
       ```typescript
       import { createClient } from '@/lib/supabase/server'
       import { cookies } from 'next/headers'

       const supabase = await createClient()
       const { data: { user } } = await supabase.auth.getUser()
       if (!user) return new Response('Unauthorized', { status: 401 })

       const cookieStore = await cookies()
       const workspaceId = cookieStore.get('morfx_workspace')?.value
       if (!workspaceId) return new Response('No workspace selected', { status: 400 })
       ```

       Verify workspace membership:
       ```typescript
       const { data: membership } = await supabase
         .from('workspace_members')
         .select('id')
         .eq('workspace_id', workspaceId)
         .eq('user_id', user.id)
         .single()
       if (!membership) return new Response('Forbidden', { status: 403 })
       ```

    2. **Parse request body**: Extract `messages` and optional `sessionId` from the JSON body.

    3. **Session management**:
       - If `sessionId` provided, load session from DB to verify it exists and belongs to this workspace
       - If no `sessionId`, create a new session. Auto-generate title from the first user message (first 60 chars + ellipsis if longer)
       - Return the sessionId in response headers: `X-Session-Id: {sessionId}`

    4. **Stream with AI SDK**:
       ```typescript
       import { streamText } from 'ai'
       import { anthropic } from '@ai-sdk/anthropic'
       import { buildSystemPrompt } from '@/lib/builder/system-prompt'
       import { createBuilderTools } from '@/lib/builder/tools'

       const ctx = { workspaceId, userId: user.id }
       const tools = createBuilderTools(ctx)
       const systemPrompt = buildSystemPrompt(workspaceId)

       const result = streamText({
         model: anthropic('claude-sonnet-4-5-20250514'),
         system: systemPrompt,
         messages,
         tools,
         maxSteps: 5,
         onFinish: async ({ response }) => {
           // Save messages to session after stream completes
           // response.messages contains the full conversation
           // Merge with existing session messages and save
           await updateSession(sessionId, workspaceId, {
             messages: [...messages, ...response.messages],
           })
         },
       })

       const response = result.toDataStreamResponse()
       // Add session ID header
       response.headers.set('X-Session-Id', sessionId)
       return response
       ```

    5. **Error handling**: Wrap in try/catch. On error, return JSON `{error: string}` with 500 status. Log the error.

    IMPORTANT: Use `ANTHROPIC_API_KEY` env var (AI SDK reads it automatically). Do NOT hardcode any API keys.

    NOTE: The `onFinish` callback runs after the stream completes. This is the right place to persist messages since the full response is available.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports POST function
    - Route reads workspace from cookies
    - Route uses streamText with anthropic provider
    - Route has maxSteps: 5
    - Route saves messages via session store
  </verify>
  <done>
    - API route at /api/builder/chat handles POST with streaming
    - Auth + workspace extracted from cookies and verified
    - Session created/updated on each request
    - Session ID returned via X-Session-Id header
    - Uses Claude Sonnet via AI SDK anthropic provider
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `/api/builder/chat` route file exists with POST export
- Session store has CRUD functions
- Route connects system prompt + tools + streaming
</verification>

<success_criteria>
Streaming API route processes chat messages through Claude with all builder tools available. Session persistence layer stores and retrieves chat history from builder_sessions table. Workspace isolation enforced at every layer.
</success_criteria>

<output>
After completion, create `.planning/phases/19-ai-automation-builder/19-03-SUMMARY.md`
</output>
