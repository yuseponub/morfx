---
phase: 15.7-ingest-timer-pluggable
plan: 02
type: execute
wave: 2
depends_on: ["15.7-01"]
files_modified:
  - src/app/(dashboard)/sandbox/components/sandbox-layout.tsx
  - src/app/(dashboard)/sandbox/components/debug-panel/debug-tabs.tsx
  - src/app/(dashboard)/sandbox/components/debug-panel/panel-container.tsx
  - src/app/(dashboard)/sandbox/components/debug-panel/ingest-tab.tsx
autonomous: true

must_haves:
  truths:
    - "Timer starts counting when first data arrives in sandbox chat"
    - "Countdown shows remaining time and current level name in Ingest tab"
    - "Timer expiration injects messages into chat as normal agent messages"
    - "5 independent sliders control each timer level's duration"
    - "Presets (Real/Rapido/Instantaneo) set all 5 sliders simultaneously"
    - "Timer toggle enables/disables timer simulation in Ingest tab"
    - "New data reevaluates timer level; questions do not interrupt timer"
    - "Level 2 silent transition chains immediately to level 3"
    - "Session reset stops the timer"
    - "Pause/Resume button works on active timer"
  artifacts:
    - path: "src/app/(dashboard)/sandbox/components/sandbox-layout.tsx"
      provides: "Timer state management, useIngestTimer hook integration, timer action handler"
      contains: "IngestTimerSimulator"
    - path: "src/app/(dashboard)/sandbox/components/debug-panel/ingest-tab.tsx"
      provides: "5 slider controls, timer toggle, countdown display, pause button"
      contains: "TimerDisplay"
    - path: "src/app/(dashboard)/sandbox/components/debug-panel/debug-tabs.tsx"
      provides: "Timer props passed through to PanelContainer"
      contains: "timerState"
    - path: "src/app/(dashboard)/sandbox/components/debug-panel/panel-container.tsx"
      provides: "Timer props passed through to IngestTab"
      contains: "timerState"
  key_links:
    - from: "src/app/(dashboard)/sandbox/components/sandbox-layout.tsx"
      to: "src/lib/sandbox/ingest-timer.ts"
      via: "IngestTimerSimulator instance in useRef"
      pattern: "IngestTimerSimulator"
    - from: "src/app/(dashboard)/sandbox/components/sandbox-layout.tsx"
      to: "src/app/(dashboard)/sandbox/components/debug-panel/debug-tabs.tsx"
      via: "timerState, timerConfig, onTimerConfigChange props"
      pattern: "timerState"
    - from: "src/app/(dashboard)/sandbox/components/debug-panel/panel-container.tsx"
      to: "src/app/(dashboard)/sandbox/components/debug-panel/ingest-tab.tsx"
      via: "timerState, timerConfig, timer callbacks as props"
      pattern: "timerState"
    - from: "src/app/(dashboard)/sandbox/components/sandbox-layout.tsx"
      to: "sandbox chat messages"
      via: "handleTimerExpire callback injects SandboxMessage"
      pattern: "setMessages.*timer"
---

<objective>
Wire the IngestTimerSimulator into the sandbox UI: manage timer state in sandbox-layout, handle timer actions (message injection, mode transitions, order creation), and build the 5-level timer UI with sliders, toggle, countdown, and pause in the Ingest tab.

Purpose: This plan connects the timer engine (Plan 01) to the user-facing UI, making the timer fully functional and configurable. Users will see countdown, control timer presets/durations, and see timer-triggered messages in the chat.

Output: Fully functional timer simulation in sandbox with 5 levels, 3 presets, 5 independent sliders, countdown display, and timer-triggered chat messages.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15.7-ingest-timer-pluggable/15.7-CONTEXT.md
@.planning/phases/15.7-ingest-timer-pluggable/15.7-RESEARCH.md
@.planning/phases/15.7-ingest-timer-pluggable/15.7-01-SUMMARY.md
@src/lib/sandbox/types.ts
@src/lib/sandbox/ingest-timer.ts
@src/lib/sandbox/sandbox-engine.ts
@src/app/(dashboard)/sandbox/components/sandbox-layout.tsx
@src/app/(dashboard)/sandbox/components/debug-panel/debug-tabs.tsx
@src/app/(dashboard)/sandbox/components/debug-panel/panel-container.tsx
@src/app/(dashboard)/sandbox/components/debug-panel/ingest-tab.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate timer into sandbox-layout with state management and action handling</name>
  <files>src/app/(dashboard)/sandbox/components/sandbox-layout.tsx</files>
  <action>
Modify `sandbox-layout.tsx` to manage the IngestTimerSimulator lifecycle and handle timer actions.

**1. Add imports:**
```typescript
import { IngestTimerSimulator, TIMER_DEFAULTS, TIMER_LEVELS, TIMER_PRESETS } from '@/lib/sandbox/ingest-timer'
import type { TimerState, TimerConfig, TimerAction, TimerEvalContext, TimerPreset } from '@/lib/sandbox/types'
```

**2. Add timer state:**
```typescript
const [timerState, setTimerState] = useState<TimerState>({
  active: false,
  level: null,
  levelName: '',
  remainingMs: 0,
  paused: false,
})
const [timerEnabled, setTimerEnabled] = useState(false)
const [timerConfig, setTimerConfig] = useState<TimerConfig>(TIMER_DEFAULTS)
const simulatorRef = useRef<IngestTimerSimulator | null>(null)
```

**3. Initialize simulator on mount:**
```typescript
useEffect(() => {
  const simulator = new IngestTimerSimulator(
    // onTick
    (remainingMs, level) => {
      const levelConfig = TIMER_LEVELS.find(l => l.id === level)
      setTimerState({
        active: true,
        level,
        levelName: levelConfig?.name ?? '',
        remainingMs,
        paused: false,
      })
    },
    // onExpire
    (level, action) => {
      handleTimerExpire(level, action)
    }
  )
  simulatorRef.current = simulator
  return () => simulator.destroy()
}, []) // handleTimerExpire will be stable via useCallback
```

Note: The onExpire callback references `handleTimerExpire` which must be defined before this effect. Use a ref to hold the callback to avoid stale closures:
```typescript
const handleTimerExpireRef = useRef<(level: number, action: TimerAction) => void>(() => {})
```
And update the ref whenever handleTimerExpire changes. The simulator constructor uses the ref.

**4. handleTimerExpire callback:**
```typescript
const handleTimerExpire = useCallback((level: number, action: TimerAction) => {
  // 1. Inject message into chat (if action has one)
  if (action.message) {
    const timerMessage: SandboxMessage = {
      id: `msg-${Date.now()}-timer`,
      role: 'assistant',
      content: action.message,
      timestamp: new Date().toISOString(),
    }
    setMessages(prev => [...prev, timerMessage])
  }

  // 2. Handle mode transition (level 2: silent transition to ofrecer_promos)
  if (action.type === 'transition_mode' && action.targetMode) {
    setState(prev => ({ ...prev, currentMode: action.targetMode! }))

    // Level 2 chains to level 3: after transitioning to ofrecer_promos,
    // immediately start level 3 timer
    if (level === 2) {
      // Build eval context for re-evaluation with new mode
      setTimeout(() => {
        const ctx: TimerEvalContext = {
          // Read current state at the time of execution
          fieldsCollected: [], // Will be filled from state
          totalFields: 0,
          currentMode: action.targetMode!,
          packSeleccionado: null,
          promosOffered: true,
        }
        // Use a function to read latest state and trigger level 3
        startTimerForLevel(3)
      }, 100) // Small delay to allow state update
    }
  }

  // 3. Handle order creation (levels 3, 4)
  if (action.type === 'create_order') {
    // Route through CRM orchestrator if available (same pattern as sandbox-engine)
    const orderManagerMode = crmAgents.find(a => a.agentId === 'order-manager' && a.enabled)
    if (orderManagerMode) {
      // Fire CRM order creation asynchronously (non-blocking for timer)
      fetch('/api/sandbox/process', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: '__timer_order_creation__',
          state: { ...state, currentMode: 'confirmado' },
          history: messages.map(m => ({ role: m.role, content: m.content })),
          turnNumber: debugTurns.length + 1,
          crmAgents: [{ agentId: 'order-manager', mode: orderManagerMode.mode }],
          workspaceId: workspace?.id,
        }),
      }).catch(err => console.error('[Timer] Order creation failed:', err))
    } else {
      const placeholderMsg: SandboxMessage = {
        id: `msg-${Date.now()}-timer-order`,
        role: 'assistant',
        content: `[SANDBOX: Timer L${level} - Order would be created here]`,
        timestamp: new Date().toISOString(),
      }
      setMessages(prev => [...prev, placeholderMsg])
    }
  }

  // 4. Reset timer state display (timer has expired)
  setTimerState({
    active: false,
    level: null,
    levelName: '',
    remainingMs: 0,
    paused: false,
  })
}, [crmAgents, state, messages, debugTurns, workspace])
```

Note: The order creation via fetch is a simplified approach. If the CRM orchestrator pattern from sandbox-engine is complex, just inject a placeholder message. The main goal is message injection and mode transitions.

**5. Helper: startTimerForLevel:**
```typescript
const startTimerForLevel = useCallback((level: number) => {
  const durationS = timerConfig.levels[level] ?? TIMER_DEFAULTS.levels[level]
  const durationMs = durationS * 1000
  simulatorRef.current?.start(level, durationMs)
}, [timerConfig])
```

**6. Process timer signals from SandboxEngine result:**
In `handleSendMessage`, after receiving the result from the API:
```typescript
// After setState(result.newState) and setDebugTurns(...):
// Handle timer signals from engine
if (timerEnabled && result.timerSignal) {
  const signal = result.timerSignal
  if (signal.type === 'start') {
    // Evaluate which level to start based on new state
    const ctx: TimerEvalContext = {
      fieldsCollected: Object.keys(result.newState.datosCapturados).filter(
        k => result.newState.datosCapturados[k] && result.newState.datosCapturados[k] !== 'N/A'
      ),
      totalFields: Object.keys(result.newState.datosCapturados).filter(
        k => result.newState.datosCapturados[k] && result.newState.datosCapturados[k] !== 'N/A'
      ).length,
      currentMode: result.newState.currentMode,
      packSeleccionado: typeof result.newState.packSeleccionado === 'string'
        ? result.newState.packSeleccionado
        : result.newState.packSeleccionado?.pack ?? null,
      promosOffered: result.newState.intentsVistos.includes('ofrecer_promos'),
    }
    const level = simulatorRef.current?.evaluateLevel(ctx)
    if (level !== null && level !== undefined) {
      startTimerForLevel(level)
    }
  } else if (signal.type === 'reevaluate') {
    // Build context and reevaluate
    const ctx: TimerEvalContext = {
      fieldsCollected: Object.keys(result.newState.datosCapturados).filter(
        k => result.newState.datosCapturados[k] && result.newState.datosCapturados[k] !== 'N/A'
      ),
      totalFields: Object.keys(result.newState.datosCapturados).filter(
        k => result.newState.datosCapturados[k] && result.newState.datosCapturados[k] !== 'N/A'
      ).length,
      currentMode: result.newState.currentMode,
      packSeleccionado: typeof result.newState.packSeleccionado === 'string'
        ? result.newState.packSeleccionado
        : result.newState.packSeleccionado?.pack ?? null,
      promosOffered: result.newState.intentsVistos.includes('ofrecer_promos'),
    }
    simulatorRef.current?.reevaluateLevel(ctx, timerConfig)
  } else if (signal.type === 'cancel') {
    simulatorRef.current?.stop()
    setTimerState({ active: false, level: null, levelName: '', remainingMs: 0, paused: false })
  }
}
```

**7. Timer config change handler:**
```typescript
const handleTimerConfigChange = useCallback((newConfig: TimerConfig) => {
  setTimerConfig(newConfig)
  // If timer is active, restart with new duration for current level (CONTEXT.md: preset change restarts timer)
  if (timerState.active && timerState.level !== null) {
    const newDurationS = newConfig.levels[timerState.level] ?? TIMER_DEFAULTS.levels[timerState.level]
    simulatorRef.current?.start(timerState.level, newDurationS * 1000)
  }
}, [timerState])
```

**8. Timer toggle handler:**
```typescript
const handleTimerToggle = useCallback((enabled: boolean) => {
  setTimerEnabled(enabled)
  if (!enabled) {
    simulatorRef.current?.stop()
    setTimerState({ active: false, level: null, levelName: '', remainingMs: 0, paused: false })
  }
}, [])
```

**9. Timer pause/resume handler:**
```typescript
const handleTimerPause = useCallback(() => {
  if (timerState.paused) {
    simulatorRef.current?.resume()
  } else {
    simulatorRef.current?.pause()
  }
  setTimerState(prev => ({ ...prev, paused: !prev.paused }))
}, [timerState.paused])
```

**10. Update handleReset to stop timer:**
```typescript
const handleReset = useCallback(() => {
  setMessages([])
  setState(INITIAL_STATE)
  setDebugTurns([])
  setTotalTokens(0)
  setIsTyping(false)
  // Stop timer on reset
  simulatorRef.current?.stop()
  setTimerState({ active: false, level: null, levelName: '', remainingMs: 0, paused: false })
  setTimerEnabled(false)
}, [])
```

**11. Pass timer props to DebugTabs:**
```tsx
<DebugTabs
  debugTurns={debugTurns}
  state={state}
  onStateEdit={handleStateEdit}
  totalTokens={totalTokens}
  agentName={AGENT_NAMES[agentId] ?? agentId}
  responseSpeed={responseSpeed}
  onResponseSpeedChange={setResponseSpeed}
  // Timer props (Phase 15.7)
  timerState={timerState}
  timerEnabled={timerEnabled}
  timerConfig={timerConfig}
  onTimerToggle={handleTimerToggle}
  onTimerConfigChange={handleTimerConfigChange}
  onTimerPause={handleTimerPause}
/>
```

**Stale closure prevention for handleTimerExpire:**
Use a ref pattern since the simulator is created once but the callback depends on changing state:
```typescript
const timerExpireRef = useRef(handleTimerExpire)
useEffect(() => { timerExpireRef.current = handleTimerExpire }, [handleTimerExpire])
```
And in the simulator constructor, use: `(level, action) => timerExpireRef.current(level, action)`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Verify that `handleReset` includes `simulatorRef.current?.stop()`. Verify that `handleSendMessage` processes `result.timerSignal`.
  </verify>
  <done>
sandbox-layout.tsx manages IngestTimerSimulator lifecycle. Timer signals from SandboxEngine are processed (start/reevaluate/cancel). Timer expiration injects messages into chat. Level 2 chains to level 3. Session reset stops timer. Timer config changes restart active timer. All timer props passed to DebugTabs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire timer props through debug-tabs and panel-container, and rebuild IngestTab with 5-level UI</name>
  <files>
    src/app/(dashboard)/sandbox/components/debug-panel/debug-tabs.tsx
    src/app/(dashboard)/sandbox/components/debug-panel/panel-container.tsx
    src/app/(dashboard)/sandbox/components/debug-panel/ingest-tab.tsx
  </files>
  <action>
**File 1: debug-tabs.tsx**

Add timer props to DebugTabsProps interface:
```typescript
interface DebugTabsProps {
  // ... existing props ...
  // Timer props (Phase 15.7)
  timerState: TimerState
  timerEnabled: boolean
  timerConfig: TimerConfig
  onTimerToggle: (enabled: boolean) => void
  onTimerConfigChange: (config: TimerConfig) => void
  onTimerPause: () => void
}
```

Import the timer types from `@/lib/sandbox/types`.

Pass timer props through to PanelContainer:
```tsx
<PanelContainer
  visiblePanels={visiblePanels}
  debugTurns={debugTurns}
  state={state}
  onStateEdit={onStateEdit}
  totalTokens={totalTokens}
  agentName={agentName}
  responseSpeed={responseSpeed}
  onResponseSpeedChange={onResponseSpeedChange}
  timerState={timerState}
  timerEnabled={timerEnabled}
  timerConfig={timerConfig}
  onTimerToggle={onTimerToggle}
  onTimerConfigChange={onTimerConfigChange}
  onTimerPause={onTimerPause}
/>
```

**File 2: panel-container.tsx**

Add timer props to PanelContainerProps:
```typescript
interface PanelContainerProps {
  // ... existing props ...
  timerState: TimerState
  timerEnabled: boolean
  timerConfig: TimerConfig
  onTimerToggle: (enabled: boolean) => void
  onTimerConfigChange: (config: TimerConfig) => void
  onTimerPause: () => void
}
```

Import timer types from `@/lib/sandbox/types`.

In PanelContent switch, update the 'ingest' case to pass timer props:
```typescript
case 'ingest':
  return (
    <IngestTab
      state={props.state}
      timerState={props.timerState}
      timerEnabled={props.timerEnabled}
      timerConfig={props.timerConfig}
      onTimerToggle={props.onTimerToggle}
      onTimerConfigChange={props.onTimerConfigChange}
      onTimerPause={props.onTimerPause}
    />
  )
```

**File 3: ingest-tab.tsx â€” Major rewrite of TimerControls and TimerCountdown**

Replace the existing 2-slider TimerControls with a 5-level timer configuration UI.

Import new types and constants:
```typescript
import { TIMER_PRESETS, TIMER_LEVELS, TIMER_DEFAULTS } from '@/lib/sandbox/ingest-timer'
import type { TimerState, TimerConfig, TimerPreset } from '@/lib/sandbox/types'
```

**Update IngestTabProps:**
```typescript
interface IngestTabProps {
  state: SandboxState
  timerState: TimerState
  timerEnabled: boolean
  timerConfig: TimerConfig
  onTimerToggle: (enabled: boolean) => void
  onTimerConfigChange: (config: TimerConfig) => void
  onTimerPause: () => void
}
```

**Remove old `onTimerChange` prop** (was never wired).

**Replace TimerCountdown component with TimerDisplay:**
```typescript
function TimerDisplay({ timerState, onPause }: { timerState: TimerState; onPause: () => void }) {
  if (!timerState.active || timerState.level === null) {
    return <span className="text-xs text-muted-foreground">-</span>
  }

  const totalSeconds = Math.ceil(timerState.remainingMs / 1000)
  const minutes = Math.floor(totalSeconds / 60)
  const seconds = totalSeconds % 60
  const display = `${minutes}:${seconds.toString().padStart(2, '0')}`

  return (
    <div className="flex items-center gap-1.5">
      <Timer className="h-3.5 w-3.5 text-muted-foreground" />
      <span className="text-sm font-medium font-mono">{display}</span>
      <span className="text-xs text-muted-foreground">
        (L{timerState.level}: {timerState.levelName})
      </span>
      <button
        onClick={onPause}
        className="p-0.5 rounded hover:bg-muted"
        title={timerState.paused ? 'Reanudar' : 'Pausar'}
      >
        {timerState.paused ? <Play className="h-3 w-3" /> : <Pause className="h-3 w-3" />}
      </button>
    </div>
  )
}
```

Import `Play, Pause` from lucide-react (add to existing import).

**Replace TimerControls with TimerControlsV2:**
This component has:
1. A toggle (Switch) to enable/disable timer simulation
2. Preset buttons (Real / Rapido / Instantaneo) using ToggleGroup
3. 5 independent sliders, one per timer level

```typescript
function TimerControlsV2({
  timerEnabled,
  timerConfig,
  onTimerToggle,
  onTimerConfigChange,
}: {
  timerEnabled: boolean
  timerConfig: TimerConfig
  onTimerToggle: (enabled: boolean) => void
  onTimerConfigChange: (config: TimerConfig) => void
}) {
  // Detect current preset from config values
  const detectPreset = (config: TimerConfig): TimerPreset | null => {
    for (const [key, presetConfig] of Object.entries(TIMER_PRESETS)) {
      const matches = Object.keys(presetConfig.levels).every(
        k => presetConfig.levels[Number(k)] === config.levels[Number(k)]
      )
      if (matches) return key as TimerPreset
    }
    return null
  }

  const currentPreset = detectPreset(timerConfig)

  const handlePresetChange = (value: string) => {
    if (!value) return
    const preset = value as TimerPreset
    onTimerConfigChange(TIMER_PRESETS[preset])
  }

  const handleLevelChange = (levelId: number, seconds: number) => {
    onTimerConfigChange({
      levels: { ...timerConfig.levels, [levelId]: seconds },
    })
  }

  // Slider config per level (min, max, step)
  const SLIDER_CONFIG: Record<number, { min: number; max: number; step: number }> = {
    0: { min: 0, max: 900, step: 10 },
    1: { min: 0, max: 600, step: 10 },
    2: { min: 0, max: 300, step: 5 },
    3: { min: 0, max: 900, step: 10 },
    4: { min: 0, max: 900, step: 10 },
  }

  return (
    <div className="border rounded-lg p-3 space-y-3">
      {/* Header with toggle */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Zap className="h-4 w-4 text-primary" />
          <span className="text-sm font-medium">Timer Simulacion</span>
        </div>
        {/* Use a simple checkbox-style toggle since Switch may not be available */}
        <button
          onClick={() => onTimerToggle(!timerEnabled)}
          className={cn(
            'relative inline-flex h-5 w-9 items-center rounded-full transition-colors',
            timerEnabled ? 'bg-primary' : 'bg-muted-foreground/30'
          )}
        >
          <span className={cn(
            'inline-block h-3.5 w-3.5 transform rounded-full bg-white transition-transform',
            timerEnabled ? 'translate-x-4.5' : 'translate-x-0.5'
          )} />
        </button>
      </div>

      {timerEnabled && (
        <>
          {/* Preset buttons */}
          <div>
            <div className="text-xs text-muted-foreground mb-1.5">Preset</div>
            <ToggleGroup
              type="single"
              value={currentPreset ?? ''}
              onValueChange={handlePresetChange}
              size="sm"
              className="gap-1"
            >
              {Object.entries(TIMER_PRESETS).map(([key, config]) => (
                <ToggleGroupItem
                  key={key}
                  value={key}
                  className="text-xs px-3"
                >
                  <span className="capitalize">{key}</span>
                </ToggleGroupItem>
              ))}
            </ToggleGroup>
          </div>

          {/* 5 sliders */}
          <div className="space-y-2.5">
            {TIMER_LEVELS.map((level) => {
              const sliderConf = SLIDER_CONFIG[level.id]
              const currentValue = timerConfig.levels[level.id] ?? level.defaultDurationS
              return (
                <div key={level.id} className="space-y-1">
                  <div className="flex items-center justify-between">
                    <span className="text-xs text-muted-foreground">
                      L{level.id}: {level.name}
                    </span>
                    <span className="text-xs font-mono font-medium">
                      {formatSeconds(currentValue)}
                    </span>
                  </div>
                  <Slider
                    value={[currentValue]}
                    onValueChange={(val) => handleLevelChange(level.id, val[0])}
                    min={sliderConf.min}
                    max={sliderConf.max}
                    step={sliderConf.step}
                  />
                </div>
              )
            })}
          </div>
        </>
      )}
    </div>
  )
}
```

Note: If the project has a Switch component from shadcn/ui, prefer using that. Otherwise, the inline toggle button above works. Check if `@/components/ui/switch` exists.

**Update StatusGrid Timer cell:**
Replace the `<TimerCountdown ingestStatus={state.ingestStatus} />` with:
```tsx
<TimerDisplay timerState={timerState} onPause={onTimerPause} />
```
This requires passing `timerState` and `onTimerPause` to StatusGrid.

**Update IngestTab to use new props:**
```typescript
export function IngestTab({
  state,
  timerState,
  timerEnabled,
  timerConfig,
  onTimerToggle,
  onTimerConfigChange,
  onTimerPause,
}: IngestTabProps) {
  const timeline = state.ingestStatus?.timeline ?? []

  return (
    <div className="space-y-4">
      <StatusGrid state={state} timerState={timerState} onTimerPause={onTimerPause} />
      <Timeline entries={timeline} />
      <TimerControlsV2
        timerEnabled={timerEnabled}
        timerConfig={timerConfig}
        onTimerToggle={onTimerToggle}
        onTimerConfigChange={onTimerConfigChange}
      />
    </div>
  )
}
```

**Remove old TimerCountdown and TimerControls components** (replaced by TimerDisplay and TimerControlsV2).

**Remove old TIMER_PRESETS constant** from this file (now imported from ingest-timer.ts).

**Remove old TimerPreset and TimerPresetConfig types** (now centralized in types.ts and ingest-timer.ts).

Keep `formatSeconds`, `getClassificationColor`, `getClassificationBadgeVariant`, `StatusGrid`, `Timeline` components as-is (with StatusGrid updated to accept timer props).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors across all 4 modified files. Verify IngestTab renders 5 sliders (one per TIMER_LEVELS entry). Verify TimerDisplay shows countdown format "M:SS (LN: name)".
  </verify>
  <done>
Timer props flow from sandbox-layout through debug-tabs and panel-container to IngestTab. IngestTab has: (1) timer toggle to enable/disable simulation, (2) 3 preset buttons controlling all 5 levels, (3) 5 independent sliders for fine-tuning each level, (4) countdown display showing remaining time + level name, (5) pause/resume button. Old 2-slider TimerControls and cosmetic TimerCountdown replaced.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Start sandbox, enable timer toggle in Ingest tab
3. Send customer data message (e.g., "Hola, soy Jose de Bogota")
4. Timer countdown appears in Status grid showing remaining time and level
5. After timer expires, message appears in chat from "agent"
6. Change preset to "Instantaneo" - timer restarts with ~2 second duration
7. Each of the 5 sliders adjusts its level independently
8. Pause button pauses countdown, resume continues
9. New session resets timer and toggle
10. Send data that completes minimum 6 fields - level transitions from 1 to 2
</verification>

<success_criteria>
- Timer countdown is visible and counts down in the Ingest tab
- Timer fires messages that appear in the chat as normal agent messages
- 5 sliders are independently adjustable
- 3 presets set all 5 sliders simultaneously
- Preset change while timer active restarts timer
- Level 2 silently transitions mode and chains to level 3
- Session reset stops the timer
- Questions do not interrupt the timer
- New data reevaluates the timer level
</success_criteria>

<output>
After completion, create `.planning/phases/15.7-ingest-timer-pluggable/15.7-02-SUMMARY.md`
</output>
