---
phase: 18-domain-layer-foundation
plan: 09
type: execute
wave: 5
depends_on: ["18-01", "18-04"]
files_modified:
  - src/lib/domain/conversations.ts
  - src/lib/domain/index.ts
  - src/app/actions/conversations.ts
  - src/app/actions/assignment.ts
  - src/lib/tools/handlers/whatsapp/index.ts
  - src/lib/whatsapp/webhook-handler.ts
  - src/inngest/functions/task-overdue-cron.ts
  - src/app/api/inngest/route.ts
autonomous: true

must_haves:
  truths:
    - "assignConversation domain function assigns conversation to agent"
    - "archiveConversation domain function archives/closes conversation"
    - "linkContactToConversation domain function links contact to conversation"
    - "findOrCreateConversation domain function creates conversations for new phone numbers"
    - "All conversation callers (server actions, tool handlers, webhook handler) use domain"
    - "task.overdue Inngest cron runs every 15 minutes and emits taskOverdue per overdue task"
    - "task.overdue trigger is no longer dead"
  artifacts:
    - path: "src/lib/domain/conversations.ts"
      provides: "4 conversation domain functions"
      exports: ["assignConversation", "archiveConversation", "linkContactToConversation", "findOrCreateConversation"]
    - path: "src/inngest/functions/task-overdue-cron.ts"
      provides: "Inngest cron function for overdue task detection"
      contains: "task-overdue-cron"
  key_links:
    - from: "src/inngest/functions/task-overdue-cron.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "import emitTaskOverdue"
      pattern: "emitTaskOverdue"
    - from: "src/lib/domain/conversations.ts"
      to: "src/lib/supabase/admin.ts"
      via: "createAdminClient"
      pattern: "createAdminClient"
---

<objective>
Create conversation domain functions, wire all callers, activate the task.overdue dead trigger with an Inngest cron job, and complete the final entity migration.

Purpose: Conversations are the last entity to migrate. After this plan, all 7 entities are domain-powered. Additionally, this plan activates the task.overdue trigger (the second dead trigger — keyword_match was activated in Plan 06).

Output: `src/lib/domain/conversations.ts` + 4 refactored callers + 1 new Inngest cron function.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/18-domain-layer-foundation/18-RESEARCH.md

Key reference files (READ THESE):
@src/app/actions/conversations.ts (assignConversation, archiveConversation, linkContactToConversation, etc.)
@src/app/actions/assignment.ts (assignConversation, assignToNextAvailable — round-robin logic)
@src/lib/tools/handlers/whatsapp/index.ts (whatsapp.conversation.assign, .close, .list)
@src/lib/whatsapp/webhook-handler.ts (findOrCreateConversation, linkConversationToContact)
@src/lib/automations/trigger-emitter.ts (emitTaskOverdue signature)
@src/inngest/functions/ (existing Inngest function patterns)
@src/app/api/inngest/route.ts (Inngest route — must register new cron function)
@src/lib/domain/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversations domain + wire callers</name>
  <files>src/lib/domain/conversations.ts, src/lib/domain/index.ts, src/app/actions/conversations.ts, src/app/actions/assignment.ts, src/lib/tools/handlers/whatsapp/index.ts, src/lib/whatsapp/webhook-handler.ts</files>
  <action>
**Create `src/lib/domain/conversations.ts`** with 4 functions:

1. **assignConversation(ctx, params):** params: conversationId, assignedTo: string (user ID) | null (unassign)
   - Logic: Update conversations.assigned_to. If assigning, update assigned_at timestamp.
   - No trigger currently defined for conversation assignment. Just domain encapsulation.
   - Return: `{ conversationId }`
   - IMPORTANT: Study `src/app/actions/assignment.ts` for the exact update logic, especially round-robin assignment.

2. **archiveConversation(ctx, params):** params: conversationId
   - Logic: Update conversations.status = 'archived'. Update archived_at timestamp.
   - Return: `{ conversationId }`
   - Note: "close" in tool handler maps to "archived" status (per Decision [12-03]).

3. **linkContactToConversation(ctx, params):** params: conversationId, contactId
   - Logic: Update conversations.contact_id = contactId.
   - Return: `{ conversationId, contactId }`

4. **findOrCreateConversation(ctx, params):** params: phone, contactId?, whatsappAccountId
   - Logic: Find existing conversation by phone + workspace. If not found, create new conversation. Link to contact if contactId provided.
   - Return: `{ conversationId, created: boolean }`
   - IMPORTANT: Study `src/lib/whatsapp/webhook-handler.ts` findOrCreateConversation for exact logic including conversation deduplication.

Update `src/lib/domain/index.ts`: Add `export * from './conversations'`.

**Wire callers:**

**`src/app/actions/conversations.ts`:**
1. Import domain conversation functions
2. assignConversation → call domainAssignConversation
3. archiveConversation / unarchiveConversation → call domain
4. linkContactToConversation → call domain
5. Keep auth + revalidatePath
6. Keep read-only functions as-is

**`src/app/actions/assignment.ts`:**
1. assignConversation → call domain
2. assignToNextAvailable: The round-robin logic (finding next agent) is a read query — keep it in the server action. But the actual assignment call → domain.
3. Keep auth + revalidatePath

**`src/lib/tools/handlers/whatsapp/index.ts`:**
1. `whatsapp.conversation.assign` → call domainAssignConversation
2. `whatsapp.conversation.close` → call domainArchiveConversation
3. `whatsapp.conversation.list` → keep as-is (read-only)
4. Remove direct DB logic from assign and close handlers

**`src/lib/whatsapp/webhook-handler.ts`:**
1. Replace findOrCreateConversation direct DB logic with `domainFindOrCreateConversation(ctx, { phone, contactId, whatsappAccountId })`
2. Replace linkConversationToContact calls with `domainLinkContactToConversation(ctx, { conversationId, contactId })`
3. Build DomainContext: `{ workspaceId, source: 'webhook' }`
4. NOTE: This webhook handler was already partially refactored in Plans 05 (contacts) and 06 (messages). This completes the webhook migration — after this, the entire webhook handler delegates to domain.
  </action>
  <verify>File compiles. 4 conversation domain functions exported. All 4 callers import from domain/conversations. Webhook handler no longer has direct conversation DB logic. Barrel export updated.</verify>
  <done>Conversations entity 100% complete. All 7 entities migrated to domain.</done>
</task>

<task type="auto">
  <name>Task 2: Create task.overdue Inngest cron + register</name>
  <files>src/inngest/functions/task-overdue-cron.ts, src/app/api/inngest/route.ts</files>
  <action>
**Create `src/inngest/functions/task-overdue-cron.ts`:**

```typescript
import { inngest } from '@/inngest/client'
import { createAdminClient } from '@/lib/supabase/admin'
import { emitTaskOverdue } from '@/lib/automations/trigger-emitter'

export const taskOverdueCron = inngest.createFunction(
  { id: 'task-overdue-cron', name: 'Check Overdue Tasks' },
  { cron: '*/15 * * * *' },  // Every 15 minutes
  async ({ step }) => {
    const supabase = createAdminClient()

    const overdueTasks = await step.run('find-overdue-tasks', async () => {
      const now = new Date().toISOString()
      const { data } = await supabase
        .from('tasks')
        .select('id, title, due_date, workspace_id, contact_id, order_id')
        .eq('status', 'pending')
        .lt('due_date', now)
        .not('due_date', 'is', null)
      return data || []
    })

    // Emit per-task (not batched)
    await step.run('emit-overdue-triggers', async () => {
      for (const task of overdueTasks) {
        emitTaskOverdue({
          workspaceId: task.workspace_id,
          taskId: task.id,
          taskTitle: task.title,
          dueDate: task.due_date!,
          contactId: task.contact_id,
          orderId: task.order_id,
        })
      }
      return { emitted: overdueTasks.length }
    })

    return { checked: overdueTasks.length }
  }
)
```

Follow the exact pattern from RESEARCH.md Code Examples section.

**IMPORTANT:** Add deduplication to prevent re-emitting for tasks that were already flagged overdue. Options:
- Add `overdue_notified_at` column to tasks table (recommended — simple, no extra queries)
- OR track in the query: filter `WHERE overdue_notified_at IS NULL` and then update it after emission
- Claude's discretion on the cleanest approach. If adding a column seems heavyweight, just emit every 15 minutes and let the automation runner handle idempotency (automations can check if they've already acted on this task).

**Register in `src/app/api/inngest/route.ts`:**
1. Import `taskOverdueCron` from `@/inngest/functions/task-overdue-cron`
2. Add to the Inngest serve function's array of functions
3. Study the existing route.ts to see how other functions are registered
  </action>
  <verify>Cron file exists and compiles. Route registers the new function. Grep for 'task-overdue-cron' in route.ts.</verify>
  <done>task.overdue trigger activated via 15-minute cron. Both dead triggers now active (keyword_match from Plan 06, task.overdue from this plan).</done>
</task>

</tasks>

<verification>
1. `src/lib/domain/conversations.ts` exports 4 functions
2. All conversation callers use domain functions
3. Webhook handler fully domain-powered (contacts, orders, messages, conversations)
4. `src/inngest/functions/task-overdue-cron.ts` exists with 15-minute cron
5. Inngest route registers the cron function
6. `src/lib/domain/index.ts` re-exports all 8 entity modules
7. `npx tsc --noEmit` passes
8. Both dead triggers now active: keyword_match + task.overdue
</verification>

<success_criteria>
- All 7 entities fully migrated to domain/ (orders, contacts, tags, messages, tasks, notes, custom-fields, conversations)
- task.overdue cron runs every 15 minutes
- Both dead triggers activated
- Webhook handler is fully domain-powered
</success_criteria>

<output>
After completion, create `.planning/phases/18-domain-layer-foundation/18-09-SUMMARY.md`
</output>
