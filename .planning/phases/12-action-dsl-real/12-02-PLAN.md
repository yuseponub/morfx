---
phase: 12-action-dsl-real
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/lib/tools/handlers/crm/index.ts
autonomous: true

must_haves:
  truths:
    - "crm.contact.create creates a real contact in Supabase and returns complete resource"
    - "crm.contact.update updates an existing contact and returns changed fields"
    - "crm.contact.read retrieves contact by ID with full details"
    - "crm.contact.list returns paginated contacts with optional search and tag filters"
    - "crm.contact.delete deletes a contact from the workspace"
    - "crm.tag.add adds a tag to a contact, creating the tag if needed"
    - "crm.tag.remove removes a tag from a contact"
    - "crm.order.create creates an order with products atomically, calculating total"
    - "crm.order.updateStatus moves an order to a new pipeline stage"
    - "Duplicate phone returns structured error with type 'duplicate' and suggestion"
    - "All handlers use createAdminClient and filter by workspace_id"
  artifacts:
    - path: "src/lib/tools/handlers/crm/index.ts"
      provides: "Real CRM tool handler implementations"
      exports: ["crmHandlers"]
      min_lines: 300
  key_links:
    - from: "src/lib/tools/handlers/crm/index.ts"
      to: "src/lib/supabase/admin.ts"
      via: "createAdminClient() for DB operations"
      pattern: "createAdminClient"
    - from: "src/lib/tools/handlers/crm/index.ts"
      to: "src/lib/tools/types.ts"
      via: "ToolResult<T> return types"
      pattern: "ToolResult"
    - from: "src/lib/tools/handlers/crm/index.ts"
      to: "src/lib/utils/phone.ts"
      via: "normalizePhone for contact create/update"
      pattern: "normalizePhone"
---

<objective>
Replace all 9 placeholder CRM tool handlers with real implementations that execute actual Supabase operations.

Purpose: CRM handlers are the core building blocks for the sales agent. Every contact creation, order placement, and tag operation must work for real.
Output: Real handlers in src/lib/tools/handlers/crm/index.ts returning ToolResult<T>.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-action-dsl-real/12-RESEARCH.md
@.planning/phases/12-action-dsl-real/12-CONTEXT.md
@.planning/phases/12-action-dsl-real/12-01-SUMMARY.md
@src/lib/tools/types.ts
@src/lib/tools/handlers/crm/index.ts
@src/app/actions/contacts.ts
@src/app/actions/orders.ts
@src/lib/supabase/admin.ts
@src/lib/utils/phone.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement contact handlers (create, update, read, list, delete)</name>
  <files>src/lib/tools/handlers/crm/index.ts</files>
  <action>
  REPLACE the entire content of `src/lib/tools/handlers/crm/index.ts`. Remove all placeholder code and implement real handlers.

  **Imports needed:**
  ```typescript
  import type { ToolHandler, ExecutionContext, ToolResult } from '../../types'
  import { createAdminClient } from '@/lib/supabase/admin'
  import { normalizePhone } from '@/lib/utils/phone'
  ```

  **Handler: `crm.contact.create`** (ADSL-R01)
  - Adapt from `createContact()` in `src/app/actions/contacts.ts:196`
  - Use `createAdminClient()` (NOT `createClient()`)
  - Normalize phone with `normalizePhone(input.phone)` -- return validation_error if null
  - Insert to `contacts` table with `workspace_id: context.workspaceId`
  - Handle tags: if `input.tags` provided, for each tag name: find or create tag in `tags` table (by name + workspace), then insert `contact_tags` entry
  - On error code `23505`: return `{ success: false, error: { type: 'duplicate', code: 'PHONE_DUPLICATE', message: 'Ya existe un contacto con este numero de telefono', suggestion: 'Use crm.contact.read para buscar el contacto existente', retryable: false } }`
  - dryRun: return preview with `_dry_run: true` in data
  - Success: return `{ success: true, data: contact, resource_url: '/crm/contactos/{id}' }`

  **Handler: `crm.contact.update`** (ADSL-R02)
  - Adapt from `updateContactFromForm()` in `src/app/actions/contacts.ts:330`
  - Build update object from only provided fields (name, phone, email, address, city)
  - If phone provided, normalize it first
  - Filter by `id: input.contactId` AND `workspace_id: context.workspaceId`
  - Handle `23505` same as create
  - Track which fields changed
  - Success: return `{ success: true, data: { ...updatedContact, changedFields: [...] }, resource_url: '/crm/contactos/{id}' }`

  **Handler: `crm.contact.read`** (ADSL-R03)
  - Query `contacts` with `id: input.contactId` AND `workspace_id: context.workspaceId`
  - Also fetch contact's tags via `contact_tags` join
  - If not found: return `{ success: false, error: { type: 'not_found', code: 'CONTACT_NOT_FOUND', message: 'Contacto no encontrado', retryable: false } }`
  - Success: return `{ success: true, data: { contact: { ...contactData, tags: [...] } }, resource_url: '/crm/contactos/{id}' }`

  **Handler: `crm.contact.list`**
  - Adapt from `getContacts()` in `src/app/actions/contacts.ts:38`
  - Support `page`, `pageSize`, `search`, `tags`, `sortBy`, `sortOrder` from input
  - Default: page=1, pageSize=20, sortBy='created_at', sortOrder='desc'
  - Search: use `.or()` with `name.ilike.%${search}%,phone.ilike.%${search}%,email.ilike.%${search}%`
  - Tags filter: use subquery via `contact_tags` to filter contacts that have ALL specified tags
  - Always filter by `workspace_id: context.workspaceId`
  - Return paginated result with total count

  **Handler: `crm.contact.delete`**
  - Adapt from `deleteContact()` in `src/app/actions/contacts.ts:393`
  - Delete from `contacts` where `id: input.contactId` AND `workspace_id: context.workspaceId`
  - If no rows affected: return not_found error
  - Success: return `{ success: true, data: { contactId: input.contactId, deleted: true } }`

  **CRITICAL rules for ALL handlers:**
  - Use `createAdminClient()` for every handler (NOT cookie-based createClient)
  - EVERY Supabase query MUST include `.eq('workspace_id', context.workspaceId)` filter
  - Do NOT call `revalidatePath()` -- tool handlers don't run in React Server Component context
  - Do NOT call `cookies()` or `supabase.auth.getUser()` -- tool handlers have no user session
  - Return `ToolResult<T>` for every handler (never throw, always return structured response)
  - dryRun mode: return a preview without modifying the database
  </action>
  <verify>
  `npx tsc --noEmit` passes. `grep -c "createAdminClient" src/lib/tools/handlers/crm/index.ts` shows usage. `grep -c "workspace_id" src/lib/tools/handlers/crm/index.ts` confirms workspace isolation in every handler.
  </verify>
  <done>
  Contact handlers (create, update, read, list, delete) implemented with real Supabase operations, workspace isolation, and ToolResult<T> returns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement tag and order handlers</name>
  <files>src/lib/tools/handlers/crm/index.ts</files>
  <action>
  Add the remaining handlers to the same file (continuing from Task 1).

  **Handler: `crm.tag.add`**
  - Adapt from `addTagToContact()` in `src/app/actions/contacts.ts:451`
  - The input has `contactId` and `tag` (tag NAME, not ID)
  - Step 1: Verify contact exists and belongs to workspace
  - Step 2: Find tag by name in workspace, or create it if not exists (insert into `tags` table with workspace_id, name, and a default color like '#6366f1')
  - Step 3: Insert into `contact_tags` (contact_id, tag_id)
  - Handle `23505` (duplicate): return success with `alreadyHadTag: true`
  - Success: return `{ success: true, data: { contactId, tag: tagName, tagId: tag.id, added: true, alreadyHadTag: false } }`

  **Handler: `crm.tag.remove`**
  - Adapt from `removeTagFromContact()` in `src/app/actions/contacts.ts:480`
  - Find tag by name in workspace
  - Delete from `contact_tags` where contact_id and tag_id match
  - If tag not found: return not_found error with suggestion
  - Success: return `{ success: true, data: { contactId, tag: tagName, removed: true, hadTag: true } }`

  **Handler: `crm.order.create`** (ADSL-R04)
  - Adapt from `createOrder()` in `src/app/actions/orders.ts:307`
  - Input: `contactId`, `products` (array of {name, quantity, price}), optional `shippingAddress`, `notes`
  - Step 1: Verify contact exists and belongs to workspace
  - Step 2: Get default pipeline and first stage for workspace:
    - Query `pipelines` where `workspace_id = context.workspaceId` and `is_default = true`
    - If no default pipeline, get any pipeline for the workspace
    - If no pipeline at all, return error: "No hay pipeline configurado en el workspace"
    - Get first stage (position 0) from that pipeline
  - Step 3: Create order in `orders` table with workspace_id, contact_id, pipeline_id, stage_id, shipping_address, description (from notes)
  - Step 4: Insert products into `order_products` table (order_id, sku=name, title=name, unit_price=price, quantity)
  - Step 5: If products insert fails, DELETE the order (manual rollback) and return error
  - Step 6: Re-query the complete order to get calculated total_value (calculated by DB trigger)
  - Success: return `{ success: true, data: { orderId, total: order.total_value, contactId, stageId, pipelineId, products: [...], created_at }, resource_url: '/crm/pedidos' }`

  NOTE on atomicity: The research suggests PostgreSQL RPC for atomicity. However, since the existing server action pattern uses manual rollback (delete order if products fail), follow the SAME pattern to stay consistent with the codebase. Do NOT create a new RPC function -- that adds migration complexity. Manual rollback is proven and works.

  **Handler: `crm.order.updateStatus`** (ADSL-R05)
  - Adapt from `moveOrderToStage()` in `src/app/actions/orders.ts:475`
  - Input: `orderId`, `status` (this is a stage NAME or stage ID -- try UUID first, if not UUID try by name)
  - Step 1: Verify order exists and belongs to workspace
  - Step 2: Get current stage_id from order
  - Step 3: Find new stage:
    - If `input.status` is a UUID, look up by ID
    - Otherwise, look up by name in the same pipeline as the order
  - Step 4: Update order stage_id
  - Success: return `{ success: true, data: { orderId, previousStatus: oldStageName, newStatus: newStageName, stageId: newStageId, updated: true } }`

  Ensure ALL handlers are exported in the `crmHandlers` record with the same keys as before.
  </action>
  <verify>
  `npx tsc --noEmit` passes. `grep -c "crmHandlers" src/lib/tools/handlers/crm/index.ts` shows the export. Verify all 9 handler keys exist: `grep "'crm\." src/lib/tools/handlers/crm/index.ts`
  </verify>
  <done>
  All 9 CRM handlers implemented: contact.create, contact.update, contact.read, contact.list, contact.delete, tag.add, tag.remove, order.create, order.updateStatus. All use createAdminClient, all filter by workspace_id, all return ToolResult<T>.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 9 CRM handler keys present in crmHandlers export
3. Every handler uses createAdminClient (no createClient)
4. Every Supabase query filters by workspace_id
5. No calls to revalidatePath, cookies(), or auth.getUser()
6. Duplicate phone returns structured ToolError with type 'duplicate'
7. Not-found cases return ToolError with type 'not_found'
</verification>

<success_criteria>
- crm.contact.create inserts real contact to Supabase, returns complete resource with ID
- crm.order.create inserts order + products atomically, returns calculated total
- All handlers return ToolResult<T> with proper error classification
- Workspace isolation enforced on every query
</success_criteria>

<output>
After completion, create `.planning/phases/12-action-dsl-real/12-02-SUMMARY.md`
</output>
