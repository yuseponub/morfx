---
phase: 06-orders
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/actions/products.ts
  - src/app/(dashboard)/crm/productos/page.tsx
  - src/app/(dashboard)/crm/productos/components/products-table.tsx
  - src/app/(dashboard)/crm/productos/components/product-form.tsx
  - src/app/(dashboard)/crm/productos/components/columns.tsx
autonomous: true

must_haves:
  truths:
    - "User can view list of products in their workspace"
    - "User can create a new product with SKU, title, and price"
    - "User can edit and delete products"
    - "Products can be marked as active/inactive"
  artifacts:
    - path: "src/app/actions/products.ts"
      provides: "Server Actions for product CRUD"
      exports: ["getProducts", "createProduct", "updateProduct", "deleteProduct"]
    - path: "src/app/(dashboard)/crm/productos/page.tsx"
      provides: "Products catalog page"
    - path: "src/app/(dashboard)/crm/productos/components/products-table.tsx"
      provides: "TanStack Table for products list"
  key_links:
    - from: "products-table.tsx"
      to: "actions/products.ts"
      via: "Server Actions for CRUD"
      pattern: "createProduct|updateProduct|deleteProduct"
    - from: "page.tsx"
      to: "products-table.tsx"
      via: "Component composition"
      pattern: "ProductsTable"
---

<objective>
Create the product catalog with full CRUD operations, allowing users to manage their products before creating orders.

Purpose: Products are selected when creating orders; they need to exist first
Output: Products page with table, forms, and Server Actions for complete product management
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-orders/06-CONTEXT.md
@.planning/phases/06-orders/06-RESEARCH.md
@src/lib/orders/types.ts
@src/app/actions/contacts.ts
@src/app/(dashboard)/crm/contactos/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Server Actions for product CRUD</name>
  <files>src/app/actions/products.ts</files>
  <action>
Create Server Actions for product management following patterns from contacts.ts:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import type { Product, ProductFormData } from '@/lib/orders/types'

// Validation schema
const productSchema = z.object({
  sku: z.string().min(1, 'SKU es requerido').max(50, 'SKU muy largo'),
  title: z.string().min(1, 'Titulo es requerido').max(200, 'Titulo muy largo'),
  price: z.number().min(0, 'Precio debe ser positivo'),
  shopify_product_id: z.string().optional().nullable(),
  is_active: z.boolean().optional().default(true),
})

// Get all products for workspace
export async function getProducts(): Promise<{ data: Product[] | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('products')
    .select('*')
    .order('title', { ascending: true })

  if (error) {
    return { data: null, error: error.message }
  }

  return { data, error: null }
}

// Get active products only (for order creation)
export async function getActiveProducts(): Promise<{ data: Product[] | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('products')
    .select('*')
    .eq('is_active', true)
    .order('title', { ascending: true })

  if (error) {
    return { data: null, error: error.message }
  }

  return { data, error: null }
}

// Get single product by ID
export async function getProduct(id: string): Promise<{ data: Product | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('products')
    .select('*')
    .eq('id', id)
    .single()

  if (error) {
    return { data: null, error: error.message }
  }

  return { data, error: null }
}

// Create product
export async function createProduct(formData: ProductFormData): Promise<{ data: Product | null; error: string | null }> {
  const validation = productSchema.safeParse(formData)
  if (!validation.success) {
    return { data: null, error: validation.error.issues[0].message }
  }

  const supabase = await createClient()

  const { data, error } = await supabase
    .from('products')
    .insert(validation.data)
    .select()
    .single()

  if (error) {
    if (error.code === '23505') { // Unique violation
      return { data: null, error: 'Ya existe un producto con este SKU' }
    }
    return { data: null, error: error.message }
  }

  revalidatePath('/crm/productos')
  return { data, error: null }
}

// Update product
export async function updateProduct(id: string, formData: Partial<ProductFormData>): Promise<{ data: Product | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('products')
    .update({
      ...formData,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      return { data: null, error: 'Ya existe un producto con este SKU' }
    }
    return { data: null, error: error.message }
  }

  revalidatePath('/crm/productos')
  return { data, error: null }
}

// Delete product
export async function deleteProduct(id: string): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('products')
    .delete()
    .eq('id', id)

  if (error) {
    return { success: false, error: error.message }
  }

  revalidatePath('/crm/productos')
  return { success: true, error: null }
}

// Toggle product active status
export async function toggleProductActive(id: string, is_active: boolean): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('products')
    .update({ is_active, updated_at: new Date().toISOString() })
    .eq('id', id)

  if (error) {
    return { success: false, error: error.message }
  }

  revalidatePath('/crm/productos')
  return { success: true, error: null }
}
```

Follow Zod v4 patterns (use .issues for errors, not .errors).
  </action>
  <verify>
Run: `pnpm tsc --noEmit` - No TypeScript errors
Check: All exports match the Server Action pattern
  </verify>
  <done>
Server Actions exist for getProducts, getActiveProducts, createProduct, updateProduct, deleteProduct, toggleProductActive
  </done>
</task>

<task type="auto">
  <name>Task 2: Create products page with table, form, and columns</name>
  <files>
    src/app/(dashboard)/crm/productos/page.tsx
    src/app/(dashboard)/crm/productos/components/products-table.tsx
    src/app/(dashboard)/crm/productos/components/product-form.tsx
    src/app/(dashboard)/crm/productos/components/columns.tsx
  </files>
  <action>
Create the products catalog UI following patterns from contactos:

**1. page.tsx:**
- Async Server Component that fetches products via Server Action
- Pass products to ProductsTable
- Handle error state
- Title: "Catalogo de Productos"

**2. products-table.tsx:**
- Client component with TanStack Table (reuse DataTable pattern from contacts)
- Toolbar with:
  - Search input (filter by title or SKU)
  - "Nuevo Producto" button that opens dialog
  - Toggle to show inactive products
- Empty state with CTA to create first product
- Product form in Dialog for create/edit

**3. product-form.tsx:**
- Form with fields:
  - SKU (required, text input)
  - Titulo (required, text input)
  - Precio (required, number input with currency formatting)
  - Shopify Product ID (optional, text input, disabled/readonly info)
  - Activo (checkbox)
- Validation with Zod
- Submit calls createProduct or updateProduct
- Toast notifications on success/error

**4. columns.tsx:**
- Column definitions:
  - SKU (sortable)
  - Titulo (sortable)
  - Precio (formatted as currency COP, sortable)
  - Estado (badge: Activo/Inactivo)
  - Acciones (edit, toggle active, delete with confirmation)
- createColumns factory pattern (inject callbacks like contacts)

UI patterns to follow:
- Use existing shadcn/ui components (Dialog, Button, Input, Badge, etc.)
- Format currency: `new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP' })`
- Use toast from sonner for notifications
- Mobile-responsive table with horizontal scroll
  </action>
  <verify>
Run: `pnpm tsc --noEmit` - No TypeScript errors
Navigate to /crm/productos - Page renders
Test: Create, edit, delete product operations work
  </verify>
  <done>
Products page displays table with CRUD operations, forms validate input, actions show toast feedback
  </done>
</task>

</tasks>

<verification>
1. Products Server Actions compile: `pnpm tsc --noEmit`
2. Products page accessible at /crm/productos
3. Can create new product with SKU, title, price
4. Can edit existing product
5. Can delete product (with confirmation)
6. Can toggle active/inactive status
7. Table shows all products with sorting and filtering
</verification>

<success_criteria>
- Complete product catalog CRUD
- SKU uniqueness enforced
- Currency formatting for prices
- Active/inactive status toggle
- Following existing UI patterns from contacts module
</success_criteria>

<output>
After completion, create `.planning/phases/06-orders/06-02-SUMMARY.md`
</output>
