---
phase: 22-robot-coordinadora-service
plan: 03
type: execute
wave: 3
depends_on: ["22-01", "22-02"]
files_modified:
  - robot-coordinadora/src/api/server.ts
  - robot-coordinadora/src/index.ts
  - robot-coordinadora/Dockerfile

autonomous: true

must_haves:
  truths:
    - "GET /api/health returns 200 with uptime and timestamp"
    - "POST /api/crear-pedidos-batch accepts a batch request, validates fields, and returns immediate 200 acknowledgement"
    - "If workspace already has an active batch, the endpoint returns 409 Conflict"
    - "Each order in the batch is processed sequentially with 2-second delays between orders"
    - "After each order, the robot POSTs the result to the callbackUrl provided in the request"
    - "Orders already being processed (per-order lock) are skipped with an error callback"
    - "The Docker image uses the official Playwright base image and starts the Express server"
    - "The service starts on port 3001 (or PORT env var)"
  artifacts:
    - path: "robot-coordinadora/src/api/server.ts"
      provides: "Express server with health and batch endpoints"
      exports: ["createServer"]
      min_lines: 150
    - path: "robot-coordinadora/src/index.ts"
      provides: "Application entry point"
      min_lines: 10
    - path: "robot-coordinadora/Dockerfile"
      provides: "Docker image for Railway deployment"
      contains: "playwright"
  key_links:
    - from: "robot-coordinadora/src/api/server.ts"
      to: "robot-coordinadora/src/adapters/coordinadora-adapter.ts"
      via: "import CoordinadoraAdapter, instantiate per batch"
      pattern: "new CoordinadoraAdapter"
    - from: "robot-coordinadora/src/api/server.ts"
      to: "robot-coordinadora/src/middleware/locks.ts"
      via: "import workspace and order lock functions"
      pattern: "withWorkspaceLock|isWorkspaceLocked|tryLockOrder"
    - from: "robot-coordinadora/src/api/server.ts"
      to: "MorfX callback API (Phase 23)"
      via: "fetch POST to callbackUrl with BatchItemResult"
      pattern: "callbackUrl"
    - from: "robot-coordinadora/src/index.ts"
      to: "robot-coordinadora/src/api/server.ts"
      via: "import createServer and call listen()"
      pattern: "createServer"
---

<objective>
Build the Express server with health check and batch processing endpoints, the application entry point, and the Docker image for Railway deployment. This plan wires together the types (Plan 01), locking middleware (Plan 01), and CoordinadoraAdapter (Plan 02) into a working HTTP service.

Purpose: This is the integration layer that receives batch requests from MorfX, processes them through the adapter, reports results via callbacks, and runs in Docker on Railway.

Output: A fully functional, deployable microservice that accepts batch shipment creation requests.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/22-robot-coordinadora-service/22-CONTEXT.md
@.planning/phases/22-robot-coordinadora-service/22-RESEARCH.md
@.planning/phases/22-robot-coordinadora-service/22-01-SUMMARY.md
@.planning/phases/22-robot-coordinadora-service/22-02-SUMMARY.md

# Key references from prior plans (read these files for exact exports/interfaces):
# robot-coordinadora/src/types/index.ts
# robot-coordinadora/src/middleware/locks.ts
# robot-coordinadora/src/adapters/coordinadora-adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Express server with health and batch endpoints</name>
  <files>robot-coordinadora/src/api/server.ts</files>
  <action>
Create the Express server that exposes the robot's HTTP API. Export a `createServer()` function that returns the configured Express app (allows the entry point to call listen separately).

**Endpoints:**

**1. GET /api/health**
Returns `{ status: 'ok', uptime: process.uptime(), timestamp: new Date().toISOString() }` with 200 status. Used by Railway for health checks.

**2. POST /api/crear-pedidos-batch**
The main batch processing endpoint. Flow:

a) **Parse and validate request body** (BatchRequest type):
   - `workspaceId` (string, required)
   - `credentials` (object with username + password, required)
   - `callbackUrl` (string, required)
   - `jobId` (string, required)
   - `orders` (array of OrderInput, required, non-empty)
   - If any field is missing, return 400 with `{ success: false, error: 'Campo requerido: [field]' }`

b) **Check workspace lock:**
   - Call `isWorkspaceLocked(workspaceId)` from locks middleware
   - If locked, return 409 with `{ success: false, error: 'Ya hay un batch en proceso para este workspace' }`

c) **Acknowledge immediately:**
   - Return 200 with `{ success: true, jobId, message: 'Batch aceptado, procesando...' }`
   - Processing continues in the background (do NOT await the processing promise before responding)

d) **Process batch in background** (async, after response is sent):
   - Wrap everything in `withWorkspaceLock(workspaceId, async () => { ... })`
   - Create a `CoordinadoraAdapter` instance with credentials and workspaceId
   - Call `adapter.init()`
   - Call `adapter.login()` -- if login fails, report ALL orders as error via callback, then close adapter and return
   - For each order in `orders`:
     - Call `tryLockOrder(order.orderId)` -- if returns false, report this order via callback as error (`errorType: 'validation'`, `errorMessage: 'Pedido ya en proceso'`), continue to next
     - Try: call `adapter.createGuia(order.pedidoInput)`
     - Report result to callback URL (success or error)
     - Finally: call `unlockOrder(order.orderId)`
     - Wait 2 seconds between orders (`await sleep(2000)`)
   - Finally (even on error): call `adapter.close()` to prevent zombie Chromium processes

**Callback reporting function** (internal helper):
```typescript
async function reportResult(callbackUrl: string, result: BatchItemResult): Promise<void> {
  try {
    await fetch(callbackUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(result),
    })
  } catch (err) {
    console.error(`[Server] Error reporting result to callback:`, err)
    // Don't throw -- callback failure shouldn't stop batch processing
  }
}
```

**sleep helper:**
```typescript
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}
```

**Error handling in batch processing:**
- If adapter.init() or adapter.login() throws, report ALL remaining orders as error via callback
- If adapter.createGuia() throws for one order, report that order as error, continue to next
- ALWAYS call adapter.close() in finally block
- Log all errors with `[Server]` prefix

**Express middleware:**
- `express.json()` for body parsing (with a reasonable limit, e.g., `{ limit: '5mb' }`)
- Simple request logging: `console.log([Server] ${req.method} ${req.path})` on each request

**IMPORTANT:** The `fetch()` call for callback reporting uses Node.js 18+ built-in fetch (no need for node-fetch package). The Playwright Docker image includes Node.js 20+.

**IMPORTANT:** The batch processing runs AFTER the response is sent. Use an immediately-invoked async function or Promise that is NOT awaited by the request handler. But DO catch and log any unhandled errors from the background processing.

```typescript
// Pattern for fire-and-forget with error handling:
processBatch(req.body).catch(err => {
  console.error('[Server] Unhandled batch processing error:', err)
})
```
  </action>
  <verify>
- `cd robot-coordinadora && npx tsc --noEmit` compiles without errors
- `grep "export function createServer" robot-coordinadora/src/api/server.ts` finds the export
- `grep "/api/health" robot-coordinadora/src/api/server.ts` finds the health endpoint
- `grep "/api/crear-pedidos-batch" robot-coordinadora/src/api/server.ts` finds the batch endpoint
- `grep "callbackUrl" robot-coordinadora/src/api/server.ts` finds callback reporting
- `grep "withWorkspaceLock" robot-coordinadora/src/api/server.ts` finds workspace locking
- `grep "tryLockOrder" robot-coordinadora/src/api/server.ts` finds order locking
- `grep "sleep(2000)" robot-coordinadora/src/api/server.ts` finds the inter-order delay
  </verify>
  <done>
Express server handles health checks and batch processing with workspace/order locking, sequential order processing with delays, callback result reporting, and proper error handling for all failure modes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create entry point and Dockerfile</name>
  <files>
    robot-coordinadora/src/index.ts
    robot-coordinadora/Dockerfile
  </files>
  <action>
**src/index.ts** -- Application entry point:

```typescript
import { createServer } from './api/server.js'

const PORT = parseInt(process.env.PORT || '3001', 10)

const app = createServer()

app.listen(PORT, () => {
  console.log(`[Robot Coordinadora] Server running on port ${PORT}`)
  console.log(`[Robot Coordinadora] Health check: http://localhost:${PORT}/api/health`)
})

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('[Robot Coordinadora] SIGTERM received, shutting down...')
  process.exit(0)
})

process.on('SIGINT', () => {
  console.log('[Robot Coordinadora] SIGINT received, shutting down...')
  process.exit(0)
})
```

**Dockerfile** -- Production Docker image:

```dockerfile
# Use official Playwright image (includes Chromium + all system dependencies)
FROM mcr.microsoft.com/playwright:v1.52.0-noble

WORKDIR /app

# Copy package files first (Docker cache layer optimization)
COPY package*.json ./

# Install production dependencies only
RUN npm ci --omit=dev

# Copy source code
COPY . .

# Build TypeScript
RUN npm run build

# Create storage directories
RUN mkdir -p storage/sessions storage/artifacts

# Health check for Railway
HEALTHCHECK --interval=30s --timeout=10s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:3001/api/health || exit 1

# Default port (Railway may override via PORT env var)
EXPOSE 3001

# Start the compiled application
CMD ["node", "dist/index.js"]
```

**IMPORTANT Dockerfile notes:**
- Use `mcr.microsoft.com/playwright:v1.52.0-noble` (matches the playwright npm package version from package.json -- if Plan 01 used a different version, match that exactly)
- `--omit=dev` ensures TypeScript and other dev deps are NOT in the production image
- The build step compiles TypeScript to `dist/`
- Storage directories are created for cookie persistence and error screenshots
- HEALTHCHECK uses curl which is available in the Playwright base image
- EXPOSE 3001 is the default; Railway injects PORT env var which the entry point reads
- `--start-period=15s` gives the app time to start before health checks begin

Also ensure the `storage/` directory structure exists for local dev:
- Create `robot-coordinadora/storage/sessions/.gitkeep`
- Create `robot-coordinadora/storage/artifacts/.gitkeep`
  </action>
  <verify>
- `cd robot-coordinadora && npx tsc --noEmit` compiles without errors
- `cd robot-coordinadora && npm run build` succeeds and creates dist/index.js
- `ls robot-coordinadora/dist/index.js` exists
- `ls robot-coordinadora/Dockerfile` exists
- `grep "playwright" robot-coordinadora/Dockerfile` finds the base image
- `grep "HEALTHCHECK" robot-coordinadora/Dockerfile` finds the health check
- `grep "PORT" robot-coordinadora/src/index.ts` finds the port configuration
- `ls robot-coordinadora/storage/sessions/.gitkeep` exists
  </verify>
  <done>
Entry point starts Express server on configurable port with graceful shutdown. Dockerfile uses official Playwright base image with production build, health check, and storage directories. The service is ready for Docker build and Railway deployment.
  </done>
</task>

</tasks>

<verification>
1. `cd robot-coordinadora && npx tsc --noEmit` passes with zero errors
2. `cd robot-coordinadora && npm run build` creates dist/ with compiled JavaScript
3. `node robot-coordinadora/dist/index.js` starts the server (test with quick curl then kill)
4. GET /api/health returns 200 with status, uptime, timestamp
5. POST /api/crear-pedidos-batch with missing fields returns 400
6. POST /api/crear-pedidos-batch with valid body returns immediate 200 acknowledgement
7. Dockerfile references correct Playwright base image version
8. HEALTHCHECK is configured for /api/health
9. All imports resolve correctly (types -> adapter -> server -> index chain)
</verification>

<success_criteria>
- Express server starts on port 3001 and responds to health checks
- Batch endpoint validates input, checks workspace lock, acknowledges immediately, and processes in background
- Callback reporting POSTs results to the provided callbackUrl
- Dockerfile builds a production image with the official Playwright base
- The entire project compiles, builds, and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-robot-coordinadora-service/22-03-SUMMARY.md`
</output>
