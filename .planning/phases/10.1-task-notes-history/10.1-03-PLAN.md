---
phase: 10.1-task-notes-history
plan: 03
type: execute
wave: 3
depends_on: ["10.1-02"]
files_modified:
  - src/components/tasks/task-notes.tsx
  - src/components/tasks/task-history.tsx
  - src/components/tasks/postponement-badge.tsx
  - src/components/tasks/task-item.tsx
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User can add notes to a task via UI"
    - "User can view task change history in timeline format"
    - "Postponement badge shows when task has been postponed 1+ times"
    - "Badge shows yellow for 1-2 postponements, red for 3+"
  artifacts:
    - path: "src/components/tasks/task-notes.tsx"
      provides: "NotesSection for tasks"
      exports: ["TaskNotesSection"]
    - path: "src/components/tasks/task-history.tsx"
      provides: "Activity timeline for tasks"
      exports: ["TaskHistoryTimeline"]
    - path: "src/components/tasks/postponement-badge.tsx"
      provides: "Visual indicator for postponements"
      exports: ["PostponementBadge"]
  key_links:
    - from: "src/components/tasks/task-notes.tsx"
      to: "src/app/actions/task-notes.ts"
      via: "createTaskNote, updateTaskNote, deleteTaskNote"
      pattern: "import.*from.*task-notes"
    - from: "src/components/tasks/task-history.tsx"
      to: "src/app/actions/task-activity.ts"
      via: "getTaskActivity"
      pattern: "import.*from.*task-activity"
    - from: "src/components/tasks/task-item.tsx"
      to: "src/components/tasks/postponement-badge.tsx"
      via: "PostponementBadge rendered in Meta row after due date badge"
      pattern: "PostponementBadge"
---

<objective>
Create UI components for task notes, activity history, and postponement indicator.

Purpose: Enable users to add notes, view change history, and see visual indicators when tasks are postponed multiple times. Follows existing contact notes/activity UI patterns.

Output: Three new components (task-notes, task-history, postponement-badge) integrated into task list and detail views.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10.1-task-notes-history/10.1-RESEARCH.md
@.planning/phases/10.1-task-notes-history/10.1-02-SUMMARY.md

# Key reference files - follow these patterns
@src/app/(dashboard)/crm/contactos/[id]/components/notes-section.tsx
@src/app/(dashboard)/crm/contactos/[id]/components/activity-timeline.tsx
@src/components/ui/timeline.tsx
@src/components/tasks/task-item.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostponementBadge component</name>
  <files>src/components/tasks/postponement-badge.tsx</files>
  <action>
Create new file `src/components/tasks/postponement-badge.tsx`:

```typescript
'use client'

import { ClockIcon } from 'lucide-react'
import { Badge } from '@/components/ui/badge'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip'
import { cn } from '@/lib/utils'

interface PostponementBadgeProps {
  count: number
  className?: string
}

/**
 * Visual indicator showing how many times a task has been postponed.
 * - 0: Nothing shown
 * - 1-2: Yellow/warning indicator
 * - 3+: Red/critical indicator
 */
export function PostponementBadge({ count, className }: PostponementBadgeProps) {
  if (count === 0) return null

  const severity = count >= 3 ? 'critical' : 'warning'

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Badge
            variant="outline"
            className={cn(
              "text-xs gap-1 cursor-help",
              severity === 'critical'
                ? "bg-red-100 text-red-700 border-red-300 dark:bg-red-900/30 dark:text-red-400 dark:border-red-800"
                : "bg-yellow-100 text-yellow-700 border-yellow-300 dark:bg-yellow-900/30 dark:text-yellow-400 dark:border-yellow-800",
              className
            )}
          >
            <ClockIcon className="h-3 w-3" />
            {count}x
          </Badge>
        </TooltipTrigger>
        <TooltipContent>
          Esta tarea ha sido postergada {count} {count === 1 ? 'vez' : 'veces'}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
}
```

**Design decisions:**
- Shows nothing for count=0 (clean UI)
- Yellow for 1-2 (warning - something to watch)
- Red for 3+ (critical - recurring postponement pattern)
- Tooltip explains the count
- Uses existing Badge component with custom colors
  </action>
  <verify>
```bash
# Check file exists with exports
grep -E "(export function PostponementBadge|severity|critical|warning)" /mnt/c/Users/Usuario/Proyectos/morfx-new/src/components/tasks/postponement-badge.tsx
```
  </verify>
  <done>
src/components/tasks/postponement-badge.tsx exists with:
- PostponementBadge component
- Severity-based coloring (yellow/red)
- Tooltip with Spanish explanation
- Returns null for count=0
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TaskNotesSection component</name>
  <files>src/components/tasks/task-notes.tsx</files>
  <action>
Create new file `src/components/tasks/task-notes.tsx` with FULL implementation (not skeleton):

```typescript
'use client'

import * as React from 'react'
import { useRouter } from 'next/navigation'
import { MessageSquareIcon, PencilIcon, TrashIcon, UserIcon } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Timeline, TimelineItem, formatRelativeDate } from '@/components/ui/timeline'
import { createTaskNote, updateTaskNote, deleteTaskNote } from '@/app/actions/task-notes'
import { toast } from 'sonner'
import type { TaskNoteWithUser } from '@/lib/tasks/types'

interface TaskNotesSectionProps {
  taskId: string
  initialNotes: TaskNoteWithUser[]
  currentUserId?: string
  isAdminOrOwner?: boolean
}

export function TaskNotesSection({
  taskId,
  initialNotes,
  currentUserId,
  isAdminOrOwner = false,
}: TaskNotesSectionProps) {
  const router = useRouter()
  const [notes, setNotes] = React.useState(initialNotes)
  const [newNote, setNewNote] = React.useState('')
  const [isCreating, setIsCreating] = React.useState(false)
  const [editingId, setEditingId] = React.useState<string | null>(null)
  const [editContent, setEditContent] = React.useState('')
  const [isUpdating, setIsUpdating] = React.useState(false)
  const [deletingId, setDeletingId] = React.useState<string | null>(null)

  // Handle creating a new note
  const handleCreate = async () => {
    if (!newNote.trim()) return

    setIsCreating(true)

    // Optimistic update
    const optimisticNote: TaskNoteWithUser = {
      id: `temp-${Date.now()}`,
      task_id: taskId,
      workspace_id: '',
      user_id: currentUserId || '',
      content: newNote.trim(),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      user: { id: currentUserId || '', email: 'Tu' }
    }

    setNotes(prev => [optimisticNote, ...prev])
    setNewNote('')

    try {
      const result = await createTaskNote(taskId, newNote.trim())

      if ('error' in result) {
        // Revert optimistic update
        setNotes(prev => prev.filter(n => n.id !== optimisticNote.id))
        setNewNote(optimisticNote.content)
        toast.error(result.error)
      } else {
        // Replace optimistic note with real one
        setNotes(prev => prev.map(n =>
          n.id === optimisticNote.id ? result.data : n
        ))
        toast.success('Nota agregada')
        router.refresh()
      }
    } catch {
      // Revert on error
      setNotes(prev => prev.filter(n => n.id !== optimisticNote.id))
      setNewNote(optimisticNote.content)
      toast.error('Error al agregar la nota')
    } finally {
      setIsCreating(false)
    }
  }

  // Handle editing a note
  const handleStartEdit = (note: TaskNoteWithUser) => {
    setEditingId(note.id)
    setEditContent(note.content)
  }

  const handleCancelEdit = () => {
    setEditingId(null)
    setEditContent('')
  }

  const handleSaveEdit = async () => {
    if (!editingId || !editContent.trim()) return

    setIsUpdating(true)

    const originalNote = notes.find(n => n.id === editingId)
    if (!originalNote) return

    // Optimistic update
    setNotes(prev => prev.map(n =>
      n.id === editingId ? { ...n, content: editContent.trim(), updated_at: new Date().toISOString() } : n
    ))

    try {
      const result = await updateTaskNote(editingId, editContent.trim())

      if ('error' in result) {
        // Revert optimistic update
        setNotes(prev => prev.map(n =>
          n.id === editingId ? originalNote : n
        ))
        toast.error(result.error)
      } else {
        toast.success('Nota actualizada')
        setEditingId(null)
        setEditContent('')
        router.refresh()
      }
    } catch {
      // Revert on error
      setNotes(prev => prev.map(n =>
        n.id === editingId ? originalNote : n
      ))
      toast.error('Error al actualizar la nota')
    } finally {
      setIsUpdating(false)
    }
  }

  // Handle deleting a note
  const handleDelete = async (noteId: string) => {
    if (!confirm('Eliminar esta nota? Esta accion no se puede deshacer.')) return

    setDeletingId(noteId)

    const noteToDelete = notes.find(n => n.id === noteId)
    if (!noteToDelete) return

    // Optimistic update
    setNotes(prev => prev.filter(n => n.id !== noteId))

    try {
      const result = await deleteTaskNote(noteId)

      if ('error' in result) {
        // Revert optimistic update
        setNotes(prev => {
          const newNotes = [...prev]
          // Find correct position to insert back
          const index = newNotes.findIndex(n =>
            new Date(n.created_at) < new Date(noteToDelete.created_at)
          )
          if (index === -1) {
            newNotes.push(noteToDelete)
          } else {
            newNotes.splice(index, 0, noteToDelete)
          }
          return newNotes
        })
        toast.error(result.error)
      } else {
        toast.success('Nota eliminada')
        router.refresh()
      }
    } catch {
      // Revert on error - simplified: just add at the beginning
      setNotes(prev => [noteToDelete, ...prev])
      toast.error('Error al eliminar la nota')
    } finally {
      setDeletingId(null)
    }
  }

  // Check if current user can edit/delete a note
  const canModify = (note: TaskNoteWithUser) => {
    return note.user_id === currentUserId || isAdminOrOwner
  }

  return (
    <div className="space-y-6">
      {/* Add note form */}
      <div className="space-y-3">
        <Textarea
          placeholder="Escribe una nota..."
          value={newNote}
          onChange={(e) => setNewNote(e.target.value)}
          rows={3}
          className="resize-none"
        />
        <Button
          onClick={handleCreate}
          disabled={!newNote.trim() || isCreating}
          size="sm"
        >
          {isCreating ? 'Agregando...' : 'Agregar nota'}
        </Button>
      </div>

      {/* Notes timeline */}
      {notes.length === 0 ? (
        <div className="text-center py-8 text-muted-foreground">
          <MessageSquareIcon className="mx-auto h-12 w-12 mb-3 opacity-50" />
          <p>Sin notas</p>
          <p className="text-sm">Agrega notas para recordar detalles importantes sobre esta tarea.</p>
        </div>
      ) : (
        <Timeline>
          {notes.map((note, index) => (
            <TimelineItem
              key={note.id}
              icon={<MessageSquareIcon className="h-4 w-4" />}
              title={
                <span className="flex items-center gap-2">
                  <UserIcon className="h-3 w-3" />
                  {note.user.email}
                </span>
              }
              date={formatRelativeDate(note.created_at)}
              isLast={index === notes.length - 1}
            >
              {editingId === note.id ? (
                // Edit mode
                <div className="space-y-2">
                  <Textarea
                    value={editContent}
                    onChange={(e) => setEditContent(e.target.value)}
                    rows={3}
                    className="resize-none"
                    autoFocus
                  />
                  <div className="flex gap-2">
                    <Button
                      size="sm"
                      onClick={handleSaveEdit}
                      disabled={!editContent.trim() || isUpdating}
                    >
                      {isUpdating ? 'Guardando...' : 'Guardar'}
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={handleCancelEdit}
                      disabled={isUpdating}
                    >
                      Cancelar
                    </Button>
                  </div>
                </div>
              ) : (
                // View mode
                <div className="space-y-2">
                  <p className="text-sm whitespace-pre-wrap">{note.content}</p>
                  {canModify(note) && (
                    <div className="flex gap-1">
                      <Button
                        size="sm"
                        variant="ghost"
                        className="h-7 px-2 text-muted-foreground hover:text-foreground"
                        onClick={() => handleStartEdit(note)}
                      >
                        <PencilIcon className="h-3 w-3 mr-1" />
                        Editar
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        className="h-7 px-2 text-muted-foreground hover:text-destructive"
                        onClick={() => handleDelete(note.id)}
                        disabled={deletingId === note.id}
                      >
                        <TrashIcon className="h-3 w-3 mr-1" />
                        {deletingId === note.id ? 'Eliminando...' : 'Eliminar'}
                      </Button>
                    </div>
                  )}
                </div>
              )}
            </TimelineItem>
          ))}
        </Timeline>
      )}
    </div>
  )
}
```

**Key implementation details:**
- State: `notes`, `newNote`, `isCreating`, `editingId`, `editContent`, `isUpdating`, `deletingId`
- Optimistic updates: UI updates immediately, reverts on error
- canModify: User can edit/delete if they authored the note OR isAdminOrOwner
- Confirmation dialog using window.confirm() for delete
- Toast notifications for all actions
- Empty state with MessageSquareIcon
  </action>
  <verify>
```bash
# Check component structure
grep -E "(export function TaskNotesSection|handleCreate|handleDelete|Timeline)" /mnt/c/Users/Usuario/Proyectos/morfx-new/src/components/tasks/task-notes.tsx
# Check imports
head -15 /mnt/c/Users/Usuario/Proyectos/morfx-new/src/components/tasks/task-notes.tsx
```
  </verify>
  <done>
src/components/tasks/task-notes.tsx exists with:
- TaskNotesSection component with full implementation
- handleCreate with optimistic update and error revert
- handleStartEdit, handleCancelEdit, handleSaveEdit with optimistic updates
- handleDelete with confirm dialog and optimistic update
- canModify permission check
- Timeline rendering with edit/view modes
- Empty state
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TaskHistoryTimeline component</name>
  <files>src/components/tasks/task-history.tsx</files>
  <action>
Create new file `src/components/tasks/task-history.tsx`:

```typescript
'use client'

import * as React from 'react'
import {
  PlusCircleIcon,
  PencilIcon,
  CheckCircleIcon,
  RotateCcwIcon,
  CalendarIcon,
  MessageSquareIcon,
  Trash2Icon,
  UserIcon,
} from 'lucide-react'
import { Timeline, TimelineItem, formatRelativeDate } from '@/components/ui/timeline'
import { formatTaskChanges, getTaskActionDescription } from '@/app/actions/task-activity'
import type { TaskActivityWithUser, TaskActivityAction } from '@/lib/tasks/types'

// Icon mapping for activity types
const ACTION_ICONS: Record<TaskActivityAction, typeof PlusCircleIcon> = {
  created: PlusCircleIcon,
  updated: PencilIcon,
  completed: CheckCircleIcon,
  reopened: RotateCcwIcon,
  due_date_changed: CalendarIcon,
  deleted: Trash2Icon,
  note_added: MessageSquareIcon,
  note_updated: PencilIcon,
  note_deleted: Trash2Icon,
}

// Spanish labels
const ACTION_LABELS: Record<TaskActivityAction, string> = {
  created: 'Tarea creada',
  updated: 'Tarea actualizada',
  completed: 'Tarea completada',
  reopened: 'Tarea reabierta',
  due_date_changed: 'Fecha limite cambiada',
  deleted: 'Tarea eliminada',
  note_added: 'Nota agregada',
  note_updated: 'Nota editada',
  note_deleted: 'Nota eliminada',
}

interface TaskHistoryTimelineProps {
  activities: TaskActivityWithUser[]
}

export function TaskHistoryTimeline({ activities }: TaskHistoryTimelineProps) {
  if (activities.length === 0) {
    return (
      <div className="text-center py-8 text-muted-foreground">
        <RotateCcwIcon className="mx-auto h-12 w-12 mb-3 opacity-50" />
        <p>Sin historial</p>
        <p className="text-sm">Los cambios en esta tarea apareceran aqui.</p>
      </div>
    )
  }

  return (
    <Timeline>
      {activities.map((activity, index) => {
        const Icon = ACTION_ICONS[activity.action] || PencilIcon
        const label = ACTION_LABELS[activity.action] || activity.action

        return (
          <TimelineItem
            key={activity.id}
            icon={<Icon className="h-4 w-4" />}
            title={
              <span className="flex items-center gap-2">
                {label}
                {activity.user && (
                  <span className="text-muted-foreground text-xs flex items-center gap-1">
                    <UserIcon className="h-3 w-3" />
                    {activity.user.email}
                  </span>
                )}
              </span>
            }
            date={formatRelativeDate(activity.created_at)}
            isLast={index === activities.length - 1}
          >
            {/* Show changes for update actions */}
            {activity.changes && Object.keys(activity.changes).length > 0 && (
              <ActivityChanges changes={activity.changes} />
            )}
            {/* Show note preview for note actions */}
            {activity.metadata?.preview && (
              <p className="text-sm text-muted-foreground italic">
                "{activity.metadata.preview as string}"
              </p>
            )}
          </TimelineItem>
        )
      })}
    </Timeline>
  )
}

// Helper component for displaying field changes
function ActivityChanges({ changes }: { changes: Record<string, { old: unknown; new: unknown }> }) {
  const [formatted, setFormatted] = React.useState<string[]>([])

  React.useEffect(() => {
    formatTaskChanges(changes).then(setFormatted)
  }, [changes])

  if (formatted.length === 0) return null

  return (
    <ul className="text-sm text-muted-foreground space-y-1">
      {formatted.map((change, i) => (
        <li key={i} className="font-mono text-xs">
          {change}
        </li>
      ))}
    </ul>
  )
}
```

**Features:**
- Icon per action type
- Spanish labels
- User email display (when available)
- Shows field-level changes for 'updated' actions
- Shows note preview for note actions
- Empty state
  </action>
  <verify>
```bash
# Check component
grep -E "(export function TaskHistoryTimeline|ACTION_ICONS|ActivityChanges)" /mnt/c/Users/Usuario/Proyectos/morfx-new/src/components/tasks/task-history.tsx
```
  </verify>
  <done>
src/components/tasks/task-history.tsx exists with:
- TaskHistoryTimeline component
- Icon mapping for all action types
- Spanish labels
- ActivityChanges helper for diff display
- Empty state
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate PostponementBadge into TaskItem component</name>
  <files>src/components/tasks/task-item.tsx</files>
  <action>
Modify `src/components/tasks/task-item.tsx` to show PostponementBadge in the Meta row.

**Exact integration location:** The Meta row is at lines 203-253, containing badges for task_type, due_date, assigned_user, and linked_entity. Add PostponementBadge AFTER the due_date badge (after line 222).

**Step 1:** Add import at top of file (after existing imports around line 36):
```typescript
import { PostponementBadge } from '@/components/tasks/postponement-badge'
```

**Step 2:** In the Meta row div (the `<div className="flex flex-wrap items-center gap-2 mt-2">` at line 203), add PostponementBadge after the due date badge block. Insert after line 222 (after the closing of the due date badge conditional):

```typescript
          {/* Postponement badge - shows after due date */}
          {task.postponement_count > 0 && (
            <PostponementBadge count={task.postponement_count} />
          )}
```

**Full context of where to insert (lines 216-230 after edit):**
```typescript
          {/* Due date badge */}
          {task.due_date && (
            <Badge variant="outline" className={cn('text-xs gap-1', dueDateStyle.className)}>
              <CalendarIcon className="h-3 w-3" />
              {dueDateStyle.label ? `${dueDateStyle.label} - ` : ''}
              {format(parseISO(task.due_date), 'dd MMM', { locale: es })}
            </Badge>
          )}

          {/* Postponement badge - shows after due date */}
          {task.postponement_count > 0 && (
            <PostponementBadge count={task.postponement_count} />
          )}

          {/* Assigned user */}
          {task.assigned_user && (
```

**Why this location:**
- Groups date-related information together (due date + postponement count)
- Visible at a glance in task list
- Consistent with other badge placements in Meta row
  </action>
  <verify>
```bash
# Check PostponementBadge is imported and used
grep -E "(import.*PostponementBadge|PostponementBadge)" /mnt/c/Users/Usuario/Proyectos/morfx-new/src/components/tasks/task-item.tsx
```
  </verify>
  <done>
task-item.tsx imports PostponementBadge and renders it in the Meta row after the due_date badge, showing for tasks with postponement_count > 0
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Task notes system, activity history timeline, and postponement badge components integrated into the task interface.
  </what-built>
  <how-to-verify>
1. Start the dev server if not running:
   ```bash
   cd /mnt/c/Users/Usuario/Proyectos/morfx-new && pkill -f "next dev" 2>/dev/null; sleep 2; npm run dev &
   ```

2. Navigate to http://localhost:3020/tareas

3. **Test postponement badge:**
   - Create a new task with a due date
   - Edit the task and move the due date forward (to a later date)
   - The task should now show a yellow badge with "1x"
   - Move the date forward again - badge shows "2x"
   - Move it forward a third time - badge turns red with "3x"

   Note: If the database migration hasn't been applied yet, you may need to apply it first:
   ```bash
   # If using local Supabase
   cd /mnt/c/Users/Usuario/Proyectos/morfx-new && pnpm supabase db push
   ```

4. **Verify visual appearance:**
   - Yellow badge for 1-2 postponements
   - Red badge for 3+ postponements
   - Tooltip on hover shows "Esta tarea ha sido postergada X veces"

Expected:
- Badge appears only when postponement_count > 0
- Colors match severity (yellow = warning, red = critical)
- Integration is clean and not visually cluttered
  </how-to-verify>
  <resume-signal>Type "approved" if badge displays correctly, or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. All three components exist in src/components/tasks/
2. PostponementBadge integrated into task-item.tsx (Meta row)
3. TypeScript compiles without errors
4. Human verification of badge functionality
</verification>

<success_criteria>
- PostponementBadge shows yellow for 1-2, red for 3+
- TaskNotesSection allows add/edit/delete notes
- TaskHistoryTimeline shows activity with icons and Spanish labels
- Badge visible in task list for postponed tasks
- All components follow existing UI patterns
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-task-notes-history/10.1-03-SUMMARY.md`
</output>
