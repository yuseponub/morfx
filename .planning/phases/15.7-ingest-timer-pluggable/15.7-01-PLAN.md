---
phase: 15.7-ingest-timer-pluggable
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/sandbox/types.ts
  - src/lib/sandbox/ingest-timer.ts
  - src/lib/sandbox/sandbox-engine.ts
autonomous: true

must_haves:
  truths:
    - "IngestTimerSimulator class can start, stop, pause, resume, and reevaluate timer levels"
    - "5 timer levels are defined with correct conditions, durations, and actions"
    - "SandboxEngine returns timerSignal in result instead of hardcoding timerExpiresAt: null"
    - "Timer types (TimerConfig, TimerLevelConfig, TimerState, TimerAction) are exported for consumers"
  artifacts:
    - path: "src/lib/sandbox/ingest-timer.ts"
      provides: "IngestTimerSimulator class, timer level definitions, timer config constants"
      min_lines: 150
    - path: "src/lib/sandbox/types.ts"
      provides: "TimerSignal, TimerState, TimerConfig types on SandboxEngineResult"
      contains: "timerSignal"
    - path: "src/lib/sandbox/sandbox-engine.ts"
      provides: "Timer signal propagation from IngestManager results"
      contains: "timerSignal"
  key_links:
    - from: "src/lib/sandbox/ingest-timer.ts"
      to: "src/lib/sandbox/types.ts"
      via: "import TimerConfig, TimerState types"
      pattern: "import.*types"
    - from: "src/lib/sandbox/sandbox-engine.ts"
      to: "src/lib/sandbox/types.ts"
      via: "return timerSignal in SandboxEngineResult"
      pattern: "timerSignal"
---

<objective>
Create the IngestTimerSimulator engine and type foundation for 5-level timer system, and fix the SandboxEngine to propagate timer signals instead of hardcoding null.

Purpose: This plan establishes the pure-logic timer simulation engine that will be consumed by the sandbox UI. Without this foundation, the timer remains cosmetic (current bug).

Output: New `ingest-timer.ts` with IngestTimerSimulator class, extended types in `types.ts`, and fixed `sandbox-engine.ts` that returns timer signals.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15.7-ingest-timer-pluggable/15.7-CONTEXT.md
@.planning/phases/15.7-ingest-timer-pluggable/15.7-RESEARCH.md
@src/lib/sandbox/types.ts
@src/lib/sandbox/sandbox-engine.ts
@src/lib/agents/somnio/data-extractor.ts (for CRITICAL_FIELDS, ALL_FIELDS reference - DO NOT MODIFY)
@src/lib/agents/somnio/ingest-manager.ts (for shouldEmitTimerStart, timerDuration - DO NOT MODIFY)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IngestTimerSimulator class and timer constants</name>
  <files>src/lib/sandbox/ingest-timer.ts</files>
  <action>
Create a NEW file `src/lib/sandbox/ingest-timer.ts` with the following components:

**0. VERIFICATION STEP (do first):**
Read `src/lib/agents/somnio/data-extractor.ts` and confirm the field names used in `datosCapturados`. The keys extracted are defined by `CRITICAL_FIELDS` (['nombre', 'telefono', 'direccion', 'ciudad', 'departamento']) and `ADDITIONAL_FIELDS` (['apellido', 'barrio', 'correo', 'indicaciones_extra']). The field names in `TIMER_MINIMUM_FIELDS` below MUST exactly match the keys used in `datosCapturados`. As verified: 'apellido' is in ADDITIONAL_FIELDS (extracted but not critical), so it IS a valid datosCapturados key. All 6 fields in TIMER_MINIMUM_FIELDS exist as extractable field names.

**1. Timer Field Definitions (separate from data-extractor CRITICAL_FIELDS):**
- `TIMER_MINIMUM_FIELDS`: 6 fields = ['nombre', 'apellido', 'telefono', 'direccion', 'ciudad', 'departamento']
  (Note: These names MUST match the keys in datosCapturados exactly. 'nombre', 'telefono', 'direccion', 'ciudad', 'departamento' come from CRITICAL_FIELDS; 'apellido' comes from ADDITIONAL_FIELDS.)
- `TIMER_ALL_FIELDS`: 8 fields = TIMER_MINIMUM_FIELDS + ['barrio', 'correo']
- `FIELD_LABELS`: Record mapping field names to human-readable Spanish labels (e.g., 'nombre' -> 'Nombre completo', 'direccion' -> 'Direccion completa', 'ciudad' -> 'Ciudad o municipio')

**2. Timer Level Definitions (5 levels):**
Define `TIMER_LEVELS: TimerLevelConfig[]` with 5 entries:
- Level 0 "Sin datos": mode=collecting_data, totalFields=0, 600s default. Action: send_message "Quedamos pendientes a tus datos, o si tienes alguna pregunta acerca del producto no dudes en hacerla"
- Level 1 "Datos parciales": mode=collecting_data, has fields but not all 6 minimum. 360s default. Action: send_message with dynamic missing fields list using FIELD_LABELS
- Level 2 "Datos minimos": mode=collecting_data, has all 6 minimum fields. 120s default. Action: transition_mode to 'ofrecer_promos' (NO message - silent)
- Level 3 "Promos sin respuesta": mode=ofrecer_promos, no packSeleccionado. 600s default. Action: create_order with message + valor=0
- Level 4 "Pack sin confirmar": mode=ofrecer_promos, has packSeleccionado. 600s default. Action: create_order with message + pack

Each level has an `evaluate(ctx: TimerEvalContext) => boolean` function. Levels are evaluated in order 0-4, first match wins.

**3. Timer Preset Configs:**
```typescript
const TIMER_PRESETS: Record<TimerPreset, TimerConfig> = {
  real: { levels: { 0: 600, 1: 360, 2: 120, 3: 600, 4: 600 } },
  rapido: { levels: { 0: 60, 1: 30, 2: 10, 3: 60, 4: 60 } },
  instantaneo: { levels: { 0: 2, 1: 2, 2: 1, 3: 2, 4: 2 } },
}
```
Export `TIMER_PRESETS` and `TIMER_DEFAULTS` (same as 'real' preset).

**4. IngestTimerSimulator class:**
Pure logic class (no React dependencies). Uses `setTimeout` for expiration and `setInterval` for tick updates.

Constructor takes callbacks:
- `onTick: (remainingMs: number, level: number) => void` - called every 1000ms
- `onExpire: (level: number, action: TimerAction) => void` - called when timer reaches 0

Methods:
- `start(level: number, durationMs: number)`: Clear existing timers, start new countdown. Store startedAt, durationMs, currentLevel.
- `stop()`: Clear all timers, reset state.
- `pause()`: Store remaining time, clear timers. Set paused flag.
- `resume()`: Resume from stored remaining time.
- `reevaluateLevel(context: TimerEvalContext, config: TimerConfig)`: Evaluate which level applies. If level changed, restart with new level's duration. If same level, continue counting. If no level matches, stop timer.
- `evaluateLevel(context: TimerEvalContext): number | null`: Find first matching level (0-4). Returns level id or null.
- `getState(): TimerState`: Return current timer state snapshot.
- `destroy()`: Clean up all intervals/timeouts (for unmount).

**Important implementation details:**
- Store timer state in instance properties (NOT in closure of setTimeout) to avoid stale closure pitfall.
- When `reevaluateLevel` detects a level change, calculate elapsed time and start new timer with: `newDuration - elapsedTime` if new duration > elapsed, otherwise fire immediately.
- When `reevaluateLevel` detects same level, do nothing (timer continues).
- `evaluateLevel` iterates TIMER_LEVELS in order, returns first where `evaluate(ctx)` returns true.

**5. Export all types and constants:**
Export: `IngestTimerSimulator`, `TIMER_LEVELS`, `TIMER_PRESETS`, `TIMER_DEFAULTS`, `TIMER_MINIMUM_FIELDS`, `TIMER_ALL_FIELDS`, `FIELD_LABELS`, and all relevant types.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. File should export IngestTimerSimulator class and all constants without compilation errors.
  </verify>
  <done>
IngestTimerSimulator class exists with start/stop/pause/resume/reevaluateLevel/evaluateLevel/getState/destroy methods. 5 timer levels defined with correct conditions and actions. 3 presets (real/rapido/instantaneo) with 5 level durations each. TIMER_MINIMUM_FIELDS has 6 fields (including apellido, separate from CRITICAL_FIELDS).
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend sandbox types with timer signal and timer state types</name>
  <files>src/lib/sandbox/types.ts</files>
  <action>
Extend `src/lib/sandbox/types.ts` with the following additions:

**1. Add TimerSignal to SandboxEngineResult:**
```typescript
export interface TimerSignal {
  type: 'start' | 'reevaluate' | 'cancel'
  /** Suggested timer level (from IngestManager analysis) */
  suggestedLevel?: number
  /** Reason for cancel signal */
  reason?: string
}
```

Add `timerSignal?: TimerSignal` field to the existing `SandboxEngineResult` interface.

**2. Add TimerState type (for UI consumption):**
```typescript
export interface TimerState {
  active: boolean
  level: number | null
  levelName: string
  remainingMs: number
  paused: boolean
}
```

**3. Add TimerConfig type:**
```typescript
export interface TimerConfig {
  levels: Record<number, number>  // levelId -> seconds
}
```

**4. Add TimerAction type:**
```typescript
export interface TimerAction {
  type: 'send_message' | 'transition_mode' | 'create_order'
  message?: string
  targetMode?: string
  orderConfig?: { valor: number; pack?: string }
}
```

**5. Add TimerEvalContext type:**
```typescript
export interface TimerEvalContext {
  fieldsCollected: string[]
  totalFields: number
  currentMode: string
  packSeleccionado: string | null
  promosOffered: boolean
}
```

**6. Add TimerLevelConfig type:**
```typescript
export interface TimerLevelConfig {
  id: number
  name: string
  defaultDurationS: number
  evaluate: (ctx: TimerEvalContext) => boolean
  buildAction: (ctx: TimerEvalContext) => TimerAction
}
```

**7. Add TimerPreset type:**
```typescript
export type TimerPreset = 'real' | 'rapido' | 'instantaneo'
```

Place all timer-related types in a clearly marked section: `// Timer Types (Phase 15.7)`.

Do NOT remove or modify any existing types. Only add new types and the `timerSignal` field to `SandboxEngineResult`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. The existing `SandboxEngineResult` now has an optional `timerSignal` field. All timer types are exported.
  </verify>
  <done>
SandboxEngineResult has `timerSignal?: TimerSignal`. TimerSignal, TimerState, TimerConfig, TimerAction, TimerEvalContext, TimerLevelConfig, TimerPreset types all exported from types.ts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix SandboxEngine to propagate timer signals</name>
  <files>src/lib/sandbox/sandbox-engine.ts</files>
  <action>
Fix `sandbox-engine.ts` to propagate timer signals from IngestManager instead of hardcoding `timerExpiresAt: null`.

**Step 1: Add class-level timer signal property:**
Add `private lastTimerSignal: TimerSignal | null = null` to the SandboxEngine class. Import `TimerSignal` from `./types`.

**Step 2: Reset at start of processMessage:**
At the beginning of `processMessage`, add: `this.lastTimerSignal = null`.

**Step 3: Set timer signals in handleIngestMode:**
After calling `this.ingestManager.handleMessage(...)`, determine the timer signal based on the ingest result:

- For `'silent'` action WITH `shouldEmitTimerStart === true` (first data arrival):
  Return the SandboxEngineResult with `timerSignal: { type: 'start' }`.

- For `'silent'` action WITHOUT `shouldEmitTimerStart` (subsequent data, not first):
  Return the SandboxEngineResult with `timerSignal: { type: 'reevaluate' }`.

- For `'complete'` action (all fields collected, returns null to continue orchestrator flow):
  Set `this.lastTimerSignal = { type: 'cancel', reason: 'ingest_complete' }`.
  Do NOT return a result here (null return continues to orchestrator).

- For `'respond'` action (pregunta detected):
  Do NOT set any timer signal. Questions do not affect the timer.

**Step 4: Set timer signal in checkImplicitYes:**
When implicit yes triggers collecting_data mode with first data, include `timerSignal: { type: 'start' }` in the returned SandboxEngineResult.

**Step 5: Propagate in final processMessage return:**
In the final return of `processMessage` (around line 347), include:
`timerSignal: this.lastTimerSignal ?? undefined`

Keep `timerExpiresAt: null` for backward compatibility (the new timer display reads from TimerState, not timerExpiresAt). Remove the "Timer simulation not needed" comment.

**Do NOT modify:**
- IngestManager (it already returns shouldEmitTimerStart correctly)
- The orchestrator flow
- CRM agent routing
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Verify that the result type includes `timerSignal` by checking the return statements contain the field.
  </verify>
  <done>
SandboxEngine returns `timerSignal` in SandboxEngineResult for: (1) 'start' when first data arrives in collecting_data, (2) 'reevaluate' when subsequent data arrives, (3) 'cancel' when ingest completes (all 8 fields). Questions do not produce timer signals. The timerExpiresAt field remains null for backward compatibility.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `IngestTimerSimulator` class can be instantiated and called without errors
3. `SandboxEngineResult` has `timerSignal` field
4. All 5 timer levels defined with evaluate/buildAction functions
5. TIMER_MINIMUM_FIELDS has 6 fields (nombre, apellido, telefono, direccion, ciudad, departamento)
6. TIMER_PRESETS has 3 presets with 5 levels each
</verification>

<success_criteria>
- IngestTimerSimulator is a pure-logic class with no React dependencies
- 5 timer levels with correct conditions matching CONTEXT.md specifications
- SandboxEngine propagates timer signals (start/reevaluate/cancel) from IngestManager results
- All types exported and usable by consumers (Plan 02)
- No changes to production code (ingest-manager.ts, somnio-engine.ts, agent-timers.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/15.7-ingest-timer-pluggable/15.7-01-SUMMARY.md`
</output>
