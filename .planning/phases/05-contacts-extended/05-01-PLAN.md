---
phase: 05-contacts-extended
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260129000002_custom_fields_notes_activity.sql
  - src/lib/types/database.ts
  - src/lib/custom-fields/types.ts
autonomous: true

must_haves:
  truths:
    - "custom_field_definitions table exists with workspace isolation"
    - "contacts table has custom_fields JSONB column with GIN index"
    - "contact_notes table exists with workspace visibility RLS"
    - "contact_activity table captures all contact changes via trigger"
    - "Activity trigger calculates JSONB diff for field changes"
  artifacts:
    - path: "supabase/migrations/20260129000002_custom_fields_notes_activity.sql"
      provides: "Database schema for custom fields, notes, activity"
      contains: "CREATE TABLE custom_field_definitions"
    - path: "src/lib/custom-fields/types.ts"
      provides: "TypeScript types for custom field system"
      exports: ["FieldType", "CustomFieldDefinition"]
    - path: "src/lib/types/database.ts"
      provides: "Extended Contact type with custom_fields"
      contains: "custom_fields"
  key_links:
    - from: "contact_activity_trigger"
      to: "contacts table"
      via: "AFTER INSERT OR UPDATE OR DELETE trigger"
      pattern: "EXECUTE FUNCTION log_contact_changes"
---

<objective>
Create database foundation for Phase 5: custom field definitions table, JSONB custom_fields column on contacts, contact notes table, and activity history with PostgreSQL trigger for automatic change tracking.

Purpose: All Phase 5 features (custom fields, notes, activity, import/export) depend on this database schema being in place.
Output: Single migration file with all tables, triggers, indexes, and RLS policies. TypeScript types for the new structures.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-contacts-extended/05-RESEARCH.md
@supabase/migrations/20260129000001_contacts_and_tags.sql
@src/lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for custom fields system</name>
  <files>src/lib/custom-fields/types.ts, src/lib/types/database.ts</files>
  <action>
Create src/lib/custom-fields/types.ts with:

1. FieldType union type with all 12 supported types:
   - text, number, date, select, checkbox, url, email, phone, currency, percentage, file, contact_relation

2. CustomFieldDefinition interface:
   - id: string (UUID)
   - workspace_id: string
   - name: string (display name like "Fecha de cumpleanos")
   - key: string (storage key like "fecha_cumpleanos")
   - field_type: FieldType
   - options?: string[] (for select type)
   - is_required: boolean
   - display_order: number
   - created_at: string

3. ContactNote interface:
   - id: string
   - contact_id: string
   - workspace_id: string
   - user_id: string
   - content: string
   - created_at: string
   - updated_at: string

4. ContactActivity interface:
   - id: string
   - contact_id: string
   - workspace_id: string
   - user_id: string | null
   - action: 'created' | 'updated' | 'deleted' | 'note_added' | 'note_updated' | 'note_deleted' | 'tag_added' | 'tag_removed'
   - changes: Record<string, { old: unknown; new: unknown }> | null
   - metadata: Record<string, unknown> | null
   - created_at: string

5. ContactActivityWithUser extends ContactActivity with user profile info for display

Update src/lib/types/database.ts:
- Add custom_fields: Record<string, unknown> to Contact type
- Export the new types from custom-fields/types.ts
  </action>
  <verify>TypeScript compiles: `cd morfx && pnpm exec tsc --noEmit`</verify>
  <done>Types exist and compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create database migration for custom fields, notes, and activity</name>
  <files>supabase/migrations/20260129000002_custom_fields_notes_activity.sql</files>
  <action>
Create migration with:

1. **custom_field_definitions table:**
```sql
CREATE TABLE custom_field_definitions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  key TEXT NOT NULL,
  field_type TEXT NOT NULL,
  options JSONB,
  is_required BOOLEAN DEFAULT false,
  display_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT timezone('America/Bogota', NOW()),
  UNIQUE(workspace_id, key)
);
```

2. **Add custom_fields column to contacts:**
```sql
ALTER TABLE contacts ADD COLUMN IF NOT EXISTS custom_fields JSONB DEFAULT '{}';
CREATE INDEX IF NOT EXISTS idx_contacts_custom_fields ON contacts USING GIN (custom_fields);
```

3. **contact_notes table:**
```sql
CREATE TABLE contact_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT timezone('America/Bogota', NOW()),
  updated_at TIMESTAMPTZ DEFAULT timezone('America/Bogota', NOW())
);
```

4. **contact_activity table:**
```sql
CREATE TABLE contact_activity (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contact_id UUID NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  action TEXT NOT NULL,
  changes JSONB,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT timezone('America/Bogota', NOW())
);
```

5. **Indexes:**
```sql
CREATE INDEX idx_custom_fields_workspace ON custom_field_definitions(workspace_id);
CREATE INDEX idx_notes_contact ON contact_notes(contact_id);
CREATE INDEX idx_notes_created ON contact_notes(created_at DESC);
CREATE INDEX idx_activity_contact ON contact_activity(contact_id);
CREATE INDEX idx_activity_created ON contact_activity(created_at DESC);
```

6. **Activity trigger function** (SECURITY DEFINER):
```sql
CREATE OR REPLACE FUNCTION log_contact_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  changes_json JSONB := '{}';
  old_json JSONB;
  new_json JSONB;
  key TEXT;
  user_uuid UUID;
BEGIN
  -- Get current user from JWT (may be null for direct DB operations)
  BEGIN
    user_uuid := (auth.jwt() ->> 'sub')::UUID;
  EXCEPTION WHEN OTHERS THEN
    user_uuid := NULL;
  END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO contact_activity (contact_id, workspace_id, user_id, action, changes)
    VALUES (NEW.id, NEW.workspace_id, user_uuid, 'created', to_jsonb(NEW));
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    old_json := to_jsonb(OLD);
    new_json := to_jsonb(NEW);

    FOR key IN SELECT jsonb_object_keys(new_json)
    LOOP
      -- Skip updated_at to avoid noise
      IF key != 'updated_at' AND old_json -> key IS DISTINCT FROM new_json -> key THEN
        changes_json := changes_json || jsonb_build_object(
          key, jsonb_build_object('old', old_json -> key, 'new', new_json -> key)
        );
      END IF;
    END LOOP;

    IF changes_json != '{}' THEN
      INSERT INTO contact_activity (contact_id, workspace_id, user_id, action, changes)
      VALUES (NEW.id, NEW.workspace_id, user_uuid, 'updated', changes_json);
    END IF;
    RETURN NEW;
  END IF;

  IF TG_OP = 'DELETE' THEN
    INSERT INTO contact_activity (contact_id, workspace_id, user_id, action, changes)
    VALUES (OLD.id, OLD.workspace_id, user_uuid, 'deleted', to_jsonb(OLD));
    RETURN OLD;
  END IF;
END;
$$;

CREATE TRIGGER contact_activity_trigger
  AFTER INSERT OR UPDATE OR DELETE ON contacts
  FOR EACH ROW
  EXECUTE FUNCTION log_contact_changes();
```

7. **RLS policies:**

For custom_field_definitions:
- SELECT: workspace_id matches user's workspace
- INSERT/UPDATE/DELETE: user is owner or admin in workspace

For contact_notes:
- SELECT: workspace_id matches user's workspace (all members see all notes)
- INSERT: workspace member can create
- UPDATE/DELETE: author OR admin/owner can modify

For contact_activity:
- SELECT: workspace_id matches user's workspace
- No INSERT/UPDATE/DELETE via RLS (trigger-managed)

Use the same workspace membership pattern from Phase 2:
```sql
EXISTS (
  SELECT 1 FROM workspace_members wm
  WHERE wm.workspace_id = TABLE.workspace_id
  AND wm.user_id = auth.uid()
)
```
  </action>
  <verify>Migration syntax is valid SQL (no runtime errors on parse)</verify>
  <done>Migration file exists with all tables, triggers, indexes, and RLS policies</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd morfx && pnpm exec tsc --noEmit`
2. Migration file contains all 4 tables: custom_field_definitions, contact_notes, contact_activity, plus ALTER TABLE contacts
3. Trigger function log_contact_changes() exists in migration
4. GIN index on contacts.custom_fields exists
5. RLS policies follow workspace isolation pattern
</verification>

<success_criteria>
- custom_field_definitions table defined with workspace isolation
- contacts.custom_fields JSONB column with GIN index
- contact_notes table with workspace-visible, author-editable RLS
- contact_activity table with trigger for automatic change capture
- Activity trigger calculates JSONB diff and filters out updated_at noise
- All TypeScript types defined and compile
</success_criteria>

<output>
After completion, create `.planning/phases/05-contacts-extended/05-01-SUMMARY.md`
</output>
