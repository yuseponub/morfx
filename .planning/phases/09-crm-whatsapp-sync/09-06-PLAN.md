---
phase: 09-crm-whatsapp-sync
plan: 06
type: execute
wave: 4
depends_on: ["09-04", "09-05"]
files_modified:
  - src/app/(dashboard)/whatsapp/components/conversation-list.tsx
  - src/app/(dashboard)/whatsapp/components/inbox-layout.tsx
  - src/hooks/use-conversations.ts
autonomous: true

must_haves:
  truths:
    - "Conversation list loads order data for indicators"
    - "Order indicators display for conversations with linked contacts"
    - "Realtime updates work for conversation tag changes"
    - "Performance is acceptable with order data loading"
  artifacts:
    - path: "src/app/(dashboard)/whatsapp/components/conversation-list.tsx"
      provides: "Conversation list with order data"
      contains: "orders"
    - path: "src/hooks/use-conversations.ts"
      provides: "Hook with order data loading"
      contains: "getOrdersForContacts"
  key_links:
    - from: "useConversations"
      to: "getOrdersForContacts"
      via: "batch order loading"
      pattern: "getOrdersForContacts"
    - from: "conversation_tags channel"
      to: "fetchConversations"
      via: "realtime subscription"
      pattern: "conversation_tags"
---

<objective>
Wire up order data loading and realtime sync for the conversation list.

Purpose: This plan connects the order data to the conversation list UI, adds realtime subscriptions for conversation_tags changes, and ensures the UI stays synchronized when data changes in either CRM or WhatsApp modules.

Output: Updated conversation list with order indicators, realtime subscription for tag changes, batch order loading.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-crm-whatsapp-sync/09-CONTEXT.md
@.planning/phases/09-crm-whatsapp-sync/09-RESEARCH.md
@.planning/phases/09-crm-whatsapp-sync/09-04-SUMMARY.md
@.planning/phases/09-crm-whatsapp-sync/09-05-SUMMARY.md

# Existing components
@src/hooks/use-conversations.ts
@src/app/(dashboard)/whatsapp/components/conversation-list.tsx
@src/app/(dashboard)/whatsapp/components/inbox-layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update useConversations hook with order loading and tag sync</name>
  <files>src/hooks/use-conversations.ts</files>
  <action>
Update the useConversations hook to:
1. Load orders for all contacts in batch after conversations load
2. Add realtime subscription for conversation_tags changes
3. Return orders data mapped by contact ID

Add imports at top:
```typescript
import { getOrdersForContacts } from '@/app/actions/whatsapp'
import type { OrderSummary } from '@/lib/whatsapp/types'
```

Update the return type interface:
```typescript
interface UseConversationsReturn {
  /** All conversations (filtered by search and status) */
  conversations: ConversationWithDetails[]
  /** Orders mapped by contact ID */
  ordersByContact: Map<string, OrderSummary[]>
  /** Search query */
  query: string
  /** Update search query */
  setQuery: (query: string) => void
  /** Filter status */
  filter: ConversationFilter
  /** Update filter */
  setFilter: (filter: ConversationFilter) => void
  /** Loading state */
  isLoading: boolean
  /** Loading orders state */
  isLoadingOrders: boolean
  /** Whether there's an active search */
  hasQuery: boolean
  /** Refresh conversations */
  refresh: () => Promise<void>
  /** Get a specific conversation by ID (always returns latest data) */
  getConversationById: (id: string) => ConversationWithDetails | undefined
}
```

Add state for orders:
```typescript
const [ordersByContact, setOrdersByContact] = useState<Map<string, OrderSummary[]>>(new Map())
const [isLoadingOrders, setIsLoadingOrders] = useState(false)
```

Add a useEffect to load orders after conversations are loaded:
```typescript
// Load orders for all contacts in batch
useEffect(() => {
  async function loadOrders() {
    // Get unique contact IDs from conversations
    const contactIds = conversations
      .map(c => c.contact?.id)
      .filter((id): id is string => !!id)

    if (contactIds.length === 0) {
      setOrdersByContact(new Map())
      return
    }

    // Deduplicate
    const uniqueContactIds = [...new Set(contactIds)]

    setIsLoadingOrders(true)
    try {
      const orders = await getOrdersForContacts(uniqueContactIds)
      setOrdersByContact(orders)
    } catch (error) {
      console.error('Error loading orders:', error)
    } finally {
      setIsLoadingOrders(false)
    }
  }

  // Only load orders after initial conversations load
  if (!isLoading && conversations.length > 0) {
    loadOrders()
  }
}, [conversations, isLoading])
```

Update the Supabase Realtime subscription to also listen to conversation_tags:
```typescript
// Set up Supabase Realtime subscriptions
useEffect(() => {
  if (!workspaceId) return

  const supabase = createClient()

  // Subscribe to conversations table changes
  const conversationsChannel = supabase
    .channel(`conversations:${workspaceId}`)
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'conversations',
        filter: `workspace_id=eq.${workspaceId}`,
      },
      async () => {
        console.log('Conversation change received')
        await fetchConversations()
      }
    )
    .subscribe()

  // Subscribe to conversation_tags changes (for tag sync)
  const tagsChannel = supabase
    .channel(`conversation_tags:${workspaceId}`)
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'conversation_tags',
      },
      async () => {
        console.log('Conversation tags change received')
        await fetchConversations()
      }
    )
    .subscribe()

  // Subscribe to contact_tags changes (for inherited tag sync)
  const contactTagsChannel = supabase
    .channel(`contact_tags:${workspaceId}`)
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'contact_tags',
      },
      async () => {
        console.log('Contact tags change received')
        await fetchConversations()
      }
    )
    .subscribe()

  // Cleanup on unmount
  return () => {
    supabase.removeChannel(conversationsChannel)
    supabase.removeChannel(tagsChannel)
    supabase.removeChannel(contactTagsChannel)
  }
}, [workspaceId, fetchConversations])
```

Update return statement:
```typescript
return {
  conversations: filteredConversations,
  ordersByContact,
  query,
  setQuery,
  filter,
  setFilter,
  isLoading,
  isLoadingOrders,
  hasQuery: query.trim().length > 0,
  refresh: fetchConversations,
  getConversationById,
}
```

Note: The subscription to conversation_tags may not filter by workspace directly since it's a junction table without workspace_id. It will receive all changes but the actual data fetch respects RLS.
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/hooks/use-conversations.ts
```
  </verify>
  <done>
useConversations hook loads orders in batch, returns ordersByContact map, and subscribes to tag changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ConversationList to pass orders to items</name>
  <files>src/app/(dashboard)/whatsapp/components/conversation-list.tsx</files>
  <action>
Update the ConversationList component to receive and pass orders data to ConversationItem.

Update the component props:
```typescript
import type { OrderSummary } from '@/lib/whatsapp/types'

interface ConversationListProps {
  conversations: ConversationWithDetails[]
  ordersByContact: Map<string, OrderSummary[]>
  selectedId: string | null
  onSelect: (id: string) => void
  isLoading?: boolean
}
```

Update the component to pass orders to each ConversationItem:
```typescript
export function ConversationList({
  conversations,
  ordersByContact,
  selectedId,
  onSelect,
  isLoading = false,
}: ConversationListProps) {
  if (isLoading) {
    return (
      <div className="p-4 space-y-3">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="h-20 bg-muted/50 rounded animate-pulse" />
        ))}
      </div>
    )
  }

  if (conversations.length === 0) {
    return (
      <div className="flex-1 flex items-center justify-center p-4">
        <p className="text-sm text-muted-foreground text-center">
          No hay conversaciones
        </p>
      </div>
    )
  }

  return (
    <div className="flex-1 overflow-y-auto">
      {conversations.map((conversation) => {
        // Get orders for this conversation's contact
        const contactOrders = conversation.contact?.id
          ? ordersByContact.get(conversation.contact.id) || []
          : []

        return (
          <ConversationItem
            key={conversation.id}
            conversation={conversation}
            isSelected={selectedId === conversation.id}
            onSelect={onSelect}
            orders={contactOrders}
          />
        )
      })}
    </div>
  )
}
```

Import OrderSummary type:
```typescript
import type { ConversationWithDetails, OrderSummary } from '@/lib/whatsapp/types'
```
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/app/\\(dashboard\\)/whatsapp/components/conversation-list.tsx
```
  </verify>
  <done>
ConversationList passes ordersByContact to ConversationItem components.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update InboxLayout to wire orders data</name>
  <files>src/app/(dashboard)/whatsapp/components/inbox-layout.tsx</files>
  <action>
Update the InboxLayout to receive ordersByContact from useConversations and pass it to ConversationList.

Find where useConversations is called and destructure the new values:
```typescript
const {
  conversations,
  ordersByContact,
  query,
  setQuery,
  filter,
  setFilter,
  isLoading,
  isLoadingOrders,
  refresh,
  getConversationById,
} = useConversations({ workspaceId, initialConversations })
```

Pass ordersByContact to ConversationList:
```typescript
<ConversationList
  conversations={conversations}
  ordersByContact={ordersByContact}
  selectedId={selectedConversationId}
  onSelect={handleSelectConversation}
  isLoading={isLoading}
/>
```

Also update the ContactPanel onConversationUpdated to trigger refresh:
```typescript
<ContactPanel
  conversation={selectedConversation}
  onClose={() => setShowContactPanel(false)}
  onConversationUpdated={refresh}
/>
```

This ensures when orders are created from the contact panel, the order indicators update.
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/app/\\(dashboard\\)/whatsapp/components/inbox-layout.tsx
```
  </verify>
  <done>
InboxLayout wires ordersByContact from hook to ConversationList and refresh callback to ContactPanel.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Conversation list shows order indicators for contacts with orders
3. Creating an order updates the indicator
4. Adding/removing tags updates UI via realtime
5. No performance issues with batch loading
</verification>

<success_criteria>
- Order indicators appear in conversation list
- Orders load efficiently in batch
- Realtime updates work for conversation_tags and contact_tags
- UI stays synchronized across CRM and WhatsApp
- Performance remains acceptable with order data
</success_criteria>

<output>
After completion, create `.planning/phases/09-crm-whatsapp-sync/09-06-SUMMARY.md`
</output>
