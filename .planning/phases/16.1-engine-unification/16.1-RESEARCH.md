# Phase 16.1: Engine Unification - Research

**Researched:** 2026-02-10
**Domain:** Internal refactoring — Ports/Adapters pattern for engine unification
**Confidence:** HIGH

## Summary

This phase unifies two engines — `SandboxEngine` (681 lines) and `SomnioEngine` (844 lines) — into a single engine with adapter-based I/O. The research domain is entirely internal to this codebase: no new libraries, no external APIs, no new frameworks. The task is a structural refactoring using the Ports & Adapters (Hexagonal Architecture) pattern.

Both engines follow the same core flow: classify message -> handle ingest mode -> check implicit yes -> detect intent -> orchestrate response -> handle orders -> emit timer signals/events -> return result. The differences are exclusively in I/O: how state is read/written, how messages are dispatched, how timer signals are communicated, how orders are created, and what debug information is returned.

**Primary recommendation:** Create a single `UnifiedEngine` class that receives 5 adapter interfaces via its constructor. The agent logic (Somnio flow) lives in a `SomnioAgent` class that receives adapters and produces output. The engine is a thin runner that connects input to agent to adapters. Sandbox and production callers each construct the engine with their respective adapter implementations.

## Standard Stack

No new libraries needed. This is a pure TypeScript refactoring using dependency injection via interfaces.

### Core
| Component | Location | Purpose | Why Standard |
|-----------|----------|---------|--------------|
| TypeScript interfaces | New adapter types file | Define adapter contracts | Already the project pattern |
| Constructor injection | UnifiedEngine constructor | Wire adapters at creation time | Simplest DI, no framework needed |
| Existing Somnio components | `src/lib/agents/somnio/*` | Business logic (unchanged) | Already working, battle-tested |

### Supporting
| Component | Location | Purpose | When to Use |
|-----------|----------|---------|-------------|
| SandboxEngine (backup) | `src/lib/sandbox/sandbox-engine.ts` | Rollback if unification breaks | Keep until Phase 17 |
| SomnioEngine (backup) | `src/lib/agents/somnio/somnio-engine.ts` | Rollback if unification breaks | Keep until Phase 17 |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Constructor DI | tsyringe/inversify | Overkill for 5 adapters, adds dependency |
| Interface adapters | Abstract base classes | Interfaces are lighter, TypeScript-idiomatic |
| Unified agent interface | Keep Somnio-specific | Decision: engine is generic, agent is Somnio-specific (CONTEXT.md) |

## Architecture Patterns

### Recommended Project Structure
```
src/lib/agents/
├── engine/                    # NEW: Unified engine
│   ├── types.ts               # Adapter interfaces, EngineConfig, EngineInput, EngineOutput
│   ├── unified-engine.ts      # UnifiedEngine class (thin runner)
│   └── index.ts               # Barrel export
├── engine-adapters/           # NEW: Adapter implementations
│   ├── sandbox/               # In-memory adapters
│   │   ├── storage.ts         # SandboxStorageAdapter
│   │   ├── timer.ts           # SandboxTimerAdapter (returns TimerSignal)
│   │   ├── messaging.ts       # SandboxMessagingAdapter (returns string[])
│   │   ├── orders.ts          # SandboxOrdersAdapter (CrmOrchestrator)
│   │   ├── debug.ts           # SandboxDebugAdapter (returns DebugTurn)
│   │   └── index.ts           # createSandboxAdapters() factory
│   ├── production/            # DB/WhatsApp adapters
│   │   ├── storage.ts         # ProductionStorageAdapter (SessionManager)
│   │   ├── timer.ts           # ProductionTimerAdapter (Inngest events)
│   │   ├── messaging.ts       # ProductionMessagingAdapter (MessageSequencer)
│   │   ├── orders.ts          # ProductionOrdersAdapter (OrderCreator)
│   │   ├── debug.ts           # ProductionDebugAdapter (logger only)
│   │   └── index.ts           # createProductionAdapters() factory
│   └── index.ts               # Re-exports
├── somnio/
│   ├── somnio-agent.ts        # NEW: SomnioAgent class (extracted business logic)
│   ├── somnio-engine.ts       # BACKUP: Old engine (renamed, not deleted)
│   ├── ... (other files unchanged)
├── production/
│   ├── webhook-processor.ts   # MODIFIED: uses UnifiedEngine + production adapters
│   ├── ... (other files unchanged)
└── ...

src/lib/sandbox/
├── sandbox-engine.ts          # BACKUP: Old engine (renamed, not deleted)
├── ... (other files unchanged)

src/app/api/sandbox/process/
├── route.ts                   # MODIFIED: uses UnifiedEngine + sandbox adapters
```

### Pattern 1: Adapter Interfaces (5 Ports)

**What:** Define 5 TypeScript interfaces that abstract I/O differences between sandbox and production.

**When to use:** Whenever an operation differs between environments (state access, message dispatch, timer signals, order creation, debug output).

**Contracts:**

```typescript
// Source: CONTEXT.md decisions

// 1. Storage Adapter
interface StorageAdapter {
  /** Read session state. Sandbox returns in-memory; Production reads DB */
  getState(sessionId: string): Promise<AgentSessionLike>
  /** Save state updates. Sandbox returns new state; Production writes DB */
  saveState(sessionId: string, updates: StateUpdates): Promise<void>
  /** Record a conversation turn (production only writes to DB, sandbox is a no-op) */
  addTurn(params: TurnParams): Promise<void>
  /** Add intent to intents_vistos */
  addIntentSeen(sessionId: string, intent: string): Promise<void>
  /** Handle handoff */
  handoff(sessionId: string): Promise<void>
}

// 2. Timer Adapter
interface TimerAdapter {
  /** Signal timer action. Sandbox accumulates signals; Production emits Inngest events */
  signal(signal: TimerSignalData): Promise<void>
  /** Emit customer message event (for timer cancellation in production) */
  onCustomerMessage?(sessionId: string, conversationId: string, content: string): Promise<void>
  /** Emit mode transition events (for timer workflows in production) */
  onModeTransition?(sessionId: string, previousMode: string, newMode: string, context: ModeTransitionContext): Promise<void>
}

// 3. Messaging Adapter
interface MessagingAdapter {
  /** Send response messages. Sandbox collects strings; Production uses MessageSequencer */
  send(messages: MessagePayload[]): Promise<MessagingResult>
}

// 4. Orders Adapter
interface OrdersAdapter {
  /** Create order. Sandbox uses CrmOrchestrator; Production uses OrderCreator */
  createOrder(data: OrderData, mode: OrderMode): Promise<OrderResult>
}

// 5. Debug Adapter
interface DebugAdapter {
  /** Record debug info. Sandbox builds DebugTurn; Production logs only */
  recordTurn(info: DebugInfo): void
  /** Get accumulated debug for this turn */
  getDebugTurn(): DebugTurnLike | undefined
}
```

### Pattern 2: AgentSessionLike (Shared State Shape)

**What:** A common interface that both sandbox in-memory state and production DB session can satisfy. This is the key abstraction that eliminates the mock session building pattern.

**Why critical:** Currently, SandboxEngine builds a mock session object at line ~226-257 to satisfy the orchestrator's `AgentSessionWithState` parameter. The unified engine needs a state shape that both environments can produce naturally.

```typescript
// The "session" as seen by the agent logic
interface AgentSessionLike {
  id: string
  agent_id: string
  conversation_id: string
  contact_id: string
  workspace_id: string
  version: number
  status: 'active' | 'paused' | 'closed' | 'handed_off'
  current_mode: string
  state: SessionStateLike
}

// Shared state shape
interface SessionStateLike {
  session_id: string
  intents_vistos: IntentRecord[]
  templates_enviados: string[]
  datos_capturados: Record<string, string>
  pack_seleccionado: PackSelection | null
  proactive_started_at: string | null
  first_data_at: string | null
  min_data_at: string | null
  ofrecer_promos_at: string | null
  updated_at: string
}
```

### Pattern 3: UnifiedEngine as Thin Runner

**What:** The engine class is minimal — it receives input + adapters, calls the agent, and routes adapter I/O. All business logic stays in the Somnio components.

```typescript
class UnifiedEngine {
  constructor(
    private adapters: EngineAdapters,
    private config: EngineConfig
  ) {}

  async processMessage(input: EngineInput): Promise<EngineOutput> {
    // 1. Storage: read state
    // 2. Agent: process (ingest, intent, orchestrate)
    // 3. Storage: save state
    // 4. Timer: signal
    // 5. Messaging: send
    // 6. Orders: create if needed
    // 7. Debug: record
    // 8. Return output
  }
}
```

### Pattern 4: EngineConfig (Environment-Specific Settings)

**What:** Configuration object that the caller injects. Replaces hardcoded values and allows independent sandbox/production tuning.

```typescript
interface EngineConfig {
  /** Timer durations per level (L0-L4) in seconds */
  timerDurations: Record<number, number>
  /** Response speed multiplier (1.0 = normal) */
  responseSpeed: number
  /** CRM agent modes (enable/disable + dry-run/live) */
  crmModes?: CrmModeConfig[]
  /** Workspace ID for DB operations */
  workspaceId: string
}
```

### Anti-Patterns to Avoid

- **Agent logic in engine:** The engine must NOT contain intent detection, ingest classification, orchestration, template selection, or data extraction. These live in the agent (Somnio components). The engine only connects I/O.
- **Environment-specific if/else in engine:** Never `if (isSandbox) { ... } else { ... }` in the engine. All environment differences must be behind adapter interfaces.
- **Premature agent abstraction:** Do not create an `Agent` interface that all agents must implement. CONTEXT.md explicitly says future agents may have completely different architectures. Only create the abstraction when there are 2+ agents with enough commonality.
- **Breaking mock session building:** The SandboxStorageAdapter must produce the same session shape that the orchestrator expects. The `intentsVistos BEFORE current intent` pattern (line 226-257 of sandbox-engine) must be preserved in the storage adapter, NOT moved into the engine.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Dependency injection | DI container | Constructor params | Only 5 deps, framework is overkill |
| State transformation | Custom serializer | Shared interface type | TypeScript interface + spread operator suffice |
| Mock session building | New mock builder | SandboxStorageAdapter | The adapter encapsulates this, keeping engine clean |
| Timer signal accumulation | Global signal queue | SandboxTimerAdapter instance state | Adapter owns its signal state per-call |

**Key insight:** This is an internal refactoring with zero new dependencies. Every building block already exists. The only new code is interfaces and adapter implementations that wrap existing logic.

## Common Pitfalls

### Pitfall 1: State Mutation Communication Pattern
**What goes wrong:** handleIngestMode and checkImplicitYes intentionally MUTATE `currentState` as a communication channel to processMessage (lines 539, 653 of sandbox-engine). Extracting these into an agent class breaks this mutation-based communication.
**Why it happens:** The mutation pattern was a deliberate design choice (documented with WARNING comments) to avoid complex return types.
**How to avoid:** In the unified agent, change the communication to explicit return values. The agent's processMessage should return intermediate state updates, not mutate parameters. Use a result type like `{ action: 'continue' | 'silent' | 'handoff', stateUpdates: Partial<State>, ... }`.
**Warning signs:** If the planner creates tasks that "move" handleIngestMode without addressing the mutation pattern, the silent accumulation flow will break.

### Pitfall 2: Mock Session intentsVistos Ordering
**What goes wrong:** SandboxEngine uses `currentState.intentsVistos` (BEFORE adding current intent) when building the mock session for the orchestrator (line 243). This ensures TemplateManager correctly detects primera_vez vs siguientes. If this ordering is wrong, templates will be skipped or wrong visit_type templates will be sent.
**Why it happens:** The orchestrator adds the intent to intents_vistos internally. If the engine pre-adds it, the orchestrator sees it as "already seen" = siguientes.
**How to avoid:** The SandboxStorageAdapter must preserve this ordering: intentsVistos BEFORE the current intent is added. Document this invariant with a comment.
**Warning signs:** If primera_vez templates stop showing on first intent visit in sandbox, this ordering is broken.

### Pitfall 3: Two-Step Timer Signal Pattern
**What goes wrong:** When ingest completes, sandbox-engine emits 'cancel' (line 552), then processMessage OVERRIDES with 'start' (line 320-322). This is intentional: cancel clears the ingest timer, start initiates the promo timer. If the unified engine only keeps the last signal, or cancels both, the promo timer never starts.
**Why it happens:** Two different timer purposes (ingest vs promo) are signaled in sequence during a single processMessage call.
**How to avoid:** The TimerAdapter must handle sequential signals correctly. Either accumulate all signals, or understand that cancel+start means "restart with new purpose". The SandboxTimerAdapter should replicate the lastTimerSignal pattern.
**Warning signs:** If transitioning from collecting_data to ofrecer_promos no longer starts the promo timer.

### Pitfall 4: Production Engine Order Flow Differences
**What goes wrong:** SomnioEngine creates orders via OrderCreator (direct DB writes), while SandboxEngine uses CrmOrchestrator (dry-run or live mode). These have different APIs and return types. Forcing them into a single adapter without careful type alignment will break one or both paths.
**Why it happens:** OrderCreator was built for production (Phase 14), CrmOrchestrator was built for sandbox (Phase 15.6). They evolved independently.
**How to avoid:** The OrdersAdapter interface must be abstract enough to cover both: `createOrder(data, context) -> OrderResult`. Each implementation wraps its specific creator.
**Warning signs:** Orders failing in production after unification, or CRM dry-run/live mode losing its mode annotation.

### Pitfall 5: SomnioEngine Builds History from DB Turns
**What goes wrong:** SomnioEngine calls `this.buildConversationHistory(session.id)` which reads from DB via SessionManager.getTurns(). SandboxEngine receives history as a parameter (in-memory). If the unified engine always reads from DB, sandbox breaks. If it always takes a parameter, production loses history persistence.
**Why it happens:** Fundamentally different state storage approaches.
**How to avoid:** The StorageAdapter should expose a `getHistory(sessionId)` method. Sandbox adapter returns the in-memory history parameter. Production adapter reads from DB via SessionManager.
**Warning signs:** History missing or duplicated in either environment.

### Pitfall 6: Production Timer Emits Inngest Events at Multiple Points
**What goes wrong:** SomnioEngine emits Inngest events at 4 distinct points: emitIngestStarted (on first data), emitIngestCompleted (on all fields), emitCustomerMessageEvent (on every message for timer cancellation), and emitModeTransitionEvent (on mode changes). These are scattered across handleIngestMode, checkImplicitYes, and the main processMessage. Missing any of these in the unified engine breaks production timer workflows.
**Why it happens:** Timer events were added incrementally across Phases 13-15.5.
**How to avoid:** The ProductionTimerAdapter must implement all 4 event emission points. Map them clearly: `signal('ingest_start')`, `signal('ingest_complete')`, `onCustomerMessage()`, `onModeTransition()`. The SandboxTimerAdapter returns TimerSignal objects instead of emitting events.
**Warning signs:** Production timers not starting, not cancelling, or not triggering mode transitions.

### Pitfall 7: webhook-processor.ts External Interface
**What goes wrong:** Success criterion #7 requires webhook-processor.ts to keep its external interface unchanged. If the unification changes the ProcessMessageInput or SomnioEngineResult types, the Inngest function and other callers break.
**Why it happens:** webhook-processor is a consumer of SomnioEngine, and its interface is used by agent-production.ts (Inngest).
**How to avoid:** Keep ProcessMessageInput and the return type of processMessageWithAgent identical. webhook-processor internally switches to using UnifiedEngine + production adapters, but its public API stays the same.
**Warning signs:** TypeScript compilation errors in agent-production.ts or webhook-processor.ts.

### Pitfall 8: SandboxEngine Returns timerSignal in Result
**What goes wrong:** SandboxEngineResult has a `timerSignal` field that the frontend reads to control the timer simulator. SomnioEngineResult does NOT have this field. If the unified engine loses this field from the sandbox result, the timer simulator breaks.
**Why it happens:** The two engines have different result types.
**How to avoid:** The unified EngineOutput should include an optional `timerSignal`. The SandboxTimerAdapter accumulates signals and the engine includes the last one in its output. Production ignores this field (adapter emits Inngest events directly).
**Warning signs:** Timer simulator stops responding to engine signals in sandbox.

## Code Examples

### Example 1: Adapter Interface Definitions
```typescript
// src/lib/agents/engine/types.ts

import type { IntentRecord, PackSelection } from '../types'
import type { TimerSignal, ToolExecution, DebugTurn, IngestStatus } from '@/lib/sandbox/types'
import type { SomnioOrchestratorResult } from '../somnio/somnio-orchestrator'

// ── Engine Input/Output ─────────────────────────────────────────────

export interface EngineInput {
  sessionId: string
  conversationId: string
  contactId: string
  message: string
  workspaceId: string
  history: { role: 'user' | 'assistant'; content: string }[]
  forceIntent?: string
  turnNumber?: number
}

export interface EngineOutput {
  success: boolean
  messages: string[]
  newState?: EngineStateLike
  debugTurn?: DebugTurn
  timerSignal?: TimerSignal
  orderCreated?: boolean
  orderId?: string
  newMode?: string
  tokensUsed?: number
  error?: { code: string; message: string }
}

// ── Adapter Bundle ──────────────────────────────────────────────────

export interface EngineAdapters {
  storage: StorageAdapter
  timer: TimerAdapter
  messaging: MessagingAdapter
  orders: OrdersAdapter
  debug: DebugAdapter
}

// ── EngineConfig ────────────────────────────────────────────────────

export interface EngineConfig {
  timerDurations?: Record<number, number>
  responseSpeed?: number
  crmModes?: Array<{ agentId: string; mode: 'dry-run' | 'live' }>
  workspaceId: string
}
```

### Example 2: Sandbox Adapter Factory
```typescript
// src/lib/agents/engine-adapters/sandbox/index.ts

export function createSandboxAdapters(
  initialState: SandboxState,
  history: ClaudeMessage[],
  crmModes?: CrmMode[],
  workspaceId?: string
): EngineAdapters {
  return {
    storage: new SandboxStorageAdapter(initialState),
    timer: new SandboxTimerAdapter(),
    messaging: new SandboxMessagingAdapter(),
    orders: new SandboxOrdersAdapter(crmModes, workspaceId),
    debug: new SandboxDebugAdapter(),
  }
}
```

### Example 3: Production Adapter Factory
```typescript
// src/lib/agents/engine-adapters/production/index.ts

export function createProductionAdapters(
  workspaceId: string,
  conversationId: string,
  phoneNumber?: string
): EngineAdapters {
  const sessionManager = new SessionManager()
  return {
    storage: new ProductionStorageAdapter(sessionManager),
    timer: new ProductionTimerAdapter(workspaceId),
    messaging: new ProductionMessagingAdapter(sessionManager, conversationId, workspaceId, phoneNumber),
    orders: new ProductionOrdersAdapter(workspaceId),
    debug: new ProductionDebugAdapter(),
  }
}
```

### Example 4: webhook-processor.ts Migration
```typescript
// Minimal change to webhook-processor.ts:
// Replace SomnioEngine instantiation with UnifiedEngine + production adapters

// BEFORE:
const { SomnioEngine } = await import('../somnio')
const engine = new SomnioEngine(workspaceId)
result = await engine.processMessage({ ... })

// AFTER:
const { UnifiedEngine } = await import('../engine')
const { createProductionAdapters } = await import('../engine-adapters/production')
const adapters = createProductionAdapters(workspaceId, conversationId, phone)
const engine = new UnifiedEngine(adapters, { workspaceId })
const output = await engine.processMessage({ ... })
// Map output to SomnioEngineResult shape for backward compat
result = mapToSomnioResult(output)
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| 2 separate engines with ~800 lines of duplicated flow | Unified engine + adapters | Phase 16.1 (now) | Single source of truth for flow logic |
| Mock session building in sandbox | StorageAdapter that produces correct session shape | Phase 16.1 (now) | Eliminates fragile mock construction |
| Scattered timer event emission | TimerAdapter with clear signal interface | Phase 16.1 (now) | All timer I/O goes through one interface |

## Open Questions

### 1. Where does the "silent response" logic live?
**What we know:** In sandbox, silent ingest returns `[SANDBOX: Silent - clasificacion: datos]` as the response message. In production, silent ingest returns `response: undefined` (SomnioEngineResult). These are fundamentally different behaviors.
**What's unclear:** Should the unified engine return no messages for silent, and let the sandbox caller inject the debug message? Or should the MessagingAdapter handle this distinction?
**Recommendation:** The engine should return `messages: []` for silent ingest. The sandbox API route (or SandboxMessagingAdapter) can inject the debug message. This keeps the engine clean and environment-agnostic.

### 2. Should SomnioAgent be a new class or inline in UnifiedEngine?
**What we know:** CONTEXT.md says "the engine is a runner, all business logic lives in the agent." This implies a SomnioAgent class. But creating a formal agent interface is premature (only one agent exists).
**What's unclear:** How formal should the agent boundary be?
**Recommendation:** Extract the Somnio-specific flow (ingest check, implicit yes, intent detection, orchestration) into a `processSomnioMessage()` function (or class methods) that the unified engine calls. Do NOT create a formal `Agent` interface yet. The function/class is Somnio-specific and that's fine.

### 3. How to handle the forceIntent + compra_confirmada skipTemplates logic?
**What we know:** When `forceIntent === 'compra_confirmada'`, sandbox-engine skips templates (line 335-336) because timer-forced purchases should only create orders, not send marketing messages. Production SomnioEngine does not have this logic (its timer path is different).
**What's unclear:** Is this sandbox-only behavior or should production also skip templates on forced compra_confirmada?
**Recommendation:** This is agent logic (Somnio-specific), not engine logic. Keep it in the agent flow. The skipTemplates decision based on forceIntent stays in the Somnio agent processing code.

### 4. SandboxEngine is stateless singleton vs SomnioEngine is per-workspace instance
**What we know:** The sandbox API route creates ONE SandboxEngine instance at module level (line 25 of route.ts). SomnioEngine is created per-request with a workspaceId in its constructor (line 155 of webhook-processor.ts). The unified engine needs to work in both modes.
**What's unclear:** Should the unified engine be stateful or stateless?
**Recommendation:** The unified engine should be stateless. Workspace-specific context comes via the adapters and EngineConfig, not the engine constructor. The `lastTimerSignal` instance state from SandboxEngine moves to the SandboxTimerAdapter. This allows a single engine instance for sandbox (like current) and per-request construction for production (just swap adapters).

## Sources

### Primary (HIGH confidence)
- Codebase investigation: `src/lib/sandbox/sandbox-engine.ts` (681 lines, full flow analysis)
- Codebase investigation: `src/lib/agents/somnio/somnio-engine.ts` (844 lines, full flow analysis)
- Codebase investigation: `src/lib/agents/production/webhook-processor.ts` (production integration)
- Codebase investigation: `src/app/api/sandbox/process/route.ts` (sandbox integration)
- Codebase investigation: `src/app/(dashboard)/sandbox/components/sandbox-layout.tsx` (frontend timer integration)
- Phase context: `.planning/phases/16.1-engine-unification/16.1-CONTEXT.md` (user decisions)

### Secondary (MEDIUM confidence)
- Architecture patterns: Ports & Adapters / Hexagonal Architecture (established GoF-era pattern)
- TypeScript DI patterns: Constructor injection without framework (well-established practice)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — No external dependencies, pure internal refactoring
- Architecture: HIGH — Pattern (Ports & Adapters) is well-understood and fits perfectly
- Pitfalls: HIGH — All 8 pitfalls identified from direct codebase analysis of both engines
- Code examples: HIGH — Based on actual types and patterns from the codebase

**Research date:** 2026-02-10
**Valid until:** 2026-03-10 (stable — internal refactoring, no external dependencies to change)

---

## Appendix: Duplication Analysis

### Flow Steps Comparison

| Step | SandboxEngine | SomnioEngine | Shared Logic? |
|------|---------------|--------------|---------------|
| 1. Read state | In-memory param | SessionManager.getSession() | **Different I/O**, same purpose |
| 2. Build history | Param (in-memory) | SessionManager.getTurns() | **Different I/O**, same purpose |
| 3. Check ingest mode | handleIngestMode() | handleIngestMode() | **~90% identical logic** |
| 4. Check implicit yes | checkImplicitYes() | checkImplicitYes() | **~85% identical logic** |
| 5. Detect intent (or force) | IntentDetector.detect() | IntentDetector.detect() | **Identical** |
| 6. Record user turn | (skipped) | SessionManager.addTurn() | **Different I/O** |
| 7. Handle handoff | Return handoff state | SessionManager.handoffSession() | **Different I/O** |
| 8. Build mock session | Manual object construction | (already a session) | **Sandbox-specific** |
| 9. Orchestrate | SomnioOrchestrator.orchestrate() | SomnioOrchestrator.orchestrate() | **Identical** |
| 10. Build new state | Spread + merge | SessionManager.updateState() | **Different I/O** |
| 11. Handle timer signals | lastTimerSignal accumulation | Inngest event emission | **Different I/O** |
| 12. Skip templates (forced) | skipTemplates flag | (not implemented) | **Sandbox-specific** |
| 13. Collect messages | Array accumulation | (handled by MessageSequencer) | **Different I/O** |
| 14. Handle orders | CrmOrchestrator.route() | OrderCreator.createContactAndOrder() | **Different I/O** |
| 15. Record assistant turn | (skipped) | SessionManager.addTurn() | **Different I/O** |
| 16. Build debug | DebugTurn object | (logging only) | **Different I/O** |
| 17. Return result | SandboxEngineResult | SomnioEngineResult | **Different types** |

### Shared Components (Used by Both, No Changes Needed)
- `IntentDetector` — identical usage
- `SomnioOrchestrator` — identical usage
- `IngestManager` — identical usage
- `MessageClassifier` — identical usage
- `DataExtractor` + `mergeExtractedData` + `hasCriticalData` — identical usage
- `agentRegistry.get()` — identical usage
- `somnioAgentConfig` — identical usage

### Lines of Pure I/O Difference (Adapter Territory)
- State read/write: ~80 lines sandbox, ~120 lines production
- Timer signals/events: ~40 lines sandbox, ~100 lines production
- Message dispatch: ~20 lines sandbox, ~40 lines production
- Order creation: ~40 lines sandbox, ~50 lines production
- Debug info: ~30 lines sandbox, ~10 lines production (just logging)
- History building: ~5 lines sandbox, ~15 lines production
- Turn recording: ~0 lines sandbox, ~30 lines production

**Total I/O-only code:** ~215 lines sandbox + ~365 lines production = ~580 lines
**Total shared flow logic:** ~950 lines (currently duplicated)
**Net gain:** One source of truth for ~950 lines of flow logic, with ~580 lines of adapter code that is inherently environment-specific anyway.
