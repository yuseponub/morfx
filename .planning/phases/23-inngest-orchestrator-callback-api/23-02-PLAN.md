---
phase: 23-inngest-orchestrator-callback-api
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/inngest/functions/robot-orchestrator.ts
  - src/app/api/inngest/route.ts
autonomous: true

must_haves:
  truths:
    - "When robot/job.submitted event fires, the orchestrator marks the job as processing, calls the robot service via HTTP, and waits for batch completion"
    - "If the robot service returns non-200, the orchestrator marks the job as failed immediately (fail-fast, no retries)"
    - "If the batch_completed event does not arrive within the dynamic timeout, the orchestrator marks the job as failed"
    - "The orchestrator is registered in Inngest serve() and receives events"
  artifacts:
    - path: "src/inngest/functions/robot-orchestrator.ts"
      provides: "robotOrchestrator Inngest function + robotOrchestratorFunctions export"
      exports: ["robotOrchestratorFunctions"]
    - path: "src/app/api/inngest/route.ts"
      provides: "robotOrchestratorFunctions registered in serve()"
      contains: "robotOrchestratorFunctions"
  key_links:
    - from: "src/inngest/functions/robot-orchestrator.ts"
      to: "src/lib/domain/robot-jobs.ts"
      via: "updateJobStatus domain call"
      pattern: "updateJobStatus"
    - from: "src/inngest/functions/robot-orchestrator.ts"
      to: "src/inngest/events.ts"
      via: "step.waitForEvent for robot/job.batch_completed"
      pattern: "robot/job\\.batch_completed"
    - from: "src/app/api/inngest/route.ts"
      to: "src/inngest/functions/robot-orchestrator.ts"
      via: "import and spread in serve functions array"
      pattern: "robotOrchestratorFunctions"
---

<objective>
Create the Inngest orchestrator function that dispatches robot jobs to the robot-coordinadora service and waits for batch completion with a dynamic timeout.

Purpose: This is the bridge between MorfX and the robot service -- it translates Inngest events into HTTP calls and handles the async waiting pattern for batch results.
Output: `src/inngest/functions/robot-orchestrator.ts` with the orchestrator function, registered in Inngest serve().
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-inngest-orchestrator-callback-api/23-RESEARCH.md
@.planning/phases/23-inngest-orchestrator-callback-api/23-01-SUMMARY.md

# Key reference files
@src/inngest/events.ts
@src/inngest/client.ts
@src/inngest/functions/agent-timers.ts
@src/lib/domain/robot-jobs.ts
@src/app/api/inngest/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create robot-orchestrator Inngest function</name>
  <files>src/inngest/functions/robot-orchestrator.ts</files>
  <action>
Create `src/inngest/functions/robot-orchestrator.ts` with the following structure:

```typescript
// ============================================================================
// Phase 23: Inngest Orchestrator + Callback API — Robot Orchestrator
// Durable function that dispatches robot jobs to the robot-coordinadora
// service and waits for batch completion with dynamic timeout.
//
// Flow:
//   1. Mark job as processing (domain layer)
//   2. Call robot service HTTP endpoint (dispatch)
//   3. Brief settle sleep (race condition prevention)
//   4. Wait for batch_completed event (with dynamic timeout)
//   5. On timeout: mark job as failed
//
// FAIL-FAST: retries: 0 — never retry to prevent duplicate submissions
// ============================================================================
```

Import:
- `inngest` from `../client`
- `updateJobStatus` from `@/lib/domain/robot-jobs`

Create the function with `inngest.createFunction()`:

**Config:**
- `id: 'robot-orchestrator'`
- `retries: 0` (CRITICAL: fail-fast to prevent duplicate portal submissions)

**Trigger:** `{ event: 'robot/job.submitted' as any }` (type assertion per project pattern)

**Steps:**

**Step 1: mark-processing**
```typescript
await step.run('mark-processing', async () => {
  const result = await updateJobStatus(
    { workspaceId, source: 'inngest-orchestrator' },
    { jobId, status: 'processing' }
  )
  if (!result.success) {
    throw new Error(`Failed to mark job processing: ${result.error}`)
  }
})
```

**Step 2: dispatch-to-robot**
```typescript
const dispatchResult = await step.run('dispatch-to-robot', async () => {
  const robotUrl = process.env.ROBOT_COORDINADORA_URL
  if (!robotUrl) throw new Error('ROBOT_COORDINADORA_URL env var not set')

  const callbackUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/robot-callback`
  const callbackSecret = process.env.ROBOT_CALLBACK_SECRET
  if (!callbackSecret) throw new Error('ROBOT_CALLBACK_SECRET env var not set')

  const response = await fetch(`${robotUrl}/api/crear-pedidos-batch`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Callback-Secret': callbackSecret,
    },
    body: JSON.stringify({
      workspaceId,
      credentials,
      callbackUrl,
      callbackSecret,
      jobId,
      orders: orders.map(o => ({
        itemId: o.itemId,
        orderId: o.orderId,
        pedidoInput: o.pedidoInput,
      })),
    }),
  })

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unknown error')
    throw new Error(`Robot service error ${response.status}: ${errorText}`)
  }

  return await response.json()
})
```

Note: Pass `callbackSecret` in the payload so the robot can forward it in callback headers.

**Step 3: settle sleep** (race condition prevention for tiny batches)
```typescript
await step.sleep('settle', '2s')
```

**Step 4: wait-for-batch** (dynamic timeout)
```typescript
// Timeout: (N orders x 30s) + 5 min margin
const timeoutMs = (orders.length * 30_000) + (5 * 60_000)

const batchCompleted = await step.waitForEvent('wait-for-batch', {
  event: 'robot/job.batch_completed',
  timeout: `${timeoutMs}ms`,
  if: `async.data.jobId == "${jobId}"`,
})
```

**Step 5: handle result**
```typescript
if (!batchCompleted) {
  // Timeout: mark job as failed
  await step.run('mark-timeout-failed', async () => {
    await updateJobStatus(
      { workspaceId, source: 'inngest-orchestrator' },
      { jobId, status: 'failed' }
    )
  })
  return { status: 'failed', reason: 'timeout', jobId }
}

return {
  status: 'completed',
  jobId,
  successCount: batchCompleted.data.successCount,
  errorCount: batchCompleted.data.errorCount,
}
```

**Error handling:** Do NOT wrap step.run() calls in try/catch (non-standard Inngest pattern; step.run inside catch may not execute correctly on replayed functions). Instead, use Inngest's `onFailure` callback to handle cleanup:

Add an `onFailure` handler to the function config:

```typescript
const robotOrchestrator = inngest.createFunction(
  {
    id: 'robot-orchestrator',
    retries: 0,
    onFailure: async ({ event, error }) => {
      // Mark job as failed when the function fails for any reason
      const { jobId, workspaceId } = event.data.event.data
      console.error(`[robot-orchestrator] Function failed for job ${jobId}:`, error.message)
      await updateJobStatus(
        { workspaceId, source: 'inngest-orchestrator' },
        { jobId, status: 'failed' }
      )
    },
  },
  { event: 'robot/job.submitted' as any },
  async ({ event, step }) => {
    // Steps 1-5 (no try/catch wrapping)
  }
)
```

This pattern is idiomatic Inngest: the `onFailure` callback runs as a separate step function that Inngest guarantees to execute when the parent function fails, regardless of which step failed. It works correctly with replays and does not have the catch-around-step.run anti-pattern.

**Export:**
```typescript
export const robotOrchestratorFunctions = [robotOrchestrator]
```

**Console logging:** Add `console.log` at key points (job start, dispatch, timeout, completion) for observability.
  </action>
  <verify>Run `npx tsc --noEmit` -- no TypeScript errors. Read the file and verify: retries is 0, step.waitForEvent uses robot/job.batch_completed, timeout is dynamic, updateJobStatus is called for processing and failure states.</verify>
  <done>robot-orchestrator.ts exists with a single Inngest function that: marks job processing, dispatches HTTP to robot service, settles 2s, waits for batch_completed with dynamic timeout, and marks job failed on timeout or error. Retries is 0 (fail-fast).</done>
</task>

<task type="auto">
  <name>Task 2: Register orchestrator in Inngest serve()</name>
  <files>src/app/api/inngest/route.ts</files>
  <action>
Update `src/app/api/inngest/route.ts`:

1. Add import:
```typescript
import { robotOrchestratorFunctions } from '@/inngest/functions/robot-orchestrator'
```

2. Remove the TODO comment from Plan 01 if it exists.

3. Add to the functions array in serve():
```typescript
functions: [
  ...agentTimerFunctions,
  ...agentProductionFunctions,
  ...automationFunctions,
  ...robotOrchestratorFunctions,
  taskOverdueCron,
],
```

4. Update the JSDoc comment to mention robot orchestrator functions.
  </action>
  <verify>Run `npx tsc --noEmit` -- no TypeScript errors. Read route.ts and confirm robotOrchestratorFunctions is imported and spread into the serve functions array.</verify>
  <done>Inngest serve() registers the robot orchestrator function alongside existing agent timers, production functions, automation runners, and cron.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `grep -r 'robot-orchestrator' src/inngest/` returns the function file and route import
3. `grep 'retries: 0' src/inngest/functions/robot-orchestrator.ts` confirms fail-fast
4. `grep 'waitForEvent' src/inngest/functions/robot-orchestrator.ts` confirms the wait pattern
5. `grep 'robotOrchestratorFunctions' src/app/api/inngest/route.ts` confirms registration
</verification>

<success_criteria>
- The orchestrator function compiles without TypeScript errors
- retries is 0 (fail-fast, no duplicate submissions)
- HTTP dispatch includes callbackUrl and callbackSecret
- Dynamic timeout is (N * 30s) + 5min
- Job is marked as failed on timeout, dispatch error, or any unhandled error
- Function is registered in Inngest serve()
</success_criteria>

<output>
After completion, create `.planning/phases/23-inngest-orchestrator-callback-api/23-02-SUMMARY.md`
</output>
