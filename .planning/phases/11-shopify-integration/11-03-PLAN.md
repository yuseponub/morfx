---
phase: 11-shopify-integration
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - src/lib/shopify/order-mapper.ts
  - src/lib/shopify/webhook-handler.ts
autonomous: true

must_haves:
  truths:
    - "Shopify order maps to MorfX order with products"
    - "Product matching uses configured strategy (SKU, name, or value)"
    - "Webhook handler processes order creation end-to-end"
    - "Duplicate webhooks are ignored via shopify_order_id"
  artifacts:
    - path: "src/lib/shopify/order-mapper.ts"
      provides: "Order mapping from Shopify to MorfX"
      exports: ["mapShopifyOrder", "matchProducts"]
    - path: "src/lib/shopify/webhook-handler.ts"
      provides: "Webhook processing logic"
      exports: ["processShopifyWebhook"]
  key_links:
    - from: "src/lib/shopify/webhook-handler.ts"
      to: "src/lib/shopify/order-mapper.ts"
      via: "import mapShopifyOrder"
      pattern: "import.*mapShopifyOrder"
    - from: "src/lib/shopify/webhook-handler.ts"
      to: "src/lib/shopify/contact-matcher.ts"
      via: "import matchContact"
      pattern: "import.*matchContact"
---

<objective>
Create order mapping and webhook processing logic.

Purpose: Transform Shopify order data into MorfX orders with proper product matching and contact linking.
Output: Order mapper that handles product matching, and webhook handler that orchestrates the full processing flow.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-shopify-integration/11-CONTEXT.md
@.planning/phases/11-shopify-integration/11-RESEARCH.md

# Existing order patterns:
@src/lib/orders/types.ts
@src/app/actions/orders.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Order mapper with product matching</name>
  <files>src/lib/shopify/order-mapper.ts</files>
  <action>
Create order mapping utilities:

```typescript
import Fuse from 'fuse.js'
import { createAdminClient } from '@/lib/supabase/admin'
import type { ShopifyOrderWebhook, ShopifyLineItem, ShopifyConfig } from './types'
import type { OrderFormData, OrderProductFormData, Product } from '@/lib/orders/types'

/**
 * Result of mapping a Shopify order to MorfX format.
 */
export interface MappedOrder {
  order: OrderFormData
  products: OrderProductFormData[]
  shopifyOrderId: number
  shopifyOrderName: string  // "#1001"
  unmatchedProducts: ShopifyLineItem[]  // Products that couldn't be matched
}

/**
 * Maps a Shopify order to MorfX order format.
 * Handles product matching based on configured strategy.
 *
 * @param shopifyOrder - Incoming Shopify order
 * @param config - Shopify integration config
 * @param workspaceId - Target workspace
 * @param contactId - Matched or created contact ID
 * @returns Mapped order data ready for insertion
 */
export async function mapShopifyOrder(
  shopifyOrder: ShopifyOrderWebhook,
  config: ShopifyConfig,
  workspaceId: string,
  contactId: string | null
): Promise<MappedOrder> {
  const supabase = createAdminClient()

  // Get workspace products for matching
  const { data: catalogProducts } = await supabase
    .from('products')
    .select('id, sku, title, price, is_active')
    .eq('workspace_id', workspaceId)
    .eq('is_active', true)

  // Match products based on configured strategy
  const { matched, unmatched } = await matchProducts(
    shopifyOrder.line_items,
    catalogProducts || [],
    config.product_matching
  )

  // Build order data
  const order: OrderFormData = {
    contact_id: contactId,
    pipeline_id: config.default_pipeline_id,
    stage_id: config.default_stage_id,
    description: buildOrderDescription(shopifyOrder),
    shipping_address: buildShippingAddress(shopifyOrder),
    shipping_city: shopifyOrder.shipping_address?.city || null,
    // Note: total_value is computed from products by trigger
  }

  return {
    order,
    products: matched,
    shopifyOrderId: shopifyOrder.id,
    shopifyOrderName: shopifyOrder.name,
    unmatchedProducts: unmatched,
  }
}

/**
 * Matches Shopify line items to MorfX products.
 */
export async function matchProducts(
  lineItems: ShopifyLineItem[],
  catalogProducts: Product[],
  matchStrategy: 'sku' | 'name' | 'value'
): Promise<{
  matched: OrderProductFormData[]
  unmatched: ShopifyLineItem[]
}> {
  const matched: OrderProductFormData[] = []
  const unmatched: ShopifyLineItem[] = []

  for (const item of lineItems) {
    const catalogProduct = findMatchingProduct(item, catalogProducts, matchStrategy)

    if (catalogProduct) {
      // Matched - use catalog product ID with Shopify pricing snapshot
      matched.push({
        product_id: catalogProduct.id,
        sku: catalogProduct.sku,
        title: catalogProduct.title,
        unit_price: parseFloat(item.price),  // Use Shopify price as snapshot
        quantity: item.quantity,
      })
    } else {
      // Not matched - create product entry without catalog link
      matched.push({
        product_id: null,  // No catalog link
        sku: item.sku || `SHOPIFY-${item.id}`,
        title: item.title || item.name,
        unit_price: parseFloat(item.price),
        quantity: item.quantity,
      })
      unmatched.push(item)
    }
  }

  return { matched, unmatched }
}

/**
 * Finds matching catalog product based on configured strategy.
 */
function findMatchingProduct(
  lineItem: ShopifyLineItem,
  catalogProducts: Product[],
  strategy: 'sku' | 'name' | 'value'
): Product | null {
  switch (strategy) {
    case 'sku':
      // Exact SKU match
      if (!lineItem.sku) return null
      return catalogProducts.find(p => p.sku.toLowerCase() === lineItem.sku.toLowerCase()) || null

    case 'name':
      // Fuzzy name match
      if (!lineItem.title && !lineItem.name) return null
      const searchName = lineItem.title || lineItem.name
      const fuse = new Fuse(catalogProducts, {
        keys: ['title'],
        threshold: 0.3,  // Fairly strict
        includeScore: true,
      })
      const results = fuse.search(searchName)
      // Only accept if score is good enough (<0.3)
      return results.length > 0 && (results[0].score || 1) < 0.3
        ? results[0].item
        : null

    case 'value':
      // Price match (exact value)
      const itemPrice = parseFloat(lineItem.price)
      return catalogProducts.find(p => Math.abs(p.price - itemPrice) < 0.01) || null

    default:
      return null
  }
}

/**
 * Builds order description from Shopify data.
 */
function buildOrderDescription(order: ShopifyOrderWebhook): string {
  const parts: string[] = [`Pedido Shopify ${order.name}`]

  if (order.note) {
    parts.push(`Nota: ${order.note}`)
  }

  if (order.financial_status) {
    parts.push(`Estado pago: ${order.financial_status}`)
  }

  return parts.join(' | ')
}

/**
 * Builds shipping address string from Shopify address.
 */
function buildShippingAddress(order: ShopifyOrderWebhook): string | null {
  const addr = order.shipping_address
  if (!addr) return null

  const parts = [
    addr.address1,
    addr.address2,
    addr.city,
    addr.province,
  ].filter(Boolean)

  return parts.join(', ') || null
}
```

Key behaviors:
- Product matching tries catalog first, falls back to manual entry
- Snapshot pricing uses Shopify's price (not catalog price)
- Unmatched products are tracked for potential alerts
- Order description includes Shopify order number and notes
  </action>
  <verify>`pnpm tsc --noEmit` passes. Review mapping logic covers all Shopify fields.</verify>
  <done>mapShopifyOrder transforms Shopify orders to MorfX format. matchProducts implements SKU/name/value strategies.</done>
</task>

<task type="auto">
  <name>Task 2: Webhook handler orchestration</name>
  <files>src/lib/shopify/webhook-handler.ts</files>
  <action>
Create the main webhook processing logic:

```typescript
import { createAdminClient } from '@/lib/supabase/admin'
import { matchContact } from './contact-matcher'
import { mapShopifyOrder, MappedOrder } from './order-mapper'
import { extractPhoneFromOrder, normalizeShopifyPhone } from './phone-normalizer'
import type { ShopifyOrderWebhook, ShopifyIntegration, WebhookEvent } from './types'

/**
 * Result of processing a Shopify webhook.
 */
export interface ProcessResult {
  success: boolean
  orderId?: string
  contactId?: string
  contactCreated?: boolean
  needsVerification?: boolean  // Contact match needs human verification
  error?: string
}

/**
 * Processes a Shopify orders/create webhook.
 * This is the main orchestration function that:
 * 1. Checks for duplicate (idempotency)
 * 2. Matches or creates contact
 * 3. Creates order with products
 * 4. Logs the webhook event
 *
 * @param order - Shopify order webhook payload
 * @param integration - Shopify integration config
 * @param webhookId - X-Shopify-Webhook-Id for idempotency
 * @returns Processing result
 */
export async function processShopifyWebhook(
  order: ShopifyOrderWebhook,
  integration: ShopifyIntegration,
  webhookId: string
): Promise<ProcessResult> {
  const supabase = createAdminClient()
  const workspaceId = integration.workspace_id
  const config = integration.config

  try {
    // Step 1: Check for duplicate webhook
    const { data: existingEvent } = await supabase
      .from('webhook_events')
      .select('id, status')
      .eq('integration_id', integration.id)
      .eq('external_id', webhookId)
      .single()

    if (existingEvent) {
      console.log(`Duplicate webhook ignored: ${webhookId}`)
      return { success: true, error: 'Duplicate webhook' }
    }

    // Step 1b: Check for duplicate order by shopify_order_id
    const { data: existingOrder } = await supabase
      .from('orders')
      .select('id')
      .eq('workspace_id', workspaceId)
      .eq('shopify_order_id', order.id)
      .single()

    if (existingOrder) {
      console.log(`Duplicate Shopify order ignored: ${order.id}`)
      // Log event as processed (duplicate)
      await logWebhookEvent(supabase, integration.id, webhookId, 'orders/create', order, 'processed')
      return { success: true, orderId: existingOrder.id, error: 'Order already exists' }
    }

    // Step 2: Log webhook event as pending
    await logWebhookEvent(supabase, integration.id, webhookId, 'orders/create', order, 'pending')

    // Step 3: Match or create contact
    const { contactId, contactCreated, needsVerification } = await resolveContact(
      supabase,
      order,
      workspaceId,
      config.enable_fuzzy_matching
    )

    // Step 4: Map Shopify order to MorfX format
    const mapped = await mapShopifyOrder(order, config, workspaceId, contactId)

    // Step 5: Create order with products
    const orderId = await createOrderWithProducts(supabase, workspaceId, mapped)

    // Step 6: Update webhook event to processed
    await updateWebhookEvent(supabase, integration.id, webhookId, 'processed')

    // Step 7: Update integration last_sync_at
    await supabase
      .from('integrations')
      .update({ last_sync_at: new Date().toISOString() })
      .eq('id', integration.id)

    console.log(`Processed Shopify order ${order.name} -> MorfX order ${orderId}`)

    return {
      success: true,
      orderId,
      contactId,
      contactCreated,
      needsVerification,
    }
  } catch (error) {
    console.error('Error processing Shopify webhook:', error)

    // Update webhook event to failed
    await updateWebhookEvent(
      supabase,
      integration.id,
      webhookId,
      'failed',
      error instanceof Error ? error.message : 'Unknown error'
    )

    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

/**
 * Resolves contact: match existing or create new.
 */
async function resolveContact(
  supabase: ReturnType<typeof createAdminClient>,
  order: ShopifyOrderWebhook,
  workspaceId: string,
  enableFuzzyMatching: boolean
): Promise<{
  contactId: string | null
  contactCreated: boolean
  needsVerification: boolean
}> {
  // Try to match existing contact
  const match = await matchContact(order, workspaceId, { enableFuzzyMatching })

  if (match.contact) {
    return {
      contactId: match.contact.id,
      contactCreated: false,
      needsVerification: match.needsVerification,
    }
  }

  // No match - create new contact
  const phone = extractPhoneFromOrder(order)
  const email = order.email || order.customer?.email
  const name = buildContactName(order)

  if (!name) {
    // Cannot create contact without a name
    return { contactId: null, contactCreated: false, needsVerification: false }
  }

  const { data: newContact, error } = await supabase
    .from('contacts')
    .insert({
      workspace_id: workspaceId,
      name,
      phone,
      email,
      address: buildShippingAddressString(order),
      city: order.shipping_address?.city || order.billing_address?.city || null,
    })
    .select('id')
    .single()

  if (error) {
    // Handle duplicate phone (race condition or existing contact)
    if (error.code === '23505' && phone) {
      const { data: existing } = await supabase
        .from('contacts')
        .select('id')
        .eq('workspace_id', workspaceId)
        .eq('phone', phone)
        .single()

      if (existing) {
        return { contactId: existing.id, contactCreated: false, needsVerification: false }
      }
    }
    console.error('Error creating contact:', error)
    return { contactId: null, contactCreated: false, needsVerification: false }
  }

  return { contactId: newContact.id, contactCreated: true, needsVerification: false }
}

/**
 * Creates order with products in a transaction.
 */
async function createOrderWithProducts(
  supabase: ReturnType<typeof createAdminClient>,
  workspaceId: string,
  mapped: MappedOrder
): Promise<string> {
  // Insert order with shopify_order_id
  const { data: newOrder, error: orderError } = await supabase
    .from('orders')
    .insert({
      workspace_id: workspaceId,
      ...mapped.order,
      shopify_order_id: mapped.shopifyOrderId,
    })
    .select('id')
    .single()

  if (orderError) {
    throw new Error(`Failed to create order: ${orderError.message}`)
  }

  // Insert order products
  if (mapped.products.length > 0) {
    const productsToInsert = mapped.products.map(p => ({
      order_id: newOrder.id,
      product_id: p.product_id,
      sku: p.sku,
      title: p.title,
      unit_price: p.unit_price,
      quantity: p.quantity,
    }))

    const { error: productsError } = await supabase
      .from('order_products')
      .insert(productsToInsert)

    if (productsError) {
      console.error('Error inserting order products:', productsError)
      // Don't throw - order was created, products are secondary
    }
  }

  return newOrder.id
}

/**
 * Builds contact name from Shopify order data.
 */
function buildContactName(order: ShopifyOrderWebhook): string | null {
  // Try customer name first
  if (order.customer?.first_name || order.customer?.last_name) {
    return [order.customer.first_name, order.customer.last_name]
      .filter(Boolean)
      .join(' ')
  }

  // Try shipping address name
  if (order.shipping_address?.first_name || order.shipping_address?.last_name) {
    return [order.shipping_address.first_name, order.shipping_address.last_name]
      .filter(Boolean)
      .join(' ')
  }

  // Try billing address name
  if (order.billing_address?.first_name || order.billing_address?.last_name) {
    return [order.billing_address.first_name, order.billing_address.last_name]
      .filter(Boolean)
      .join(' ')
  }

  return null
}

/**
 * Builds address string from shipping address.
 */
function buildShippingAddressString(order: ShopifyOrderWebhook): string | null {
  const addr = order.shipping_address
  if (!addr) return null

  return [addr.address1, addr.address2].filter(Boolean).join(', ') || null
}

// Webhook event logging helpers
async function logWebhookEvent(
  supabase: ReturnType<typeof createAdminClient>,
  integrationId: string,
  externalId: string,
  topic: string,
  payload: unknown,
  status: string
): Promise<void> {
  await supabase.from('webhook_events').insert({
    integration_id: integrationId,
    external_id: externalId,
    topic,
    payload,
    status,
  })
}

async function updateWebhookEvent(
  supabase: ReturnType<typeof createAdminClient>,
  integrationId: string,
  externalId: string,
  status: string,
  errorMessage?: string
): Promise<void> {
  await supabase
    .from('webhook_events')
    .update({
      status,
      error_message: errorMessage,
      processed_at: status === 'processed' ? new Date().toISOString() : null,
    })
    .eq('integration_id', integrationId)
    .eq('external_id', externalId)
}
```

Key behaviors:
- Idempotency via webhook_id AND shopify_order_id checks
- Contact resolution: match first, create if not found
- Order creation with all products in one flow
- Comprehensive error handling and logging
- Returns needsVerification flag for fuzzy matches
  </action>
  <verify>`pnpm tsc --noEmit` passes. Review all error paths are handled.</verify>
  <done>processShopifyWebhook orchestrates complete webhook flow: dedup, contact resolution, order creation, logging.</done>
</task>

</tasks>

<verification>
1. Order mapper handles all three matching strategies
2. Webhook handler has idempotency checks
3. Contact creation handles race conditions
4. Error handling logs failures properly
5. All files compile without errors
</verification>

<success_criteria>
- Shopify orders map to MorfX format with products
- Duplicate webhooks are silently ignored
- Contacts are matched or created as appropriate
- Webhook events are logged for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/11-shopify-integration/11-03-SUMMARY.md`
</output>
