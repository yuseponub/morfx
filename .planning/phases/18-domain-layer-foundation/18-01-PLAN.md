---
phase: 18-domain-layer-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/domain/types.ts
  - src/lib/domain/index.ts
  - supabase/migrations/YYYYMMDD_mutation_audit.sql
  - CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "DomainContext and DomainResult types are importable from src/lib/domain/types"
    - "mutation_audit table exists with triggers on 7 critical tables"
    - "CLAUDE.md contains permanent rule about domain/ as single source of truth"
  artifacts:
    - path: "src/lib/domain/types.ts"
      provides: "DomainContext, DomainResult<T>, shared domain types"
      contains: "DomainContext"
    - path: "src/lib/domain/index.ts"
      provides: "Barrel re-export for all domain modules"
      contains: "export"
    - path: "supabase/migrations/YYYYMMDD_mutation_audit.sql"
      provides: "mutation_audit table + audit triggers"
      contains: "mutation_audit"
    - path: "CLAUDE.md"
      provides: "Domain layer rule"
      contains: "domain/"
  key_links:
    - from: "src/lib/domain/types.ts"
      to: "no project imports"
      via: "zero-import rule prevents circular deps"
      pattern: "export interface DomainContext"
---

<objective>
Create the foundation for the domain layer: shared types, barrel export, DB audit safety net, and permanent CLAUDE.md rule.

Purpose: Establish the type contracts (DomainContext, DomainResult) that ALL domain functions will use, plus the DB audit trigger that catches any code that bypasses domain/. This is the prerequisite for every subsequent plan.

Output: `src/lib/domain/types.ts`, `src/lib/domain/index.ts`, SQL migration for mutation_audit, updated CLAUDE.md.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-domain-layer-foundation/18-CONTEXT.md
@.planning/phases/18-domain-layer-foundation/18-RESEARCH.md

Key reference files:
@src/lib/automations/trigger-emitter.ts (trigger emit function signatures)
@src/lib/supabase/admin.ts (createAdminClient pattern)
@CLAUDE.md (to add domain rule)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create domain types and barrel export</name>
  <files>src/lib/domain/types.ts, src/lib/domain/index.ts</files>
  <action>
Create `src/lib/domain/types.ts` with ZERO project imports (prevents circular deps):

```typescript
// DomainContext — passed by every caller to domain functions
export interface DomainContext {
  workspaceId: string
  /** Who initiated: 'server-action' | 'tool-handler' | 'automation' | 'webhook' | 'adapter' */
  source: string
  /** Cascade depth for automation trigger chain protection */
  cascadeDepth?: number
}

// DomainResult — returned by every domain function
export interface DomainResult<T = void> {
  success: boolean
  data?: T
  error?: string
}
```

Create `src/lib/domain/index.ts` as initially empty barrel export with a comment that subsequent plans will add re-exports as entity modules are created. Add placeholder comments for each entity that will be added:
```typescript
// src/lib/domain/index.ts — Barrel export for domain layer
// Each entity module is added as it's implemented in Plans 02-09

// export * from './orders'        // Plan 02
// export * from './contacts'      // Plan 04
// export * from './tags'          // Plan 04
// export * from './messages'      // Plan 06
// export * from './tasks'         // Plan 07
// export * from './notes'         // Plan 08
// export * from './custom-fields' // Plan 08
// export * from './conversations' // Plan 09

export type { DomainContext, DomainResult } from './types'
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/lib/domain/types.ts` passes. Verify types.ts has ZERO import statements from project files (only native TS types).</verify>
  <done>DomainContext and DomainResult are defined and importable from `@/lib/domain/types`. types.ts has zero project imports.</done>
</task>

<task type="auto">
  <name>Task 2: Create DB audit migration and update CLAUDE.md</name>
  <files>supabase/migrations/YYYYMMDD_mutation_audit.sql, CLAUDE.md</files>
  <action>
Create SQL migration file `supabase/migrations/20260213_mutation_audit.sql` (adjust date to current). Contents:

1. Create `mutation_audit` table:
   - id uuid DEFAULT gen_random_uuid() PRIMARY KEY
   - table_name text NOT NULL
   - operation text NOT NULL (INSERT, UPDATE, DELETE)
   - row_id uuid
   - workspace_id uuid
   - occurred_at timestamptz DEFAULT timezone('America/Bogota', NOW())
   - old_data jsonb
   - new_data jsonb

2. Create indexes:
   - idx_mutation_audit_occurred ON mutation_audit (occurred_at)
   - idx_mutation_audit_workspace ON mutation_audit (workspace_id)

3. Create trigger function `audit_mutation()` RETURNS TRIGGER:
   - INSERTs a row with TG_TABLE_NAME, TG_OP, COALESCE(NEW.id, OLD.id), COALESCE(NEW.workspace_id, OLD.workspace_id)
   - Captures old_data for UPDATE/DELETE, new_data for INSERT/UPDATE
   - RETURNS COALESCE(NEW, OLD)

4. Attach trigger to 7 critical tables: contacts, orders, tasks, messages, contact_tags, order_tags, conversations
   - AFTER INSERT OR UPDATE OR DELETE FOR EACH ROW

5. RLS policy: NO RLS on mutation_audit (system table only, never exposed to users).

Use exact SQL from RESEARCH.md Code Examples section.

Then update `CLAUDE.md` — add a new section after "## Regla 2" called "## Regla 3: Domain Layer":
```
## Regla 3: Domain Layer

TODA mutacion de datos DEBE pasar por `src/lib/domain/`.
Nunca escribir directo a Supabase desde server actions, tool handlers, action executor o webhooks.

Patron obligatorio:
- Server Action → valida auth → llama domain → revalidatePath
- Tool Handler → llama domain → retorna ToolResult
- Action Executor → llama domain con cascadeDepth
- Webhook → llama domain con source: 'webhook'

Domain SIEMPRE:
- Usa `createAdminClient()` (bypass RLS)
- Filtra por `workspace_id` en cada query
- Emite trigger de automatizacion correspondiente
```
  </action>
  <verify>SQL file exists and has valid syntax (check for common SQL issues). CLAUDE.md contains "Regla 3: Domain Layer" section.</verify>
  <done>mutation_audit migration ready for deployment. CLAUDE.md contains permanent domain layer rule.</done>
</task>

</tasks>

<verification>
1. `src/lib/domain/types.ts` exists with DomainContext and DomainResult types
2. `src/lib/domain/index.ts` exists and re-exports types
3. types.ts has zero `import ... from '@/` lines
4. SQL migration file exists with mutation_audit table + 7 triggers
5. CLAUDE.md has "Regla 3: Domain Layer" section
6. `npx tsc --noEmit` passes (no TypeScript errors introduced)
</verification>

<success_criteria>
- DomainContext and DomainResult types compile and are importable
- Migration SQL is complete and ready to apply
- CLAUDE.md rule is permanent and clear
- No circular dependencies possible (zero-import types file)
</success_criteria>

<output>
After completion, create `.planning/phases/18-domain-layer-foundation/18-01-SUMMARY.md`
</output>
