---
phase: 06-orders
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/actions/pipelines.ts
  - src/app/(dashboard)/crm/configuracion/pipelines/page.tsx
  - src/app/(dashboard)/crm/configuracion/pipelines/components/pipeline-list.tsx
  - src/app/(dashboard)/crm/configuracion/pipelines/components/pipeline-form.tsx
  - src/app/(dashboard)/crm/configuracion/pipelines/components/stage-manager.tsx
autonomous: true

must_haves:
  truths:
    - "User can create multiple pipelines per workspace"
    - "User can add, edit, and delete stages within a pipeline"
    - "User can reorder stages via drag-and-drop"
    - "Each stage has name, color, and optional WIP limit"
    - "Default pipeline is created on first access"
  artifacts:
    - path: "src/app/actions/pipelines.ts"
      provides: "Server Actions for pipeline and stage CRUD"
      exports: ["getPipelines", "createPipeline", "createStage", "updateStageOrder", "deleteStage"]
    - path: "src/app/(dashboard)/crm/configuracion/pipelines/page.tsx"
      provides: "Pipeline configuration page"
    - path: "src/app/(dashboard)/crm/configuracion/pipelines/components/stage-manager.tsx"
      provides: "Stage list with drag-and-drop reordering"
  key_links:
    - from: "stage-manager.tsx"
      to: "actions/pipelines.ts"
      via: "Server Action for reorder"
      pattern: "updateStageOrder"
    - from: "stage-manager.tsx"
      to: "@dnd-kit/sortable"
      via: "DnD for stage reorder"
      pattern: "SortableContext"
---

<objective>
Create pipeline and stage management allowing workspace admins to configure their Kanban workflows.

Purpose: Pipelines define the stages (columns) of the Kanban board; must be configurable before orders can be created
Output: Pipeline settings page with stage management including drag-to-reorder
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-orders/06-CONTEXT.md
@.planning/phases/06-orders/06-RESEARCH.md
@.planning/phases/06-orders/06-01-SUMMARY.md
@src/lib/orders/types.ts
@src/app/actions/contacts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @dnd-kit and create pipeline Server Actions</name>
  <files>
    package.json
    src/app/actions/pipelines.ts
  </files>
  <action>
**1. Install @dnd-kit packages:**
```bash
pnpm add @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

**2. Create src/app/actions/pipelines.ts:**

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import type { Pipeline, PipelineStage, PipelineFormData, StageFormData } from '@/lib/orders/types'

// Validation schemas
const pipelineSchema = z.object({
  name: z.string().min(1, 'Nombre es requerido').max(100),
  description: z.string().optional().nullable(),
  is_default: z.boolean().optional().default(false),
})

const stageSchema = z.object({
  name: z.string().min(1, 'Nombre es requerido').max(50),
  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Color invalido').default('#6366f1'),
  position: z.number().int().min(0).optional(),
  wip_limit: z.number().int().min(1).optional().nullable(),
  is_closed: z.boolean().optional().default(false),
})

// Default stages for new pipeline
const DEFAULT_STAGES = [
  { name: 'Nuevo', color: '#6366f1', position: 0 },
  { name: 'En Proceso', color: '#f59e0b', position: 1 },
  { name: 'Ganado', color: '#10b981', position: 2, is_closed: true },
  { name: 'Perdido', color: '#ef4444', position: 3, is_closed: true },
]

// Get all pipelines with stages
export async function getPipelines(): Promise<{ data: Pipeline[] | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('pipelines')
    .select(`
      *,
      stages:pipeline_stages(*)
    `)
    .order('is_default', { ascending: false })
    .order('name')

  if (error) return { data: null, error: error.message }

  // Sort stages by position within each pipeline
  const pipelines = data?.map(p => ({
    ...p,
    stages: p.stages?.sort((a: PipelineStage, b: PipelineStage) => a.position - b.position),
  }))

  return { data: pipelines, error: null }
}

// Get single pipeline with stages
export async function getPipeline(id: string): Promise<{ data: Pipeline | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('pipelines')
    .select(`
      *,
      stages:pipeline_stages(*)
    `)
    .eq('id', id)
    .single()

  if (error) return { data: null, error: error.message }

  // Sort stages by position
  if (data.stages) {
    data.stages.sort((a: PipelineStage, b: PipelineStage) => a.position - b.position)
  }

  return { data, error: null }
}

// Get or create default pipeline
export async function getOrCreateDefaultPipeline(): Promise<{ data: Pipeline | null; error: string | null }> {
  const supabase = await createClient()

  // Try to find default pipeline
  const { data: existing } = await supabase
    .from('pipelines')
    .select(`*, stages:pipeline_stages(*)`)
    .eq('is_default', true)
    .single()

  if (existing) {
    existing.stages?.sort((a: PipelineStage, b: PipelineStage) => a.position - b.position)
    return { data: existing, error: null }
  }

  // Create default pipeline with stages
  const { data: pipeline, error: pipelineError } = await supabase
    .from('pipelines')
    .insert({ name: 'Ventas', is_default: true })
    .select()
    .single()

  if (pipelineError) return { data: null, error: pipelineError.message }

  // Create default stages
  const stagesToInsert = DEFAULT_STAGES.map(s => ({
    ...s,
    pipeline_id: pipeline.id,
  }))

  const { error: stagesError } = await supabase
    .from('pipeline_stages')
    .insert(stagesToInsert)

  if (stagesError) return { data: null, error: stagesError.message }

  // Fetch complete pipeline
  return getPipeline(pipeline.id)
}

// Create pipeline
export async function createPipeline(formData: PipelineFormData): Promise<{ data: Pipeline | null; error: string | null }> {
  const validation = pipelineSchema.safeParse(formData)
  if (!validation.success) {
    return { data: null, error: validation.error.issues[0].message }
  }

  const supabase = await createClient()

  const { data, error } = await supabase
    .from('pipelines')
    .insert(validation.data)
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      return { data: null, error: 'Ya existe un pipeline con este nombre' }
    }
    return { data: null, error: error.message }
  }

  // Create default stages
  const stagesToInsert = DEFAULT_STAGES.map(s => ({
    ...s,
    pipeline_id: data.id,
  }))

  await supabase.from('pipeline_stages').insert(stagesToInsert)

  revalidatePath('/crm/configuracion/pipelines')
  return getPipeline(data.id)
}

// Update pipeline
export async function updatePipeline(id: string, formData: Partial<PipelineFormData>): Promise<{ data: Pipeline | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('pipelines')
    .update({ ...formData, updated_at: new Date().toISOString() })
    .eq('id', id)
    .select()
    .single()

  if (error) return { data: null, error: error.message }

  revalidatePath('/crm/configuracion/pipelines')
  return { data, error: null }
}

// Delete pipeline (only if not default and has no orders)
export async function deletePipeline(id: string): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  // Check if default
  const { data: pipeline } = await supabase
    .from('pipelines')
    .select('is_default')
    .eq('id', id)
    .single()

  if (pipeline?.is_default) {
    return { success: false, error: 'No se puede eliminar el pipeline por defecto' }
  }

  // Check for orders
  const { count } = await supabase
    .from('orders')
    .select('*', { count: 'exact', head: true })
    .eq('pipeline_id', id)

  if (count && count > 0) {
    return { success: false, error: `Este pipeline tiene ${count} pedidos. Muevelos antes de eliminar.` }
  }

  const { error } = await supabase.from('pipelines').delete().eq('id', id)

  if (error) return { success: false, error: error.message }

  revalidatePath('/crm/configuracion/pipelines')
  return { success: true, error: null }
}

// --- Stage Operations ---

// Create stage
export async function createStage(pipelineId: string, formData: StageFormData): Promise<{ data: PipelineStage | null; error: string | null }> {
  const validation = stageSchema.safeParse(formData)
  if (!validation.success) {
    return { data: null, error: validation.error.issues[0].message }
  }

  const supabase = await createClient()

  // Get max position
  const { data: stages } = await supabase
    .from('pipeline_stages')
    .select('position')
    .eq('pipeline_id', pipelineId)
    .order('position', { ascending: false })
    .limit(1)

  const nextPosition = stages && stages.length > 0 ? stages[0].position + 1 : 0

  const { data, error } = await supabase
    .from('pipeline_stages')
    .insert({
      ...validation.data,
      pipeline_id: pipelineId,
      position: formData.position ?? nextPosition,
    })
    .select()
    .single()

  if (error) return { data: null, error: error.message }

  revalidatePath('/crm/configuracion/pipelines')
  return { data, error: null }
}

// Update stage
export async function updateStage(id: string, formData: Partial<StageFormData>): Promise<{ data: PipelineStage | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('pipeline_stages')
    .update(formData)
    .eq('id', id)
    .select()
    .single()

  if (error) return { data: null, error: error.message }

  revalidatePath('/crm/configuracion/pipelines')
  return { data, error: null }
}

// Update stage positions (for drag reorder)
export async function updateStageOrder(pipelineId: string, stageIds: string[]): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  // Update each stage's position
  const updates = stageIds.map((id, index) =>
    supabase
      .from('pipeline_stages')
      .update({ position: index })
      .eq('id', id)
      .eq('pipeline_id', pipelineId)
  )

  const results = await Promise.all(updates)
  const errors = results.filter(r => r.error)

  if (errors.length > 0) {
    return { success: false, error: 'Error actualizando posiciones' }
  }

  revalidatePath('/crm/configuracion/pipelines')
  return { success: true, error: null }
}

// Delete stage (only if no orders in that stage)
export async function deleteStage(id: string): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  // Check for orders
  const { count } = await supabase
    .from('orders')
    .select('*', { count: 'exact', head: true })
    .eq('stage_id', id)

  if (count && count > 0) {
    return { success: false, error: `Esta etapa tiene ${count} pedidos. Muevelos antes de eliminar.` }
  }

  const { error } = await supabase.from('pipeline_stages').delete().eq('id', id)

  if (error) return { success: false, error: error.message }

  revalidatePath('/crm/configuracion/pipelines')
  return { success: true, error: null }
}
```
  </action>
  <verify>
Run: `pnpm tsc --noEmit` - No TypeScript errors
Check: @dnd-kit packages in package.json
  </verify>
  <done>
@dnd-kit installed, Server Actions for pipeline and stage CRUD with reorder support
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline configuration UI with stage manager</name>
  <files>
    src/app/(dashboard)/crm/configuracion/pipelines/page.tsx
    src/app/(dashboard)/crm/configuracion/pipelines/components/pipeline-list.tsx
    src/app/(dashboard)/crm/configuracion/pipelines/components/pipeline-form.tsx
    src/app/(dashboard)/crm/configuracion/pipelines/components/stage-manager.tsx
  </files>
  <action>
Create pipeline configuration UI:

**1. page.tsx:**
- Async Server Component
- Fetch pipelines via getPipelines()
- If no pipelines, call getOrCreateDefaultPipeline()
- Title: "Configuracion de Pipelines"
- Subtitle: "Administra los pipelines y etapas de tu flujo de trabajo"

**2. pipeline-list.tsx:**
- Client component showing all pipelines as cards/accordions
- Each pipeline card shows:
  - Name, description, default badge
  - "Editar" and "Eliminar" buttons
  - StageManager component for its stages
- "Nuevo Pipeline" button at top
- Expand/collapse for each pipeline

**3. pipeline-form.tsx:**
- Dialog form for create/edit pipeline
- Fields: name (required), description (optional), is_default (checkbox)
- Validation feedback
- Toast on success/error

**4. stage-manager.tsx (key component):**
- Shows stages as sortable list using @dnd-kit/sortable
- Each stage item shows:
  - Drag handle (GripVertical icon)
  - Color dot (colored by stage.color)
  - Name
  - WIP limit badge if set
  - "Cerrado" badge if is_closed
  - Edit and Delete buttons
- DndContext + SortableContext for drag reorder
- On drag end: call updateStageOrder() Server Action
- "Agregar Etapa" button at bottom
- Stage form dialog for add/edit:
  - Name (required)
  - Color picker (predefined palette + custom hex)
  - WIP limit (optional number)
  - Is closed (checkbox)

Color palette presets (same as tags):
```typescript
const STAGE_COLORS = [
  '#6366f1', // indigo
  '#8b5cf6', // violet
  '#ec4899', // pink
  '#ef4444', // red
  '#f59e0b', // amber
  '#10b981', // emerald
  '#06b6d4', // cyan
  '#3b82f6', // blue
  '#6b7280', // gray
]
```

Use @dnd-kit patterns from research:
- DndContext with PointerSensor and KeyboardSensor
- SortableContext with verticalListSortingStrategy
- useSortable hook for each stage item
- CSS.Transform.toString for style
  </action>
  <verify>
Navigate to /crm/configuracion/pipelines - Page renders
Test: Create pipeline, add/edit/delete stages, drag to reorder
Run: `pnpm tsc --noEmit`
  </verify>
  <done>
Pipeline configuration page with stage management, drag-to-reorder stages, color picker, WIP limit config
  </done>
</task>

</tasks>

<verification>
1. @dnd-kit packages installed: check package.json
2. Pipeline page accessible at /crm/configuracion/pipelines
3. Default "Ventas" pipeline auto-created on first visit
4. Can create new pipeline with custom name
5. Can add stages with name, color, WIP limit
6. Can drag stages to reorder (positions update in DB)
7. Can edit and delete stages (with order protection)
8. Can delete non-default pipelines (with order protection)
</verification>

<success_criteria>
- Multi-pipeline support with configurable stages
- Stage drag-to-reorder using @dnd-kit
- Color picker for stage colors
- WIP limit configuration per stage
- Default pipeline auto-created on first access
- Cannot delete stages/pipelines with existing orders
</success_criteria>

<output>
After completion, create `.planning/phases/06-orders/06-03-SUMMARY.md`
</output>
