---
phase: 11-shopify-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/shopify/hmac.ts
  - src/lib/shopify/phone-normalizer.ts
  - src/lib/shopify/contact-matcher.ts
autonomous: true

must_haves:
  truths:
    - "Webhook requests are verified as authentic before processing"
    - "Phone normalization handles Shopify formats with country codes"
    - "Contact matcher tries phone first, then fuzzy name+city"
    - "Fuzzy matches are always flagged for human verification"
  artifacts:
    - path: "src/lib/shopify/hmac.ts"
      provides: "HMAC verification for Shopify webhooks"
      exports: ["verifyShopifyHmac"]
    - path: "src/lib/shopify/phone-normalizer.ts"
      provides: "Phone normalization for Shopify numbers"
      exports: ["normalizeShopifyPhone"]
    - path: "src/lib/shopify/contact-matcher.ts"
      provides: "Contact matching with phone and fuzzy logic"
      exports: ["matchContact"]
  key_links:
    - from: "src/lib/shopify/contact-matcher.ts"
      to: "src/lib/shopify/phone-normalizer.ts"
      via: "import normalizeShopifyPhone"
      pattern: "import.*normalizeShopifyPhone"
---

<objective>
Create core utilities for Shopify webhook processing.

Purpose: Build the security (HMAC verification) and matching (phone + fuzzy) utilities needed for webhook handling.
Output: Utility functions for HMAC verification, phone normalization, and intelligent contact matching.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-shopify-integration/11-CONTEXT.md
@.planning/phases/11-shopify-integration/11-RESEARCH.md

# Existing phone utility to reference:
@src/lib/utils/phone.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: HMAC verification utility</name>
  <files>src/lib/shopify/hmac.ts</files>
  <action>
Create HMAC verification following Shopify's official pattern:

```typescript
import crypto from 'crypto'

/**
 * Verifies a Shopify webhook HMAC signature.
 * CRITICAL: Must use raw body string (before JSON parsing) for verification.
 * Uses timing-safe comparison to prevent timing attacks.
 *
 * @param rawBody - The raw request body as a string (NOT parsed JSON)
 * @param hmacHeader - The X-Shopify-Hmac-SHA256 header value
 * @param apiSecret - The Shopify API Secret Key (NOT the access token)
 * @returns true if signature is valid
 */
export function verifyShopifyHmac(
  rawBody: string,
  hmacHeader: string,
  apiSecret: string
): boolean {
  // Generate HMAC using SHA-256 and API secret
  const generatedHmac = crypto
    .createHmac('sha256', apiSecret)
    .update(rawBody, 'utf8')
    .digest('base64')

  try {
    // Use timing-safe comparison to prevent timing attacks
    return crypto.timingSafeEqual(
      Buffer.from(generatedHmac),
      Buffer.from(hmacHeader)
    )
  } catch {
    // If buffers have different lengths, timingSafeEqual throws
    return false
  }
}
```

Add detailed JSDoc explaining:
- Why raw body must be used (HMAC computed on exact bytes sent)
- Why timing-safe comparison matters (prevents attackers measuring response time)
- Difference between API Secret and Access Token
  </action>
  <verify>Unit test with known Shopify HMAC values if available, otherwise verify function compiles and signature of valid/invalid payloads differ.</verify>
  <done>verifyShopifyHmac function correctly validates HMAC signatures using timing-safe comparison.</done>
</task>

<task type="auto">
  <name>Task 2: Phone normalization for Shopify</name>
  <files>src/lib/shopify/phone-normalizer.ts</files>
  <action>
Create extended phone normalization that handles Shopify's international formats:

```typescript
import { parsePhoneNumber } from 'libphonenumber-js'

/**
 * Normalizes a phone number from Shopify to E.164 format.
 * Shopify phones may include country codes in various formats.
 *
 * Examples:
 * - "+1 555-123-4567" -> "+15551234567"
 * - "+57 300 123 4567" -> "+573001234567"
 * - "573001234567" -> "+573001234567"
 *
 * @param phone - Phone number from Shopify customer data
 * @returns E.164 formatted phone or null if invalid/unparseable
 */
export function normalizeShopifyPhone(phone: string | null | undefined): string | null {
  if (!phone) return null

  // Clean the input - remove spaces, dashes, parentheses
  const cleaned = phone.trim().replace(/[\s\-\(\)\.]/g, '')
  if (!cleaned) return null

  try {
    // Try parsing with automatic country detection (Shopify usually includes country code)
    let phoneNumber = parsePhoneNumber(cleaned)

    if (phoneNumber && phoneNumber.isValid()) {
      return phoneNumber.format('E.164')
    }

    // Fallback: try with CO (Colombia) default for local numbers
    const coPhone = parsePhoneNumber(cleaned, 'CO')
    if (coPhone && coPhone.isValid()) {
      return coPhone.format('E.164')
    }

    return null
  } catch {
    return null
  }
}

/**
 * Extracts phone from shipping or billing address if customer phone is missing.
 * Shopify orders may have phone in address even when customer.phone is null.
 */
export function extractPhoneFromOrder(order: {
  phone?: string | null
  customer?: { phone?: string | null } | null
  shipping_address?: { phone?: string | null } | null
  billing_address?: { phone?: string | null } | null
}): string | null {
  // Priority: order.phone > customer.phone > shipping.phone > billing.phone
  const candidates = [
    order.phone,
    order.customer?.phone,
    order.shipping_address?.phone,
    order.billing_address?.phone,
  ]

  for (const phone of candidates) {
    const normalized = normalizeShopifyPhone(phone)
    if (normalized) return normalized
  }

  return null
}
```

Key differences from existing phone.ts:
- Does NOT restrict to Colombian numbers only (Shopify is international)
- Tries automatic country detection first
- Falls back to CO for ambiguous local formats
- Provides extractPhoneFromOrder for complete order phone extraction
  </action>
  <verify>Test with various Shopify phone formats: "+1 555-123-4567", "+57 300 123 4567", "573001234567".</verify>
  <done>normalizeShopifyPhone handles international Shopify formats. extractPhoneFromOrder checks all order phone fields.</done>
</task>

<task type="auto">
  <name>Task 3: Contact matching with fuzzy logic</name>
  <files>src/lib/shopify/contact-matcher.ts</files>
  <action>
First, install dependencies:
```bash
pnpm add fuse.js talisman
```

Create intelligent contact matcher:

```typescript
import Fuse from 'fuse.js'
import doubleMetaphone from 'talisman/phonetics/double-metaphone'
import { createAdminClient } from '@/lib/supabase/admin'
import { normalizeShopifyPhone, extractPhoneFromOrder } from './phone-normalizer'
import type { ShopifyOrderWebhook, ContactMatchResult } from './types'

/**
 * Attempts to match a Shopify order customer to an existing contact.
 * Strategy:
 * 1. First, try exact phone match (E.164 normalized)
 * 2. If enabled, try fuzzy name+city matching with phonetic algorithms
 * 3. Fuzzy matches are ALWAYS flagged for human verification
 *
 * @param order - Shopify order webhook payload
 * @param workspaceId - Target workspace
 * @param options - Matching options
 * @returns Match result with confidence and verification flag
 */
export async function matchContact(
  order: ShopifyOrderWebhook,
  workspaceId: string,
  options: { enableFuzzyMatching: boolean }
): Promise<ContactMatchResult> {
  const supabase = createAdminClient()

  // Step 1: Try exact phone match
  const phone = extractPhoneFromOrder(order)
  if (phone) {
    const { data: contact } = await supabase
      .from('contacts')
      .select('id, name, phone')
      .eq('workspace_id', workspaceId)
      .eq('phone', phone)
      .single()

    if (contact) {
      return {
        contact,
        matchType: 'phone',
        confidence: 1.0,
        needsVerification: false,
      }
    }
  }

  // Step 2: Fuzzy name+city matching (if enabled)
  if (options.enableFuzzyMatching && order.customer?.first_name) {
    const customerName = buildCustomerName(order.customer)
    const customerCity = order.shipping_address?.city || order.billing_address?.city || ''

    if (customerName) {
      // Get all contacts in workspace for fuzzy matching
      const { data: contacts } = await supabase
        .from('contacts')
        .select('id, name, phone, city')
        .eq('workspace_id', workspaceId)
        .limit(1000) // Reasonable limit for fuzzy search

      if (contacts && contacts.length > 0) {
        const match = findFuzzyMatch(customerName, customerCity, contacts)
        if (match) {
          return match
        }
      }
    }
  }

  // No match found
  return {
    contact: null,
    matchType: 'none',
    confidence: 0,
    needsVerification: false,
  }
}

/**
 * Builds full customer name from Shopify customer data.
 */
function buildCustomerName(customer: {
  first_name?: string | null
  last_name?: string | null
}): string {
  const parts = [customer.first_name, customer.last_name]
    .filter(Boolean)
    .map(s => s!.trim())
  return parts.join(' ')
}

/**
 * Finds best fuzzy match using Fuse.js and phonetic algorithms.
 */
function findFuzzyMatch(
  customerName: string,
  customerCity: string,
  contacts: Array<{ id: string; name: string; phone: string; city: string | null }>
): ContactMatchResult | null {
  // Get phonetic code for customer name
  const customerPhonetic = doubleMetaphone(customerName.toLowerCase())

  // Prepare contacts with phonetic codes and combined name+city
  const contactsWithMeta = contacts.map(c => ({
    ...c,
    phonetic: doubleMetaphone(c.name.toLowerCase()),
    nameCity: `${c.name} ${c.city || ''}`.toLowerCase(),
  }))

  // Fuse.js for fuzzy string matching
  const fuse = new Fuse(contactsWithMeta, {
    keys: ['nameCity'],
    threshold: 0.4, // 0 = exact, 1 = match anything
    includeScore: true,
  })

  const searchTerm = `${customerName} ${customerCity}`.toLowerCase()
  const results = fuse.search(searchTerm)

  if (results.length === 0) {
    return null
  }

  // Take best match
  const best = results[0]
  const fuseScore = best.score || 1

  // Additional phonetic check for "sounds like" matching
  const phoneticMatch =
    best.item.phonetic[0] === customerPhonetic[0] ||
    best.item.phonetic[1] === customerPhonetic[1]

  // Combined confidence: Fuse score (inverted) + phonetic boost
  let confidence = 1 - fuseScore
  if (phoneticMatch) {
    confidence = Math.min(confidence + 0.2, 0.95) // Boost but cap at 95%
  }

  // Only return if confidence is reasonable (>40%)
  if (confidence < 0.4) {
    return null
  }

  return {
    contact: {
      id: best.item.id,
      name: best.item.name,
      phone: best.item.phone,
    },
    matchType: 'fuzzy',
    confidence,
    needsVerification: true, // ALWAYS flag fuzzy matches for human verification
  }
}
```

Key design decisions per CONTEXT.md:
- Fuzzy matches ALWAYS set needsVerification: true
- Phonetic matching uses Double Metaphone (better than Soundex for non-English names)
- Combined Fuse.js + phonetic for best matching
- Confidence threshold of 40% to avoid false positives
  </action>
  <verify>`pnpm tsc --noEmit` passes. Manual test with sample data if feasible.</verify>
  <done>matchContact function implements tiered contact matching with phone-first, fuzzy-second strategy. All fuzzy matches flagged for verification.</done>
</task>

</tasks>

<verification>
1. All three utility files compile without errors
2. HMAC verification uses timing-safe comparison
3. Phone normalizer handles international formats
4. Contact matcher correctly priorities phone over fuzzy
5. Fuzzy matches always have needsVerification: true
</verification>

<success_criteria>
- Webhook HMAC can be verified securely
- Shopify phone numbers normalize to E.164 for matching
- Contact matching implements the tiered strategy from CONTEXT.md
- All fuzzy matches require human verification
</success_criteria>

<output>
After completion, create `.planning/phases/11-shopify-integration/11-02-SUMMARY.md`
</output>
