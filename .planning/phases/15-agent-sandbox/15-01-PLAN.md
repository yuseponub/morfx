---
phase: 15-agent-sandbox
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/sandbox/types.ts
  - src/lib/sandbox/sandbox-engine.ts
  - src/lib/sandbox/sandbox-session.ts
  - src/app/(dashboard)/sandbox/components/typing-indicator.tsx
  - src/app/(dashboard)/sandbox/components/typing-indicator.css
autonomous: true

must_haves:
  truths:
    - "Sandbox types define SandboxMessage, SandboxSession, DebugInfo structures"
    - "SandboxEngine processes messages without writing to real database"
    - "SandboxSession stores/retrieves sessions from localStorage"
    - "Typing indicator animates with CSS keyframes"
  artifacts:
    - path: "src/lib/sandbox/types.ts"
      provides: "Type definitions for sandbox system"
      exports: ["SandboxMessage", "SandboxSession", "DebugTurn", "ToolExecution", "IntentInfo", "TokenInfo"]
    - path: "src/lib/sandbox/sandbox-engine.ts"
      provides: "In-memory engine wrapper for Somnio agent"
      exports: ["SandboxEngine"]
    - path: "src/lib/sandbox/sandbox-session.ts"
      provides: "localStorage session management"
      exports: ["saveSandboxSession", "loadSandboxSessions", "deleteSandboxSession", "getLastAgentId", "setLastAgentId"]
    - path: "src/app/(dashboard)/sandbox/components/typing-indicator.tsx"
      provides: "Animated typing dots component"
      exports: ["TypingIndicator"]
  key_links:
    - from: "src/lib/sandbox/sandbox-engine.ts"
      to: "src/lib/agents/somnio/somnio-orchestrator.ts"
      via: "Direct import for orchestration"
      pattern: "SomnioOrchestrator"
    - from: "src/lib/sandbox/sandbox-engine.ts"
      to: "src/lib/agents/claude-client.ts"
      via: "Claude API calls"
      pattern: "ClaudeClient"
---

<objective>
Create the foundation for the sandbox system: types, in-memory engine, localStorage session management, and typing indicator animation.

Purpose: Establishes the data structures and core logic that all sandbox UI components will depend on, ensuring sandbox operations never touch real database.
Output: Type definitions, SandboxEngine class, session persistence utilities, typing indicator component.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-agent-sandbox/15-CONTEXT.md
@.planning/phases/15-agent-sandbox/15-RESEARCH.md
@src/lib/agents/types.ts
@src/lib/agents/somnio/somnio-engine.ts
@src/lib/agents/somnio/somnio-orchestrator.ts
@src/lib/agents/claude-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create sandbox types</name>
  <files>
    package.json
    src/lib/sandbox/types.ts
  </files>
  <action>
Install the two new dependencies:
```bash
npm install allotment @uiw/react-json-view
```

Create `src/lib/sandbox/types.ts` with these type definitions:

```typescript
/**
 * Sandbox Type Definitions
 * Phase 15: Agent Sandbox
 *
 * Types for the sandbox testing UI that simulates agent conversations
 * without affecting real data.
 */

import type { IntentResult, SessionState, ToolCallRecord, PackSelection } from '@/lib/agents/types'

/**
 * Message in sandbox conversation
 */
export interface SandboxMessage {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp: string // ISO string, always show HH:MM:SS
}

/**
 * Tool execution with full details for debugging
 */
export interface ToolExecution {
  name: string
  input: Record<string, unknown>
  result?: {
    success: boolean
    data?: unknown
    error?: { code: string; message: string }
  }
  durationMs?: number
  timestamp: string
}

/**
 * Intent detection info for debugging
 */
export interface IntentInfo {
  intent: string
  confidence: number
  alternatives?: { intent: string; confidence: number }[]
  reasoning?: string
  timestamp: string
}

/**
 * Token usage info for debugging
 */
export interface TokenInfo {
  turnNumber: number
  tokensUsed: number
  timestamp: string
}

/**
 * Debug information for a single turn
 */
export interface DebugTurn {
  turnNumber: number
  intent?: IntentInfo
  tools: ToolExecution[]
  tokens: TokenInfo
  stateAfter: SandboxState
}

/**
 * Sandbox session state (in-memory, not persisted to DB)
 */
export interface SandboxState {
  currentMode: string
  intentsVistos: string[]
  templatesEnviados: string[]
  datosCapturados: Record<string, string>
  packSeleccionado: PackSelection | null
}

/**
 * Saved sandbox session for localStorage
 */
export interface SavedSandboxSession {
  id: string
  name: string
  agentId: string
  messages: SandboxMessage[]
  state: SandboxState
  debugTurns: DebugTurn[]
  totalTokens: number
  createdAt: string
  updatedAt: string
}

/**
 * Active sandbox session (in-memory during testing)
 */
export interface ActiveSandboxSession {
  agentId: string
  messages: SandboxMessage[]
  state: SandboxState
  debugTurns: DebugTurn[]
  totalTokens: number
  isTyping: boolean
}

/**
 * Result from SandboxEngine.processMessage()
 */
export interface SandboxEngineResult {
  success: boolean
  /** Response messages (may be multiple for sequences) */
  messages: string[]
  /** Debug info for this turn */
  debugTurn: DebugTurn
  /** New state after processing */
  newState: SandboxState
  /** Error if failed */
  error?: { code: string; message: string }
}
```
  </action>
  <verify>
Run `npm ls allotment @uiw/react-json-view` to confirm dependencies installed.
Run `npx tsc --noEmit src/lib/sandbox/types.ts` to verify types compile.
  </verify>
  <done>
Dependencies installed, types file created with all sandbox data structures, TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SandboxEngine and session persistence</name>
  <files>
    src/lib/sandbox/sandbox-engine.ts
    src/lib/sandbox/sandbox-session.ts
    src/lib/sandbox/index.ts
  </files>
  <action>
Create `src/lib/sandbox/sandbox-engine.ts`:

```typescript
/**
 * Sandbox Engine
 * Phase 15: Agent Sandbox
 *
 * In-memory engine wrapper that uses Somnio components without
 * writing to the real database. Simulates full agent flow.
 */

import { ClaudeClient } from '@/lib/agents/claude-client'
import { IntentDetector } from '@/lib/agents/intent-detector'
import { SomnioOrchestrator } from '@/lib/agents/somnio/somnio-orchestrator'
import { somnioAgentConfig } from '@/lib/agents/somnio/config'
import { agentRegistry } from '@/lib/agents/registry'
import { mergeExtractedData } from '@/lib/agents/somnio/data-extractor'
import type { SandboxState, SandboxEngineResult, DebugTurn, ToolExecution, IntentInfo, TokenInfo } from './types'

/**
 * SandboxEngine: Processes messages using Somnio agent components
 * but stores all state in memory (no database writes).
 *
 * Key differences from real SomnioEngine:
 * - No SessionManager (state passed in/out)
 * - No MessageSequencer (returns messages array, caller handles delays)
 * - No OrderCreator (returns shouldCreateOrder flag, never creates real orders)
 */
export class SandboxEngine {
  private claudeClient: ClaudeClient
  private intentDetector: IntentDetector
  private orchestrator: SomnioOrchestrator

  constructor() {
    this.claudeClient = new ClaudeClient()
    this.intentDetector = new IntentDetector(this.claudeClient)
    this.orchestrator = new SomnioOrchestrator(this.claudeClient)
  }

  /**
   * Get initial state for a new sandbox session.
   */
  getInitialState(): SandboxState {
    return {
      currentMode: somnioAgentConfig.initialState,
      intentsVistos: [],
      templatesEnviados: [],
      datosCapturados: {},
      packSeleccionado: null,
    }
  }

  /**
   * Process a customer message through the Somnio agent.
   *
   * @param message - Customer message content
   * @param currentState - Current sandbox state
   * @param history - Conversation history
   * @param turnNumber - Current turn number (for debug tracking)
   */
  async processMessage(
    message: string,
    currentState: SandboxState,
    history: { role: 'user' | 'assistant'; content: string }[],
    turnNumber: number
  ): Promise<SandboxEngineResult> {
    const startTime = Date.now()
    const tools: ToolExecution[] = []
    let totalTokens = 0

    try {
      const agentConfig = agentRegistry.get(somnioAgentConfig.id)

      // 1. Detect intent
      const intentStart = Date.now()
      const { intent, action, tokensUsed: intentTokens } = await this.intentDetector.detect(
        message,
        history,
        {
          systemPrompt: agentConfig.intentDetector.systemPrompt,
          model: agentConfig.intentDetector.model,
          thresholds: agentConfig.confidenceThresholds,
        }
      )
      totalTokens += intentTokens

      const intentInfo: IntentInfo = {
        intent: intent.intent,
        confidence: intent.confidence,
        alternatives: intent.alternatives,
        reasoning: intent.reasoning,
        timestamp: new Date().toISOString(),
      }

      // 2. Update intents_vistos
      const newIntentsVistos = [...currentState.intentsVistos]
      if (!newIntentsVistos.includes(intent.intent)) {
        newIntentsVistos.push(intent.intent)
      }

      // 3. Handle handoff
      if (action === 'handoff') {
        const handoffState: SandboxState = {
          ...currentState,
          currentMode: 'handoff',
          intentsVistos: newIntentsVistos,
        }

        const debugTurn: DebugTurn = {
          turnNumber,
          intent: intentInfo,
          tools: [],
          tokens: { turnNumber, tokensUsed: totalTokens, timestamp: new Date().toISOString() },
          stateAfter: handoffState,
        }

        return {
          success: true,
          messages: ['Voy a transferirte con un asesor humano para atenderte mejor. Un momento por favor.'],
          debugTurn,
          newState: handoffState,
        }
      }

      // 4. Build mock session for orchestrator
      const mockSession = {
        id: 'sandbox-session',
        agentId: somnioAgentConfig.id,
        conversationId: 'sandbox-conversation',
        contactId: 'sandbox-contact',
        workspaceId: 'sandbox-workspace',
        version: 1,
        status: 'active' as const,
        currentMode: currentState.currentMode,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        lastActivityAt: new Date().toISOString(),
        state: {
          session_id: 'sandbox-session',
          intents_vistos: newIntentsVistos.map((i, idx) => ({
            intent: i,
            orden: idx + 1,
            timestamp: new Date().toISOString(),
          })),
          templates_enviados: currentState.templatesEnviados,
          datos_capturados: currentState.datosCapturados,
          pack_seleccionado: currentState.packSeleccionado,
          proactive_started_at: null,
          first_data_at: null,
          min_data_at: null,
          ofrecer_promos_at: null,
          updated_at: new Date().toISOString(),
        },
      }

      // 5. Orchestrate response
      const orchestratorResult = await this.orchestrator.orchestrate(
        intent,
        mockSession,
        message,
        history
      )
      totalTokens += orchestratorResult.tokensUsed ?? 0

      // 6. Build new state
      const newState: SandboxState = {
        currentMode: orchestratorResult.nextMode ?? currentState.currentMode,
        intentsVistos: newIntentsVistos,
        templatesEnviados: orchestratorResult.stateUpdates?.templatesSent
          ? [...currentState.templatesEnviados, ...orchestratorResult.stateUpdates.templatesSent]
          : currentState.templatesEnviados,
        datosCapturados: orchestratorResult.stateUpdates?.datosCapturados
          ? mergeExtractedData(currentState.datosCapturados, orchestratorResult.stateUpdates.datosCapturados)
          : currentState.datosCapturados,
        packSeleccionado: orchestratorResult.stateUpdates?.packSeleccionado ?? currentState.packSeleccionado,
      }

      // 7. Extract response messages
      const messages: string[] = []
      if (orchestratorResult.response) {
        messages.push(orchestratorResult.response)
      }
      if (orchestratorResult.templates) {
        for (const template of orchestratorResult.templates) {
          messages.push(template.content)
        }
      }

      // If shouldCreateOrder is true, add a note (no real order creation)
      if (orchestratorResult.shouldCreateOrder) {
        messages.push('[SANDBOX: Order would be created here with pack: ' + newState.packSeleccionado + ']')
      }

      const debugTurn: DebugTurn = {
        turnNumber,
        intent: intentInfo,
        tools, // Tool executions would be populated if we had tool calls
        tokens: { turnNumber, tokensUsed: totalTokens, timestamp: new Date().toISOString() },
        stateAfter: newState,
      }

      return {
        success: true,
        messages: messages.length > 0 ? messages : ['[No response generated]'],
        debugTurn,
        newState,
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'

      return {
        success: false,
        messages: [],
        debugTurn: {
          turnNumber,
          tools,
          tokens: { turnNumber, tokensUsed: totalTokens, timestamp: new Date().toISOString() },
          stateAfter: currentState,
        },
        newState: currentState,
        error: { code: 'SANDBOX_ERROR', message: errorMessage },
      }
    }
  }
}
```

Create `src/lib/sandbox/sandbox-session.ts`:

```typescript
/**
 * Sandbox Session Persistence
 * Phase 15: Agent Sandbox
 *
 * localStorage utilities for saving/loading sandbox sessions.
 */

import type { SavedSandboxSession } from './types'

const SESSIONS_KEY = 'morfx:sandbox:sessions'
const LAST_AGENT_KEY = 'morfx:sandbox:last-agent'
const MAX_SESSIONS = 20 // Prevent localStorage quota issues

/**
 * Load all saved sandbox sessions from localStorage.
 */
export function loadSandboxSessions(): SavedSandboxSession[] {
  try {
    const data = localStorage.getItem(SESSIONS_KEY)
    if (!data) return []
    return JSON.parse(data) as SavedSandboxSession[]
  } catch {
    return []
  }
}

/**
 * Save a sandbox session to localStorage.
 * Prunes old sessions if over MAX_SESSIONS limit.
 */
export function saveSandboxSession(session: SavedSandboxSession): void {
  try {
    const sessions = loadSandboxSessions()

    // Check if updating existing session
    const existingIndex = sessions.findIndex(s => s.id === session.id)
    if (existingIndex >= 0) {
      sessions[existingIndex] = { ...session, updatedAt: new Date().toISOString() }
    } else {
      sessions.unshift(session) // Add to beginning (most recent first)
    }

    // Prune old sessions
    const prunedSessions = sessions.slice(0, MAX_SESSIONS)

    localStorage.setItem(SESSIONS_KEY, JSON.stringify(prunedSessions))
  } catch (error) {
    // localStorage quota exceeded or private browsing
    console.warn('Failed to save sandbox session:', error)
  }
}

/**
 * Delete a sandbox session from localStorage.
 */
export function deleteSandboxSession(sessionId: string): void {
  try {
    const sessions = loadSandboxSessions()
    const filtered = sessions.filter(s => s.id !== sessionId)
    localStorage.setItem(SESSIONS_KEY, JSON.stringify(filtered))
  } catch {
    // Ignore errors
  }
}

/**
 * Get the last used agent ID.
 */
export function getLastAgentId(): string | null {
  try {
    return localStorage.getItem(LAST_AGENT_KEY)
  } catch {
    return null
  }
}

/**
 * Save the last used agent ID.
 */
export function setLastAgentId(agentId: string): void {
  try {
    localStorage.setItem(LAST_AGENT_KEY, agentId)
  } catch {
    // Ignore errors
  }
}

/**
 * Generate a unique session ID.
 */
export function generateSessionId(): string {
  return `sandbox-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
}
```

Create `src/lib/sandbox/index.ts`:

```typescript
/**
 * Sandbox Module Exports
 * Phase 15: Agent Sandbox
 */

export * from './types'
export * from './sandbox-engine'
export * from './sandbox-session'
```
  </action>
  <verify>
Run `npx tsc --noEmit src/lib/sandbox/index.ts` to verify all sandbox modules compile.
Check that SandboxEngine can be imported without errors.
  </verify>
  <done>
SandboxEngine class created that processes messages using real Claude/Orchestrator but keeps state in memory.
Session persistence utilities created with localStorage save/load/delete and pruning.
All modules export correctly from index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create typing indicator component</name>
  <files>
    src/app/(dashboard)/sandbox/components/typing-indicator.tsx
    src/app/(dashboard)/sandbox/components/typing-indicator.css
  </files>
  <action>
Create directories first:
```bash
mkdir -p src/app/\(dashboard\)/sandbox/components
```

Create `src/app/(dashboard)/sandbox/components/typing-indicator.css`:

```css
/**
 * Typing Indicator Animation
 * Phase 15: Agent Sandbox
 *
 * CSS keyframes for the "typing..." dots animation.
 * Source pattern: https://dev.to/3mustard/create-a-typing-animation-in-react-17o0
 */

.typing-indicator {
  display: flex;
  gap: 4px;
  padding: 8px 12px;
  background: hsl(var(--muted));
  border-radius: 12px;
  width: fit-content;
}

.typing-indicator span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: hsl(var(--muted-foreground));
  animation: typing 1.4s infinite ease-in-out both;
}

.typing-indicator span:nth-child(1) {
  animation-delay: -0.32s;
}

.typing-indicator span:nth-child(2) {
  animation-delay: -0.16s;
}

.typing-indicator span:nth-child(3) {
  animation-delay: 0s;
}

@keyframes typing {
  0%, 80%, 100% {
    transform: scale(0.6);
    opacity: 0.4;
  }
  40% {
    transform: scale(1);
    opacity: 1;
  }
}
```

Create `src/app/(dashboard)/sandbox/components/typing-indicator.tsx`:

```typescript
'use client'

/**
 * Typing Indicator Component
 * Phase 15: Agent Sandbox
 *
 * Animated "typing..." dots that appear when agent is processing.
 * Uses CSS keyframes for smooth animation without React re-renders.
 */

import './typing-indicator.css'

interface TypingIndicatorProps {
  /** Optional className for positioning */
  className?: string
}

export function TypingIndicator({ className }: TypingIndicatorProps) {
  return (
    <div className={`typing-indicator ${className ?? ''}`} role="status" aria-label="Agent is typing">
      <span />
      <span />
      <span />
    </div>
  )
}
```
  </action>
  <verify>
Verify files exist:
```bash
ls -la src/app/\(dashboard\)/sandbox/components/
```
Run `npx tsc --noEmit src/app/\(dashboard\)/sandbox/components/typing-indicator.tsx` to verify component compiles.
  </verify>
  <done>
Typing indicator component created with CSS keyframes animation.
Three dots animate with staggered delays for realistic typing effect.
Accessible with role="status" and aria-label.
  </done>
</task>

</tasks>

<verification>
1. `npm ls allotment @uiw/react-json-view` shows both packages installed
2. `npx tsc --noEmit src/lib/sandbox/index.ts` compiles without errors
3. `npx tsc --noEmit src/app/\(dashboard\)/sandbox/components/typing-indicator.tsx` compiles without errors
4. All type definitions are properly exported
5. SandboxEngine methods have correct signatures matching types
</verification>

<success_criteria>
- allotment and @uiw/react-json-view installed in package.json
- src/lib/sandbox/types.ts exports all required types
- src/lib/sandbox/sandbox-engine.ts exports SandboxEngine class that processes messages without DB writes
- src/lib/sandbox/sandbox-session.ts exports localStorage utilities
- TypingIndicator component animates correctly with CSS
</success_criteria>

<output>
After completion, create `.planning/phases/15-agent-sandbox/15-01-SUMMARY.md`
</output>
