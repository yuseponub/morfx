---
phase: 17-crm-automations-engine
plan: 09
type: execute
wave: 5
depends_on: ["17-01", "17-04"]
files_modified:
  - src/lib/orders/types.ts
  - src/app/actions/orders.ts
  - src/app/(dashboard)/crm/orders/[id]/components/related-orders.tsx
  - src/app/(dashboard)/crm/orders/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Orders created by automations have source_order_id linking to the original"
    - "Order detail page shows related orders (both source and derived)"
    - "User can navigate between connected orders"
    - "Related orders show pipeline, stage, value, and creation date"
  artifacts:
    - path: "src/app/(dashboard)/crm/orders/[id]/components/related-orders.tsx"
      provides: "Related orders panel showing connected orders"
      exports: ["RelatedOrders"]
    - path: "src/lib/orders/types.ts"
      provides: "Updated order types with source_order_id"
      contains: "source_order_id"
  key_links:
    - from: "src/app/(dashboard)/crm/orders/[id]/components/related-orders.tsx"
      to: "src/app/actions/orders.ts"
      via: "getRelatedOrders server action"
      pattern: "getRelatedOrders"
    - from: "src/app/(dashboard)/crm/orders/[id]/page.tsx"
      to: "src/app/(dashboard)/crm/orders/[id]/components/related-orders.tsx"
      via: "Renders RelatedOrders in order detail"
      pattern: "RelatedOrders"
---

<objective>
Implement connected orders: source_order_id tracking and a related orders UI in the order detail page.

Purpose: When automations create or duplicate orders across pipelines, the connection is tracked via source_order_id. Users need to see which orders are related and navigate between them. This fulfills the CONTEXT.md requirement: "Vista de ordenes relacionadas en detalle de orden, botones para navegar entre ellas."

Output: Updated order types, server action for related orders, and a UI component in the order detail page.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-crm-automations-engine/17-CONTEXT.md
@src/lib/orders/types.ts
@src/app/actions/orders.ts
@src/app/(dashboard)/crm/orders/[id]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update order types and add related orders server action</name>
  <files>src/lib/orders/types.ts, src/app/actions/orders.ts</files>
  <action>
**File 1: src/lib/orders/types.ts**
Add `source_order_id` to the Order type (it was added to the DB in Plan 01):
```typescript
// Add to Order interface:
source_order_id: string | null
```

Add to OrderFormData if not already present:
```typescript
source_order_id?: string | null
```

Add a new type for related orders display:
```typescript
export interface RelatedOrder {
  id: string
  pipeline_name: string
  stage_name: string
  stage_emoji?: string
  contact_name: string | null
  total_value: number
  created_at: string
  relationship: 'source' | 'derived'  // Is this the parent or a child?
}
```

**File 2: src/app/actions/orders.ts**
Add a new server action `getRelatedOrders(orderId: string)`:

```typescript
export async function getRelatedOrders(orderId: string): Promise<RelatedOrder[]> {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return []

  // Get the current order to find its source_order_id
  const { data: order } = await supabase
    .from('orders')
    .select('id, source_order_id')
    .eq('id', orderId)
    .single()

  if (!order) return []

  const relatedOrders: RelatedOrder[] = []

  // 1. If this order has a source, get the source order
  if (order.source_order_id) {
    const { data: source } = await supabase
      .from('orders')
      .select(`
        id,
        total_value,
        created_at,
        pipeline_stages!inner(name, pipelines!inner(name)),
        contacts(name)
      `)
      .eq('id', order.source_order_id)
      .single()

    if (source) {
      relatedOrders.push({
        id: source.id,
        pipeline_name: source.pipeline_stages?.pipelines?.name ?? '',
        stage_name: source.pipeline_stages?.name ?? '',
        contact_name: source.contacts?.name ?? null,
        total_value: source.total_value ?? 0,
        created_at: source.created_at,
        relationship: 'source',
      })
    }
  }

  // 2. Get all orders derived from this order
  const { data: derived } = await supabase
    .from('orders')
    .select(`
      id,
      total_value,
      created_at,
      pipeline_stages!inner(name, pipelines!inner(name)),
      contacts(name)
    `)
    .eq('source_order_id', orderId)
    .order('created_at', { ascending: false })

  if (derived) {
    for (const d of derived) {
      relatedOrders.push({
        id: d.id,
        pipeline_name: d.pipeline_stages?.pipelines?.name ?? '',
        stage_name: d.pipeline_stages?.name ?? '',
        contact_name: d.contacts?.name ?? null,
        total_value: d.total_value ?? 0,
        created_at: d.created_at,
        relationship: 'derived',
      })
    }
  }

  // 3. Also get siblings (other orders derived from the same source)
  if (order.source_order_id) {
    const { data: siblings } = await supabase
      .from('orders')
      .select(`
        id,
        total_value,
        created_at,
        pipeline_stages!inner(name, pipelines!inner(name)),
        contacts(name)
      `)
      .eq('source_order_id', order.source_order_id)
      .neq('id', orderId)
      .order('created_at', { ascending: false })

    if (siblings) {
      for (const s of siblings) {
        relatedOrders.push({
          id: s.id,
          pipeline_name: s.pipeline_stages?.pipelines?.name ?? '',
          stage_name: s.pipeline_stages?.name ?? '',
          contact_name: s.contacts?.name ?? null,
          total_value: s.total_value ?? 0,
          created_at: s.created_at,
          relationship: 'derived',
        })
      }
    }
  }

  return relatedOrders
}
```

NOTE: The exact Supabase join syntax may vary based on the existing schema relationships. Read the actual orders table and join patterns before implementing. The query above is illustrative â€” adapt to match the real FK relationships (orders -> pipeline_stages via stage_id, orders -> contacts via contact_id).
  </action>
  <verify>source_order_id added to Order type. getRelatedOrders returns source, derived, and sibling orders. TypeScript compiles.</verify>
  <done>Order types updated with source_order_id. Server action returns related orders (source, derived, siblings) with pipeline/stage/value info.</done>
</task>

<task type="auto">
  <name>Task 2: Related orders UI component in order detail page</name>
  <files>
    src/app/(dashboard)/crm/orders/[id]/components/related-orders.tsx,
    src/app/(dashboard)/crm/orders/[id]/page.tsx
  </files>
  <action>
**File 1: related-orders.tsx**
'use client' component showing connected orders.

```typescript
interface RelatedOrdersProps {
  orderId: string
  relatedOrders: RelatedOrder[]
}
```

Layout:
- Section header: "Ordenes relacionadas" with Link2 icon (from lucide-react)
- If no related orders: show nothing (don't render the section at all)
- If has related orders: show as a list of compact cards:
  - Source order (if exists): highlighted with "Orden origen" label, arrow-up-left icon
  - Derived orders: "Orden derivada" label, arrow-down-right icon
  - Each card shows:
    - Pipeline name + stage name badges
    - Contact name (if available)
    - Formatted value ($XXX,XXX)
    - Relative time (hace 2 horas)
    - Click navigates to `/crm/orders/{id}`
- Style: compact Cards with hover effect, inside a collapsible section

Use Tailwind classes and shadcn components (Card, Badge).

Format currency Colombian style: `new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', minimumFractionDigits: 0 }).format(value)`

Format dates with `toLocaleDateString('es-CO', { timeZone: 'America/Bogota' })`.

**File 2: Order detail page modification**
Find the order detail page (likely `src/app/(dashboard)/crm/orders/[id]/page.tsx` or a sheet/dialog component).

Add the RelatedOrders component to the order detail view:
1. Import `getRelatedOrders` server action
2. Call it with the order ID in the server component
3. Pass result to `<RelatedOrders orderId={id} relatedOrders={relatedOrders} />`
4. Place it after the main order info section, before activity/history

If the order detail is in a Sheet (side panel) rather than a full page, the related orders section should be a collapsible accordion at the bottom to save space.

Read the actual order detail implementation to determine the correct placement.
  </action>
  <verify>Related orders component renders when related orders exist. Source order shows "Orden origen" label. Derived orders show "Orden derivada" label. Click navigates to the related order. Component hidden when no related orders. TypeScript compiles.</verify>
  <done>Related orders UI shows connected orders with navigation, distinguishes source vs derived, and integrates into order detail page.</done>
</task>

</tasks>

<verification>
1. source_order_id field present in Order type
2. getRelatedOrders returns source, derived, and sibling orders
3. Related orders component renders in order detail
4. Navigation between connected orders works
5. Component hidden when no related orders (no empty state cluttering the UI)
6. Currency and date formatting follows Colombian locale
7. TypeScript compiles without errors
</verification>

<success_criteria>
- Connected orders tracked via source_order_id
- Order detail shows related orders with bidirectional navigation
- Relationship type (source vs derived) clearly indicated
- Seamless navigation between connected orders
</success_criteria>

<output>
After completion, create `.planning/phases/17-crm-automations-engine/17-09-SUMMARY.md`
</output>
