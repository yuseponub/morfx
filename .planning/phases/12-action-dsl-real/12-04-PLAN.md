---
phase: 12-action-dsl-real
plan: 04
type: execute
wave: 3
depends_on: ["12-01", "12-02", "12-03"]
files_modified:
  - src/lib/tools/executor.ts
  - src/app/api/v1/tools/[toolName]/route.ts
autonomous: false

must_haves:
  truths:
    - "Tool execution enforces domain-specific timeouts (5s CRM, 15s WhatsApp)"
    - "Tool execution enforces rate limiting per workspace per module"
    - "Rate limit exceeded returns structured error to caller"
    - "Timeout returns structured error to caller"
    - "agent_session_id flows from ExecutionContext through to tool_executions log"
    - "API /api/v1/tools/{toolName} returns ToolResult structure in response"
    - "Every tool execution generates a forensic log with inputs, outputs, duration, and errors"
  artifacts:
    - path: "src/lib/tools/executor.ts"
      provides: "Enhanced executor with timeout, rate limiting, and agent_session_id"
      exports: ["executeTool", "executeToolFromAgent"]
    - path: "src/app/api/v1/tools/[toolName]/route.ts"
      provides: "API endpoint returning structured ToolResult responses"
      exports: ["POST", "GET"]
  key_links:
    - from: "src/lib/tools/executor.ts"
      to: "src/lib/tools/rate-limiter.ts"
      via: "rateLimiter.check() before execution"
      pattern: "rateLimiter"
    - from: "src/lib/tools/executor.ts"
      to: "src/lib/audit/tool-logger.ts"
      via: "logToolExecution with agent_session_id"
      pattern: "agent_session_id"
    - from: "src/app/api/v1/tools/[toolName]/route.ts"
      to: "src/lib/tools/executor.ts"
      via: "executeTool for API invocation"
      pattern: "executeTool"
---

<objective>
Enhance the executor with timeout enforcement and rate limiting, wire agent_session_id through the logging pipeline, and update the API route to return structured responses.

Purpose: The executor is the central entry point for all tool invocations. Adding timeout, rate limiting, and proper logging ensures every tool call is safe, bounded, and traceable.
Output: Enhanced executor.ts and updated API route with structured responses.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-action-dsl-real/12-RESEARCH.md
@.planning/phases/12-action-dsl-real/12-CONTEXT.md
@.planning/phases/12-action-dsl-real/12-01-SUMMARY.md
@.planning/phases/12-action-dsl-real/12-02-SUMMARY.md
@.planning/phases/12-action-dsl-real/12-03-SUMMARY.md
@src/lib/tools/executor.ts
@src/lib/tools/types.ts
@src/lib/tools/rate-limiter.ts
@src/app/api/v1/tools/[toolName]/route.ts
@src/lib/audit/tool-logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout and rate limiting to executor</name>
  <files>src/lib/tools/executor.ts</files>
  <action>
  Enhance `src/lib/tools/executor.ts` with timeout enforcement, rate limiting, and agent_session_id support.

  **Add imports:**
  ```typescript
  import { rateLimiter } from './rate-limiter'
  import type { ToolModule } from './types'
  ```

  **Add timeout constants at module level:**
  ```typescript
  const TIMEOUTS: Record<string, number> = {
    crm: 5_000,       // 5 seconds for DB operations
    whatsapp: 15_000,  // 15 seconds for external API
    system: 10_000,    // 10 seconds default
  }
  ```

  **Add TimeoutError class:**
  ```typescript
  class TimeoutError extends Error {
    constructor(toolName: string, timeoutMs: number) {
      super(`Tool ${toolName} timed out after ${timeoutMs}ms`)
      this.name = 'TimeoutError'
    }
  }
  ```

  **Add helper function `executeWithTimeout`:**
  - Uses `Promise.race` pattern from 12-RESEARCH.md Pattern 6
  - Gets timeout by looking up the tool's module from registry metadata
  - Wraps handler execution in race with timeout promise

  **Modify `executeTool` function:**

  1. After permission checking (step 2), BEFORE handler execution (step 3), add rate limit check:
     ```typescript
     // 2.5 Rate limit check
     const module = tool.metadata.module as ToolModule
     const rateCheck = rateLimiter.check(options.context.workspaceId, module)
     if (!rateCheck.allowed) {
       // Log rate limit hit
       if (!options.skipLogging) {
         await logToolExecution({
           workspace_id: options.context.workspaceId,
           tool_name: toolName,
           inputs: inputs as Record<string, unknown>,
           outputs: {},
           status: 'error',
           error_message: `Rate limit exceeded: ${rateCheck.remaining} remaining, resets in ${rateCheck.resetMs}ms`,
           started_at: startedAt.toISOString(),
           completed_at: new Date().toISOString(),
           duration_ms: Math.round(performance.now() - startTime),
           user_id: options.context.userId ?? undefined,
           session_id: options.context.sessionId,
           agent_session_id: options.context.agentSessionId,
           request_context: options.context.requestContext,
         })
       }
       return {
         id: crypto.randomUUID(),
         toolName,
         status: 'error' as const,
         outputs: {} as TOutput,
         durationMs: Math.round(performance.now() - startTime),
         error: {
           message: `Rate limit exceeded. Try again in ${Math.ceil(rateCheck.resetMs / 1000)} seconds.`,
           code: 'RATE_LIMITED',
         },
       }
     }
     ```

  2. Wrap the handler execution (step 3) with timeout:
     ```typescript
     // 3. Execute handler with timeout
     const dryRun = options.dryRun ?? false
     const module = tool.metadata.module
     const timeoutMs = TIMEOUTS[module] || TIMEOUTS.system

     const outputs = await Promise.race([
       tool.handler(inputs, options.context, dryRun),
       new Promise<never>((_, reject) =>
         setTimeout(() => reject(new TimeoutError(toolName, timeoutMs)), timeoutMs)
       ),
     ])
     ```

  3. Add `agent_session_id` to ALL `logToolExecution` calls (both success and error paths):
     ```typescript
     agent_session_id: options.context.agentSessionId,
     ```

  4. Handle TimeoutError in the catch block (alongside ToolValidationError, PermissionError, ToolNotFoundError):
     - Log it as an error execution
     - Return structured error result with code 'TIMEOUT'

  5. Update `executeToolFromAgent` to accept `agentSessionId` parameter:
     ```typescript
     export async function executeToolFromAgent<TOutput = unknown>(
       toolName: string,
       inputs: unknown,
       workspaceId: string,
       sessionId: string,
       agentSessionId?: string,
       dryRun = false
     ): Promise<ToolExecutionResult<TOutput>> {
       return executeTool<TOutput>(toolName, inputs, {
         dryRun,
         context: {
           workspaceId,
           userId: null,
           sessionId,
           agentSessionId,
           requestContext: {
             source: 'agent',
           },
         },
       })
     }
     ```

  **IMPORTANT:** Preserve ALL existing functionality. Only ADD timeout, rate limiting, and agent_session_id. Do not change function signatures except executeToolFromAgent (add optional param).

  Also add `agentSessionId?: string` to the `ExecutionContext` interface in types.ts if not already present (it should be from 12-01, but double-check). The field name in ExecutionContext should be `agentSessionId` (camelCase in TS) which maps to `agent_session_id` (snake_case in DB).
  </action>
  <verify>
  1. `npx tsc --noEmit` passes
  2. `grep -n "rateLimiter\|TIMEOUTS\|TimeoutError\|agent_session_id\|agentSessionId" src/lib/tools/executor.ts` confirms all additions
  3. `grep -c "logToolExecution" src/lib/tools/executor.ts` should show multiple calls with agent_session_id
  </verify>
  <done>
  Executor enhanced with: domain-specific timeouts (5s CRM, 15s WhatsApp), rate limiting per workspace per module, agent_session_id flowing through to forensic logs, and TimeoutError handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update API route for structured responses</name>
  <files>src/app/api/v1/tools/[toolName]/route.ts</files>
  <action>
  Update the API route to pass through ToolResult structure from handlers and improve error responses.

  The current API route already works (Phase 3). The changes are minor:

  1. When `result.status === 'error'`, include the full error object (code, message) in the response, not just a generic message:
     ```typescript
     if (result.status === 'error') {
       return NextResponse.json(
         {
           execution_id: result.id,
           status: 'error',
           error: result.error?.code || 'EXECUTION_ERROR',
           message: result.error?.message || 'Tool execution failed',
           duration_ms: result.durationMs,
         },
         { status: result.error?.code === 'RATE_LIMITED' ? 429 :
                   result.error?.code === 'TIMEOUT' ? 504 : 500 }
       )
     }
     ```

  2. When `result.status === 'success'`, the `outputs` field now contains the ToolResult from the handler. Pass it through directly:
     ```typescript
     return NextResponse.json({
       execution_id: result.id,
       status: result.status,
       outputs: result.outputs,
       duration_ms: result.durationMs,
     })
     ```
     The `outputs` field will contain the ToolResult structure (with `success`, `data`, `resource_url`, etc.) because that's what the real handlers now return.

  3. Map error codes to HTTP status codes:
     - `RATE_LIMITED` -> 429 Too Many Requests
     - `TIMEOUT` -> 504 Gateway Timeout
     - `VALIDATION_ERROR` -> 400 (already handled)
     - `PERMISSION_DENIED` -> 403 (already handled)
     - Default -> 500

  The existing catch handlers for ToolValidationError and PermissionError should remain as-is.
  </action>
  <verify>
  1. `npx tsc --noEmit` passes
  2. `grep -n "429\|504\|RATE_LIMITED\|TIMEOUT" src/app/api/v1/tools/\\[toolName\\]/route.ts` confirms HTTP status mapping
  </verify>
  <done>
  API route returns structured error responses with proper HTTP status codes for rate limiting (429) and timeout (504).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete Phase 12 implementation:
  - ToolResult<T> type system for structured responses
  - In-memory rate limiter (120/min CRM, 30/min WhatsApp)
  - Domain-specific timeouts (5s CRM, 15s WhatsApp)
  - 9 real CRM handlers (contact CRUD, tag add/remove, order create/updateStatus)
  - 7 real WhatsApp handlers (message send, template send, lists, assign, close)
  - Enhanced forensic logging with agent_session_id
  - API route with structured error responses
  </what-built>
  <how-to-verify>
  1. Server should start without errors: check terminal for compilation errors
  2. Test API endpoint (if API key configured):
     ```bash
     curl -X POST http://localhost:3020/api/v1/tools/crm.contact.create \
       -H "Content-Type: application/json" \
       -H "Authorization: Bearer YOUR_API_KEY" \
       -d '{"inputs": {"name": "Test Agent", "phone": "+573001234567"}, "dry_run": true}'
     ```
  3. Verify dry_run returns structured ToolResult with `success: true`
  4. Check TypeScript compiles: `npx tsc --noEmit` should pass
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Executor applies rate limiting before execution
3. Executor applies domain-specific timeouts
4. agent_session_id flows from context to tool_executions table
5. API route returns 429 for rate limit, 504 for timeout
6. Server starts and responds to tool invocations
</verification>

<success_criteria>
- Every tool execution is rate-limited per workspace per module
- CRM tools timeout after 5s, WhatsApp tools after 15s
- Agent session ID is persisted in every forensic log entry
- API /api/v1/tools/{toolName} returns structured ToolResult response
- Human verifies server starts and basic dry_run works
</success_criteria>

<output>
After completion, create `.planning/phases/12-action-dsl-real/12-04-SUMMARY.md`
</output>
