---
phase: 17-crm-automations-engine
plan: 07
type: execute
wave: 4
depends_on: ["17-04"]
files_modified:
  - src/app/actions/orders.ts
  - src/app/actions/tags.ts
  - src/app/actions/contacts.ts
  - src/app/actions/tasks.ts
  - src/app/api/webhooks/whatsapp/webhook-handler.ts
autonomous: true

must_haves:
  truths:
    - "moveOrderToStage emits automation/order.stage_changed event"
    - "createOrder emits automation/order.created event"
    - "Tag assign/remove operations emit tag.assigned/tag.removed events"
    - "createContact emits automation/contact.created event"
    - "updateContact and updateOrder emit automation/field.changed events when field values change"
    - "Task completion emits automation/task.completed event"
    - "WhatsApp message received emits automation event (in addition to agent event)"
    - "All emissions are fire-and-forget (do NOT block server actions)"
  artifacts:
    - path: "src/app/actions/orders.ts"
      provides: "Order actions with trigger emission"
      contains: "emitOrderStageChanged"
    - path: "src/app/actions/tags.ts"
      provides: "Tag actions with trigger emission"
      contains: "emitTagAssigned"
    - path: "src/app/actions/contacts.ts"
      provides: "Contact actions with trigger emission"
      contains: "emitContactCreated"
  key_links:
    - from: "src/app/actions/orders.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "Calls emitOrderStageChanged after stage update"
      pattern: "emitOrderStageChanged"
    - from: "src/app/actions/tags.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "Calls emitTagAssigned after tag assignment"
      pattern: "emitTagAssigned"
---

<objective>
Wire trigger emission into existing server actions so that CRM operations, WhatsApp messages, and task completions fire automation trigger events.

Purpose: Without this wiring, automations never execute. This plan adds fire-and-forget calls to the trigger emitter after successful operations in the existing server actions. This is the integration point between the existing CRM/WhatsApp/Tasks modules and the new automation engine.

Output: Modified server actions and webhook handler with trigger emission.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-crm-automations-engine/17-CONTEXT.md
@.planning/phases/17-crm-automations-engine/17-RESEARCH.md
@src/lib/automations/trigger-emitter.ts
@src/app/actions/orders.ts
@src/app/actions/tags.ts
@src/app/actions/contacts.ts
@src/app/actions/tasks.ts
@src/app/api/webhooks/whatsapp/webhook-handler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire CRM triggers (orders, tags, contacts)</name>
  <files>src/app/actions/orders.ts, src/app/actions/tags.ts, src/app/actions/contacts.ts</files>
  <action>
Add trigger emission to existing server actions. Import the trigger emitter functions at the top of each file.

**CRITICAL: Fire-and-forget pattern.** Do NOT await the emitter. The emitter itself already catches errors. Just call it after the successful operation:

```typescript
import { emitOrderStageChanged } from '@/lib/automations/trigger-emitter'
```

**src/app/actions/orders.ts — Add to these functions:**

1. **moveOrderToStage** (or equivalent function that changes stage):
   After successful stage update, add:
   ```typescript
   // Fire automation trigger (fire-and-forget)
   emitOrderStageChanged({
     workspaceId,
     orderId,
     previousStageId: order.stage_id,  // Read before update
     newStageId: stageId,
     pipelineId: order.pipeline_id,
     contactId: order.contact_id,
     // Enrich with names for variable resolution
     previousStageName: previousStage?.name,
     newStageName: newStage?.name,
     pipelineName: pipeline?.name,
     contactName: contact?.name,
     contactPhone: contact?.phone,
   })
   ```
   IMPORTANT: Read the previous stage ID BEFORE the update operation, store it in a variable, then emit after update succeeds.

2. **createOrder**:
   After successful order creation, add:
   ```typescript
   emitOrderCreated({
     workspaceId,
     orderId: data.id,
     pipelineId: data.pipeline_id,
     stageId: data.stage_id,
     contactId: data.contact_id,
     totalValue: data.total_value ?? 0,
   })
   ```

3. **updateOrder** (or equivalent function that updates order fields like value, description, custom_fields):
   Same pattern as updateContact — capture previous state before update, compare after, emit `emitFieldChanged` for each changed field:
   ```typescript
   // Fields to check for orders: 'description', 'shipping_address', 'total_value', 'custom_fields'
   // For custom_fields JSONB: iterate keys in the new value, compare with previous
   emitFieldChanged({
     workspaceId,
     entityType: 'order',
     entityId: orderId,
     fieldName,
     previousValue: prevVal,
     newValue: newVal,
   })
   ```
   IMPORTANT: Do NOT emit field.changed for stage_id changes (those are handled by the separate `emitOrderStageChanged` event).

**src/app/actions/tags.ts — Add to these functions:**

1. **addTagToContact** (or equivalent tag assignment function):
   After successful tag assignment, add:
   ```typescript
   emitTagAssigned({
     workspaceId,
     entityType: 'contact',
     entityId: contactId,
     tagId: tag.id,
     tagName: tag.name,
     contactId,
   })
   ```

2. **removeTagFromContact** (or equivalent):
   After removal:
   ```typescript
   emitTagRemoved({
     workspaceId,
     entityType: 'contact',
     entityId: contactId,
     tagId: tag.id,
     tagName: tag.name,
   })
   ```

3. If there are tag operations for orders (`addTagToOrder`, etc.), add similar emissions.

4. If there are tag operations for conversations, add emissions with `entityType: 'conversation'`.

**src/app/actions/contacts.ts — Add to these functions:**

1. **updateContact** (or equivalent function that updates contact fields):
   BEFORE the update query, read the current contact to capture previous field values. After successful update, compare old vs new for each changed field and emit `emitFieldChanged` for each one:
   ```typescript
   import { emitFieldChanged } from '@/lib/automations/trigger-emitter'

   // Before update: capture previous state
   const { data: previousContact } = await supabase
     .from('contacts')
     .select('*')
     .eq('id', contactId)
     .single()

   // ... perform update ...

   // After successful update: emit field.changed for each changed field
   if (previousContact) {
     const fieldsToCheck = ['name', 'phone', 'email', 'city', 'address']
     for (const fieldName of fieldsToCheck) {
       const prevVal = previousContact[fieldName]
       const newVal = updatedData[fieldName]
       if (newVal !== undefined && prevVal !== newVal) {
         emitFieldChanged({
           workspaceId,
           entityType: 'contact',
           entityId: contactId,
           fieldName,
           previousValue: prevVal,
           newValue: newVal,
         })
       }
     }
     // Also check custom_fields JSONB if the project supports them
   }
   ```

2. **createContact**:
   After successful creation, add:
   ```typescript
   emitContactCreated({
     workspaceId,
     contactId: data.id,
     contactName: data.name ?? '',
     contactPhone: data.phone ?? '',
     contactEmail: data.email,
     contactCity: data.city,
   })
   ```

**For each modification:**
- Read the exact function names from the actual files (they may differ from my guesses)
- Add import at top of file
- Add emission AFTER the successful Supabase operation
- Do NOT wrap in try/catch (the emitter handles its own errors)
- Do NOT change existing function signatures or return types
- For stage changes: capture previous state BEFORE the update query
- For enriched names (stage name, pipeline name): if not already available in the function scope, do a quick select to get the name OR pass null (variable resolution will leave {{path}} unresolved for missing data, which is acceptable)
  </action>
  <verify>Check each modified file imports the trigger emitter. Check emission calls are fire-and-forget (no await). Check previous stage captured before update in moveOrderToStage. TypeScript compiles.</verify>
  <done>Orders, tags, and contacts server actions emit automation trigger events after successful operations, all fire-and-forget.</done>
</task>

<task type="auto">
  <name>Task 2: Wire task and WhatsApp triggers</name>
  <files>src/app/actions/tasks.ts, src/app/api/webhooks/whatsapp/webhook-handler.ts</files>
  <action>
**src/app/actions/tasks.ts:**

1. Find the function that marks a task as completed (likely `updateTask` with status change or `completeTask`):
   After successful completion, add:
   ```typescript
   import { emitTaskCompleted } from '@/lib/automations/trigger-emitter'

   // After task marked as completed:
   emitTaskCompleted({
     workspaceId,
     taskId: task.id,
     taskTitle: task.title,
     contactId: task.contact_id,
     orderId: task.order_id,
   })
   ```

2. Task overdue detection is handled separately by a cron job (Plan 06 can add this later, or a separate future plan). For now, just wire the completion trigger.

**src/app/api/webhooks/whatsapp/webhook-handler.ts:**

The webhook handler already emits `agent/whatsapp.message_received` for the agent system. Add automation trigger emission ALONGSIDE (not replacing) the agent event.

Find the location where incoming text messages are processed (after storing in DB). Add:

```typescript
import { emitWhatsAppMessageReceived, emitWhatsAppKeywordMatch } from '@/lib/automations/trigger-emitter'

// After message stored in DB, alongside existing agent event emission:
emitWhatsAppMessageReceived({
  workspaceId,
  conversationId,
  contactId,
  messageContent: message.text,
  phone: message.from,
})

// Keyword match detection:
// Load automations with trigger_type = 'whatsapp.keyword_match' for this workspace
// Check if message contains any of their configured keywords
// If match found, emit keyword match event
// NOTE: This is a lightweight check — load keywords once per workspace (could cache),
// then do simple string.includes() for each keyword.
// For MVP: skip the keyword check in the webhook handler.
// Instead, the automation runner for 'whatsapp.message_received' can check keyword
// match as part of trigger config evaluation. This avoids loading automation config
// in the hot webhook path. The keyword_match trigger type can be an alias handled
// by the same runner as message_received but with keyword checking in matchesTriggerConfig.
```

**IMPORTANT DECISION:** For keyword matching, do NOT add keyword checking to the webhook handler. Instead, have the `whatsapp.message_received` event handler check keywords as part of `matchesTriggerConfig`. This keeps the webhook handler simple and avoids loading automation configs on every message.

The emitWhatsAppKeywordMatch function exists but won't be called directly from the webhook. It can be used by the action executor for cascading or future use.

**WhatsApp webhook modification should be minimal:**
1. Import emitWhatsAppMessageReceived
2. Add a single fire-and-forget call after the existing agent event emission
3. No other changes to the webhook handler
  </action>
  <verify>Task completion emits trigger event. WhatsApp webhook emits automation event alongside agent event. No existing functionality broken. TypeScript compiles.</verify>
  <done>Task completion and WhatsApp message received trigger events wired. Keyword matching handled at runner level via trigger config, not in webhook handler.</done>
</task>

</tasks>

<verification>
1. orders.ts: moveOrderToStage emits order.stage_changed, createOrder emits order.created
2. orders.ts: updateOrder emits field.changed for each changed field (excluding stage_id)
3. tags.ts: tag add/remove operations emit tag.assigned/tag.removed
4. contacts.ts: createContact emits contact.created
5. contacts.ts: updateContact emits field.changed for each changed field (name, phone, email, city, address)
6. tasks.ts: task completion emits task.completed
7. webhook-handler.ts: incoming messages emit whatsapp.message_received
8. All emissions are fire-and-forget (no await, no try/catch wrapping)
9. Previous state captured before updates (for stage change previousStageId, for field changes previousValue)
10. No existing functionality broken
11. TypeScript compiles
</verification>

<success_criteria>
- All server actions emit appropriate trigger events after successful operations
- Emissions do not block or slow down existing operations
- Existing agent/WhatsApp event emission untouched
- Previous state captured for diff-based triggers (stage change)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-crm-automations-engine/17-07-SUMMARY.md`
</output>
