---
phase: 17-crm-automations-engine
plan: 04
type: execute
wave: 3
depends_on: ["17-01", "17-02"]
files_modified:
  - src/lib/automations/action-executor.ts
  - src/lib/automations/trigger-emitter.ts
autonomous: true

must_haves:
  truths:
    - "Action executor can execute all 11 action types using existing tool handlers"
    - "Trigger emitter emits Inngest events with cascade depth tracking"
    - "Cascade protection stops at MAX_CASCADE_DEPTH (3)"
    - "Actions that modify CRM state can trigger cascading automations"
  artifacts:
    - path: "src/lib/automations/action-executor.ts"
      provides: "Executes automation actions via existing Action DSL tool handlers"
      exports: ["executeAction"]
    - path: "src/lib/automations/trigger-emitter.ts"
      provides: "Emits automation trigger events to Inngest"
      exports: ["emitOrderStageChanged", "emitTagAssigned", "emitTagRemoved", "emitContactCreated", "emitOrderCreated", "emitWhatsAppMessageReceived", "emitTaskCompleted", "emitTaskOverdue"]
  key_links:
    - from: "src/lib/automations/action-executor.ts"
      to: "src/lib/tools/executor.ts"
      via: "Uses executeToolFromWebhook for CRM/WhatsApp actions"
      pattern: "executeToolFromWebhook"
    - from: "src/lib/automations/trigger-emitter.ts"
      to: "src/inngest/client.ts"
      via: "Sends events to Inngest"
      pattern: "inngest\\.send"
---

<objective>
Implement the action executor (runs automation actions via existing tool handlers) and the trigger emitter (fires Inngest events when triggers occur).

Purpose: The action executor is the bridge between automation definitions and actual CRM/WhatsApp operations. It reuses the existing Action DSL tool handlers (executeToolFromWebhook) so we don't duplicate any CRUD logic. The trigger emitter is what server actions will call to notify the automation engine of changes. Together they form the core execution layer.

Output: Two TypeScript modules — one for executing actions, one for emitting trigger events.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-crm-automations-engine/17-CONTEXT.md
@.planning/phases/17-crm-automations-engine/17-RESEARCH.md
@src/lib/automations/types.ts
@src/lib/automations/constants.ts
@src/lib/automations/variable-resolver.ts
@src/lib/tools/executor.ts
@src/lib/tools/index.ts
@src/inngest/client.ts
@src/inngest/events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Action executor using existing tool handlers</name>
  <files>src/lib/automations/action-executor.ts</files>
  <action>
Create `src/lib/automations/action-executor.ts` — the function that executes a single automation action.

**Imports:**
- `AutomationAction`, `ActionType`, `TriggerContext` from `./types`
- `resolveVariables`, `resolveVariablesInObject` from `./variable-resolver`
- `initializeTools` from `@/lib/tools/init` (must call before using registry)
- `createAdminClient` from `@/lib/supabase/admin` (bypass RLS — Inngest context has no user session)
- `emitTagAssigned`, `emitOrderCreated` from `./trigger-emitter` (for cascading)

**Main function:**
```typescript
export interface ActionResult {
  success: boolean
  result?: unknown
  error?: string
  duration_ms: number
}

export async function executeAction(
  action: AutomationAction,
  context: TriggerContext,
  workspaceId: string,
  cascadeDepth: number
): Promise<ActionResult>
```

**Implementation strategy per action type:**

1. **assign_tag / remove_tag**: Use `createAdminClient()` to directly insert/delete from `contact_tags` or `order_tags` table. After success, call `emitTagAssigned/emitTagRemoved` with `cascadeDepth + 1` for cascading.

2. **change_stage**: Use `createAdminClient()` to update `orders.stage_id`. After success, call `emitOrderStageChanged` with `cascadeDepth + 1`.

3. **update_field**: Use `createAdminClient()` to update contact or order field. For custom_fields, merge into existing JSONB.

4. **create_order**: Use `createAdminClient()` to insert into orders table. Resolve default first stage if stageId not specified. Link to contact from trigger context. After success, call `emitOrderCreated` with `cascadeDepth + 1`.

5. **duplicate_order**: Read source order from context (orderId), copy to target pipeline with `source_order_id = context.orderId`. Respect copyContact/copyProducts/copyValue/copyTags params. After success, call `emitOrderCreated` with `cascadeDepth + 1`.

6. **send_whatsapp_template**: Use `executeToolFromWebhook` with tool name `whatsapp.template.send`. Resolve template variables from context. Need phone number from trigger context.

7. **send_whatsapp_text**: Use `executeToolFromWebhook` with tool name `whatsapp.message.send`. Resolve `{{variables}}` in text using `resolveVariables(action.params.text, context)`.

8. **send_whatsapp_media**: Use `executeToolFromWebhook` with tool name `whatsapp.message.send` with media attachment.

9. **create_task**: Use `createAdminClient()` to insert into tasks table. Resolve `{{variables}}` in title and description. Calculate due_date from relative delay config. Link to contact/order from context.

10. **webhook**: Use `fetch()` with POST method. Resolve `{{variables}}` in payload template using `resolveVariablesInObject`. Include custom headers. Timeout at WEBHOOK_TIMEOUT_MS. Return response status and body.

**Important patterns:**
- Call `initializeTools()` at the top of executeAction (idempotent, ensures tool registry ready)
- Wrap each action in try/catch, return `{ success: false, error: message }` on failure
- Measure duration with `Date.now()` before/after
- For WhatsApp actions, need the contact's phone from context — if not available, return error
- For CRM actions, use createAdminClient (Pitfall 5 from research — RLS bypass)
- For cascading: ONLY emit cascade events for actions that modify CRM state (tag, stage, order creation). WhatsApp sends and webhooks do NOT cascade.

**Variable resolution in params:**
Before executing any action, resolve variables in string params:
```typescript
const resolvedParams = resolveVariablesInObject(action.params, context)
```
  </action>
  <verify>All 11 action types have implementations. CRM actions use createAdminClient. WhatsApp actions use executeToolFromWebhook. Cascade events emitted with depth+1 for state-modifying actions. TypeScript compiles.</verify>
  <done>Action executor handles all 11 action types, resolves variables, uses existing tool handlers, bypasses RLS, and emits cascade events for state-modifying actions.</done>
</task>

<task type="auto">
  <name>Task 2: Trigger emitter with cascade protection</name>
  <files>src/lib/automations/trigger-emitter.ts</files>
  <action>
Create `src/lib/automations/trigger-emitter.ts` — functions that server actions call to notify the automation engine of changes.

**Imports:**
- `inngest` from `@/inngest/client` (will need to update client to support new event types — see note below)
- `MAX_CASCADE_DEPTH` from `./constants`

**IMPORTANT: Inngest event types extension.** The trigger emitter sends events with names like `automation/order.stage_changed`. These event types must be added to the Inngest client's type system. However, the inngest client.ts file is modified in Plan 06 when registering runner functions. For now, the trigger emitter can use `inngest.send()` with type assertion since Inngest accepts any event name at runtime — the type safety will be added in Plan 06. Use `as any` for the event name to avoid TypeScript errors until Plan 06 adds the types.

**Emitter functions (one per trigger type):**

```typescript
export async function emitOrderStageChanged(data: {
  workspaceId: string
  orderId: string
  previousStageId: string
  newStageId: string
  pipelineId: string
  contactId: string | null
  // Enriched names for variable resolution
  previousStageName?: string
  newStageName?: string
  pipelineName?: string
  contactName?: string
  contactPhone?: string
  cascadeDepth?: number
}): Promise<void>
```

Each function:
1. Check `cascadeDepth ?? 0 >= MAX_CASCADE_DEPTH` → return silently (log warning)
2. Fire-and-forget: `inngest.send({ name: 'automation/xxx', data: { ...data, cascadeDepth: data.cascadeDepth ?? 0 } }).catch(err => console.error('[trigger-emitter] Failed:', err))`
3. Do NOT await — fire-and-forget to avoid blocking server actions (Pitfall 3 from research)

**Functions to create:**
1. `emitOrderStageChanged` — data: workspaceId, orderId, previousStageId, newStageId, pipelineId, contactId, names
2. `emitTagAssigned` — data: workspaceId, entityType, entityId, tagId, tagName, contactId, contactName
3. `emitTagRemoved` — data: workspaceId, entityType, entityId, tagId, tagName, contactId
4. `emitContactCreated` — data: workspaceId, contactId, contactName, contactPhone, contactEmail, contactCity
5. `emitOrderCreated` — data: workspaceId, orderId, pipelineId, stageId, contactId, totalValue, sourceOrderId
6. `emitFieldChanged` — data: workspaceId, entityType, entityId, fieldName, previousValue, newValue
7. `emitWhatsAppMessageReceived` — data: workspaceId, conversationId, contactId, messageContent, phone
8. `emitWhatsAppKeywordMatch` — data: workspaceId, conversationId, contactId, messageContent, phone, keywordMatched
9. `emitTaskCompleted` — data: workspaceId, taskId, taskTitle, contactId, orderId
10. `emitTaskOverdue` — data: workspaceId, taskId, taskTitle, dueDate, contactId, orderId

Each function also accepts optional `cascadeDepth` (default 0).

**Logging:** Use `console.error` for failures (not console.log) so they're visible in Vercel logs. Include the trigger type and workspaceId in the error message.
  </action>
  <verify>All 10 emitter functions exported. Each checks cascade depth before emitting. Each is fire-and-forget (no await on inngest.send). TypeScript compiles (may need `as any` for event names until Plan 06).</verify>
  <done>10 trigger emitter functions exported, all with cascade protection (max depth 3), fire-and-forget pattern, and enriched data for variable resolution.</done>
</task>

</tasks>

<verification>
1. executeAction handles all 11 action types
2. CRM actions use createAdminClient (bypass RLS)
3. WhatsApp actions use existing tool handlers via executeToolFromWebhook
4. Cascade events emitted only for state-modifying actions (tag, stage, order)
5. Trigger emitters check MAX_CASCADE_DEPTH before sending
6. Trigger emitters are fire-and-forget (don't block server actions)
7. Variables resolved in action params before execution
8. TypeScript compiles without errors
</verification>

<success_criteria>
- All 11 action types executable with proper error handling
- All 10 trigger types emittable with cascade protection
- Actions reuse existing tool handlers (no duplicate CRUD logic)
- Fire-and-forget pattern prevents blocking server actions
</success_criteria>

<output>
After completion, create `.planning/phases/17-crm-automations-engine/17-04-SUMMARY.md`
</output>
