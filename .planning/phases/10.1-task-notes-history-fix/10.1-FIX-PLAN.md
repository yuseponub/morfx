---
phase: 10.1-task-notes-history-fix
plan: FIX
type: bugfix
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260204000003_fix_task_activity_triggers.sql
autonomous: true
user_setup: ["Apply migration to Supabase"]

must_haves:
  truths:
    - "User can create tasks without errors"
    - "Task activity logs creation event correctly"
    - "Postponement counter increments when due_date moves forward"
    - "Task updates are logged to task_activity"
  artifacts:
    - path: "supabase/migrations/20260204000003_fix_task_activity_triggers.sql"
      provides: "Fixed trigger architecture matching contact_activity pattern"
  key_links:
    - from: "tasks table"
      to: "task_activity table"
      via: "AFTER trigger (not BEFORE)"
      pattern: "log_task_changes"
---

<objective>
Fix the trigger architecture that prevents task creation.

**Root Cause:** The `log_task_changes()` trigger is BEFORE INSERT, which attempts to INSERT into `task_activity` before the task row exists. This causes RLS evaluation issues.

**Solution:** Split into two triggers following the proven `contact_activity` pattern:
1. BEFORE UPDATE trigger - Only for incrementing `postponement_count`
2. AFTER INSERT/UPDATE/DELETE trigger - For logging to `task_activity`

Output: New migration that drops the broken trigger and creates the correct architecture.
</objective>

<context>
**Problem discovered:** 2026-02-04
**Impact:** Users cannot create tasks - "Error al crear la tarea"
**Pattern reference:** contact_activity in 20260129000002_custom_fields_notes_activity.sql (lines 144-147)
**Fix reference:** 20260129000004_fix_contact_delete_trigger.sql (separated BEFORE/AFTER)

**Investigation confirmed:**
- contact_activity uses AFTER trigger → WORKS
- task_activity uses BEFORE trigger → FAILS
- SET row_security = off is invalid for functions (ignored by PostgreSQL)
- SECURITY DEFINER works correctly with AFTER triggers
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration to fix trigger architecture</name>
  <files>supabase/migrations/20260204000003_fix_task_activity_triggers.sql</files>
  <action>
Create new migration file `supabase/migrations/20260204000003_fix_task_activity_triggers.sql`:

```sql
-- ============================================================================
-- Fix: Task Activity Trigger Architecture
-- Problem: BEFORE trigger attempting INSERT into task_activity fails due to
--          RLS evaluation timing issues.
-- Solution: Split into BEFORE (postponement only) and AFTER (logging) triggers,
--           matching the proven contact_activity pattern.
-- ============================================================================

-- ============================================================================
-- STEP 1: Drop the broken trigger and function
-- ============================================================================

DROP TRIGGER IF EXISTS task_activity_trigger ON tasks;
DROP FUNCTION IF EXISTS log_task_changes();

-- ============================================================================
-- STEP 2: Create BEFORE trigger function for postponement counting ONLY
-- This runs BEFORE UPDATE to modify NEW.postponement_count
-- ============================================================================

CREATE OR REPLACE FUNCTION set_task_postponement_count()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Only increment if both old and new due_date exist and new > old
  IF (NEW.due_date IS NOT NULL AND OLD.due_date IS NOT NULL
      AND NEW.due_date > OLD.due_date) THEN
    NEW.postponement_count := COALESCE(OLD.postponement_count, 0) + 1;
  END IF;

  RETURN NEW;
END;
$$;

-- Attach BEFORE UPDATE trigger (only UPDATE needs postponement logic)
CREATE TRIGGER task_set_postponement_trigger
  BEFORE UPDATE ON tasks
  FOR EACH ROW
  EXECUTE FUNCTION set_task_postponement_count();

-- ============================================================================
-- STEP 3: Create AFTER trigger function for activity logging
-- This runs AFTER INSERT/UPDATE/DELETE to log to task_activity
-- Matches the contact_activity pattern exactly
-- ============================================================================

CREATE OR REPLACE FUNCTION log_task_activity()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  changes_json JSONB := '{}';
  old_json JSONB;
  new_json JSONB;
  key TEXT;
  user_uuid UUID;
  action_type TEXT;
BEGIN
  -- Get current user from JWT (may be null for direct DB operations)
  BEGIN
    user_uuid := (auth.jwt() ->> 'sub')::UUID;
  EXCEPTION WHEN OTHERS THEN
    user_uuid := NULL;
  END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO task_activity (task_id, workspace_id, user_id, action, changes)
    VALUES (NEW.id, NEW.workspace_id, user_uuid, 'created', to_jsonb(NEW));
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    old_json := to_jsonb(OLD);
    new_json := to_jsonb(NEW);

    -- Build diff of changed fields
    FOR key IN SELECT jsonb_object_keys(new_json)
    LOOP
      -- Skip auto-updated fields
      IF key NOT IN ('updated_at', 'postponement_count') AND old_json -> key IS DISTINCT FROM new_json -> key THEN
        changes_json := changes_json || jsonb_build_object(
          key, jsonb_build_object('old', old_json -> key, 'new', new_json -> key)
        );
      END IF;
    END LOOP;

    -- Determine action type based on what changed
    IF changes_json ? 'due_date' THEN
      action_type := 'due_date_changed';
    ELSIF changes_json ? 'status' THEN
      IF NEW.status = 'completed' THEN
        action_type := 'completed';
      ELSE
        action_type := 'reopened';
      END IF;
    ELSE
      action_type := 'updated';
    END IF;

    -- Only log if there are actual changes
    IF changes_json != '{}' THEN
      INSERT INTO task_activity (task_id, workspace_id, user_id, action, changes)
      VALUES (NEW.id, NEW.workspace_id, user_uuid, action_type, changes_json);
    END IF;
    RETURN NEW;
  END IF;

  IF TG_OP = 'DELETE' THEN
    INSERT INTO task_activity (task_id, workspace_id, user_id, action, changes)
    VALUES (OLD.id, OLD.workspace_id, user_uuid, 'deleted', to_jsonb(OLD));
    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$;

-- Attach AFTER trigger for INSERT/UPDATE/DELETE (matches contact_activity pattern)
CREATE TRIGGER task_activity_trigger
  AFTER INSERT OR UPDATE OR DELETE ON tasks
  FOR EACH ROW
  EXECUTE FUNCTION log_task_activity();

-- ============================================================================
-- STEP 4: Clean up the invalid fix migration function if it exists
-- The 20260204000002 migration tried SET row_security = off which doesn't work
-- ============================================================================

-- The function was already dropped above, this ensures clean state
```

**Key changes from original:**
1. Split into TWO separate functions and triggers
2. `set_task_postponement_count()` - BEFORE UPDATE only, modifies NEW
3. `log_task_activity()` - AFTER INSERT/UPDATE/DELETE, logs to task_activity
4. Removed invalid `SET row_security = off`
5. Matches proven `contact_activity` pattern exactly
  </action>
  <verify>
```bash
# Check migration file exists and has correct structure
grep -E "(BEFORE UPDATE|AFTER INSERT OR UPDATE OR DELETE|set_task_postponement_count|log_task_activity)" /mnt/c/Users/Usuario/Proyectos/morfx-new/supabase/migrations/20260204000003_fix_task_activity_triggers.sql
```
  </verify>
  <done>
Migration file exists with:
- BEFORE UPDATE trigger for postponement_count
- AFTER INSERT/UPDATE/DELETE trigger for activity logging
- Two separate functions matching contact_activity pattern
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Fixed trigger architecture that was preventing task creation.

The fix:
1. Splits the single BEFORE trigger into two separate triggers
2. BEFORE UPDATE → Only increments postponement_count
3. AFTER INSERT/UPDATE/DELETE → Logs to task_activity (matches contact_activity pattern)
  </what-built>
  <how-to-verify>
1. Apply the migration to Supabase:
   ```bash
   # Option A: Via Supabase CLI (if connected)
   npx supabase db push

   # Option B: Via Supabase Dashboard
   # Go to SQL Editor → Run the migration SQL manually
   ```

2. Restart the dev server:
   ```bash
   pkill -f "next dev" 2>/dev/null; sleep 2; cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npm run dev &
   ```

3. Navigate to http://localhost:3020/tareas

4. **Test task creation:**
   - Click "Nueva tarea"
   - Fill in title, description, due date
   - Click "Crear tarea"
   - ✓ Task should be created without error

5. **Test activity logging:**
   - Click on the created task to open detail sheet
   - Go to "Historial" tab
   - ✓ Should show "Tarea creada" entry

6. **Test postponement tracking:**
   - Edit the task, change due date to a later date
   - ✓ History should show "Fecha limite cambiada"
   - ✓ Postponement badge should appear

Expected: All CRUD operations work, activity is logged, postponement counter increments correctly.
  </how-to-verify>
  <resume-signal>Type "approved" if task creation works, or describe any remaining issues</resume-signal>
</task>

</tasks>

<verification>
After migration applied:
1. Task creation succeeds without errors
2. task_activity receives INSERT records via AFTER trigger
3. postponement_count increments correctly via BEFORE UPDATE trigger
4. All existing Phase 10.1 functionality (notes, history, badge) works
</verification>

<success_criteria>
- [ ] Migration file created with correct trigger architecture
- [ ] User can create tasks without errors
- [ ] Activity logged correctly for all operations
- [ ] Postponement counter works when due date moves forward
- [ ] Human verification passed
</success_criteria>
