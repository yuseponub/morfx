---
phase: 17-crm-automations-engine
plan: 03
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/app/actions/automations.ts
autonomous: true

must_haves:
  truths:
    - "Server actions exist for full automation CRUD (create, read, update, delete)"
    - "Enable/disable toggle works via dedicated server action"
    - "Duplicate automation creates a copy with '(copia)' suffix"
    - "Execution history is queryable with pagination"
  artifacts:
    - path: "src/app/actions/automations.ts"
      provides: "All automation CRUD server actions"
      exports: ["getAutomations", "getAutomation", "createAutomation", "updateAutomation", "deleteAutomation", "toggleAutomation", "duplicateAutomation", "getExecutionHistory", "getExecutionDetail"]
  key_links:
    - from: "src/app/actions/automations.ts"
      to: "src/lib/automations/types.ts"
      via: "imports Automation, AutomationFormData, AutomationExecution types"
      pattern: "import.*Automation.*from.*automations/types"
---

<objective>
Create all server actions for automation CRUD and execution history retrieval.

Purpose: The automation builder wizard UI (Plan 05) and the execution history UI (Plan 08) need server actions to create, read, update, delete, toggle, and duplicate automations, plus query execution history. This plan creates the complete data access layer.

Output: One server actions file with full automation management.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-crm-automations-engine/17-CONTEXT.md
@.planning/phases/17-crm-automations-engine/17-RESEARCH.md
@src/lib/automations/types.ts

# Pattern to follow
@src/app/actions/orders.ts
@src/app/actions/tags.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Automation CRUD server actions</name>
  <files>src/app/actions/automations.ts</files>
  <action>
Create `src/app/actions/automations.ts` with `'use server'` directive. Follow the exact pattern from `orders.ts` and `tags.ts`:
- Import `createClient` from `@/lib/supabase/server`
- Import `revalidatePath` from `next/cache`
- Import `cookies` from `next/headers`
- Import `z` from `zod`
- Import types from `@/lib/automations/types`
- Import `MAX_ACTIONS_PER_AUTOMATION` from `@/lib/automations/constants`

**Zod validation schemas:**
```typescript
const conditionSchema: z.ZodType<any> = z.lazy(() =>
  z.object({
    logic: z.enum(['AND', 'OR']),
    conditions: z.array(
      z.union([
        z.object({
          field: z.string().min(1),
          operator: z.string().min(1),
          value: z.unknown(),
        }),
        conditionSchema,  // Recursive for nested groups
      ])
    ),
  })
)

const actionSchema = z.object({
  type: z.string().min(1),
  params: z.record(z.string(), z.unknown()),
  delay: z.object({
    amount: z.number().positive(),
    unit: z.enum(['minutes', 'hours', 'days']),
  }).nullable().optional(),
})

const automationSchema = z.object({
  name: z.string().min(1, 'El nombre es requerido').max(100),
  description: z.string().max(500).optional().nullable(),
  trigger_type: z.string().min(1, 'El trigger es requerido'),
  trigger_config: z.record(z.string(), z.unknown()).optional().default({}),
  conditions: conditionSchema.nullable().optional(),
  actions: z.array(actionSchema).min(1, 'Se requiere al menos una accion').max(MAX_ACTIONS_PER_AUTOMATION),
})
```

**ActionResult type:**
```typescript
type ActionResult<T = void> =
  | { success: true; data: T }
  | { error: string; field?: string }
```

**Server actions to implement:**

1. `getAutomations()` — Get all automations for current workspace, ordered by created_at DESC. Return Automation[]. Include count of recent executions (last 24h) and last execution status as extra fields via a joined query or separate count query.

2. `getAutomation(id: string)` — Get single automation by ID with workspace check.

3. `createAutomation(formData: AutomationFormData)` — Validate with Zod, get workspace from auth, insert into automations table. Check MAX_AUTOMATIONS_PER_WORKSPACE limit. Revalidate `/automatizaciones`.

4. `updateAutomation(id: string, formData: AutomationFormData)` — Validate, verify ownership (workspace match), update. Revalidate `/automatizaciones`.

5. `deleteAutomation(id: string)` — Verify ownership, delete. Revalidate.

6. `toggleAutomation(id: string)` — Toggle is_enabled boolean. Read current value, flip it. Revalidate.

7. `duplicateAutomation(id: string)` — Read original, create copy with name + ' (copia)', is_enabled = false. Revalidate.

**All actions must:**
- Get user via `supabase.auth.getUser()`
- Get workspace membership via the existing pattern (query workspace_members)
- Return `{ error: 'No autorizado' }` if not authenticated or not in workspace
- Use `revalidatePath('/automatizaciones')` after mutations
- Handle Supabase errors gracefully
  </action>
  <verify>Verify all 7 CRUD functions are exported. Check Zod schema handles recursive conditions. TypeScript compiles: `npx tsc --noEmit src/app/actions/automations.ts`</verify>
  <done>7 CRUD server actions exported (get list, get one, create, update, delete, toggle, duplicate) with Zod validation and workspace isolation.</done>
</task>

<task type="auto">
  <name>Task 2: Execution history server actions</name>
  <files>src/app/actions/automations.ts</files>
  <action>
Add execution history query functions to the same `automations.ts` file:

1. `getExecutionHistory(params: { automationId?: string; page?: number; pageSize?: number; status?: string })` — Query automation_executions for workspace with optional filters. Join with automations table to get automation name. Order by started_at DESC. Return paginated results with total count.

2. `getExecutionDetail(executionId: string)` — Get single execution with full actions_log, trigger_event snapshot, and parent automation name. Verify workspace ownership.

3. `getRecentFailures()` — Get count of failed executions in last 24h for badge display in sidebar. Return just the count number.

4. `getAutomationStats(automationId: string)` — Get basic stats for a single automation: total executions, success rate, last execution date. Used in the automation list view.

**Pagination pattern:**
```typescript
const pageSize = params.pageSize ?? 20
const offset = ((params.page ?? 1) - 1) * pageSize

// Count query
const { count } = await supabase
  .from('automation_executions')
  .select('*', { count: 'exact', head: true })
  .eq('workspace_id', workspaceId)

// Data query with range
const { data } = await supabase
  .from('automation_executions')
  .select('*, automations!inner(name)')
  .eq('workspace_id', workspaceId)
  .order('started_at', { ascending: false })
  .range(offset, offset + pageSize - 1)
```

Return type for history: `{ data: (AutomationExecution & { automation_name: string })[]; total: number; page: number; pageSize: number }`
  </action>
  <verify>All 4 history functions exported. Pagination returns correct range. TypeScript compiles.</verify>
  <done>Execution history queryable with pagination, filtering by automation/status, detail view with full action logs, and failure count for sidebar badge.</done>
</task>

</tasks>

<verification>
1. All server actions properly authenticated and workspace-isolated
2. Zod validates recursive condition groups
3. MAX_ACTIONS_PER_AUTOMATION enforced in validation
4. MAX_AUTOMATIONS_PER_WORKSPACE enforced in createAutomation
5. Execution history paginated with total count
6. TypeScript compiles without errors
</verification>

<success_criteria>
- Complete CRUD: create, read, update, delete, toggle, duplicate automations
- Execution history with pagination, filters, and detail view
- Failure count for sidebar badge
- All workspace-isolated with proper auth checks
</success_criteria>

<output>
After completion, create `.planning/phases/17-crm-automations-engine/17-03-SUMMARY.md`
</output>
