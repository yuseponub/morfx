---
phase: 15.6-sandbox-evolution
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/agents/crm/types.ts
  - src/lib/agents/crm/base-crm-agent.ts
  - src/lib/agents/crm/crm-agent-registry.ts
  - src/lib/agents/crm/crm-orchestrator.ts
  - src/lib/agents/crm/order-manager/tools.ts
  - src/lib/agents/crm/order-manager/agent.ts
  - src/lib/agents/crm/index.ts
autonomous: true

must_haves:
  truths:
    - "CRM agent interface is defined with execute method accepting dry-run or live mode"
    - "CRM agent registry allows registering and looking up agents by ID"
    - "CRM orchestrator routes commands to the correct agent"
    - "Order Manager agent exists with 3 modes: full, no_promo, draft"
    - "Dry-run mode generates realistic mock data without touching database"
    - "Live mode would prefix test data with 'test-' (wiring deferred to Plan 05)"
  artifacts:
    - path: "src/lib/agents/crm/types.ts"
      provides: "CRM agent interfaces, command types, result types"
      contains: "CrmAgent"
    - path: "src/lib/agents/crm/base-crm-agent.ts"
      provides: "Abstract base class for CRM agents"
      contains: "BaseCrmAgent"
    - path: "src/lib/agents/crm/crm-agent-registry.ts"
      provides: "Registry for CRM agents with get/list/register methods"
      contains: "CrmAgentRegistry"
    - path: "src/lib/agents/crm/crm-orchestrator.ts"
      provides: "Routes CRM commands to registered agents"
      contains: "CrmOrchestrator"
    - path: "src/lib/agents/crm/order-manager/agent.ts"
      provides: "Order Manager agent with 3 modes and dry-run/live execution"
      contains: "OrderManagerAgent"
  key_links:
    - from: "src/lib/agents/crm/crm-orchestrator.ts"
      to: "src/lib/agents/crm/crm-agent-registry.ts"
      via: "Looks up agents by command type"
      pattern: "registry.getAgentForCommand"
    - from: "src/lib/agents/crm/order-manager/agent.ts"
      to: "src/lib/agents/crm/base-crm-agent.ts"
      via: "Extends BaseCrmAgent"
      pattern: "extends BaseCrmAgent"
---

<objective>
Build the CRM agent system architecture: interfaces, base class, registry, orchestrator, and the first concrete CRM agent (Order Manager). This establishes the foundation for separating conversational agents (Somnio) from CRM agents (data operations).

Purpose: Success Criteria 3 requires "Agentes separados: conversacional vs CRM". This plan creates the CRM agent infrastructure. Only Order Manager is implemented (per CONTEXT.md: "se iran creando mas progresivamente").
Output: Complete CRM agent system under src/lib/agents/crm/ with Order Manager as first agent.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/agents/types.ts
@src/lib/agents/somnio/order-creator.ts
@src/lib/tools/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CRM agent types, base class, and registry</name>
  <files>
    src/lib/agents/crm/types.ts
    src/lib/agents/crm/base-crm-agent.ts
    src/lib/agents/crm/crm-agent-registry.ts
  </files>
  <action>
**1. Create `src/lib/agents/crm/types.ts`:**

Define the CRM agent system interfaces:

```typescript
/**
 * CRM Agent Type Definitions
 * Phase 15.6: Sandbox Evolution
 *
 * Interfaces for CRM agents that execute data operations.
 * CRM agents are separate from conversational agents (Somnio).
 */

import type { ModelTokenEntry } from '@/lib/agents/types'
import type { ToolExecution } from '@/lib/sandbox/types'

/** Execution mode for CRM agents */
export type CrmExecutionMode = 'dry-run' | 'live'

/** CRM command types (extensible as more agents are added) */
export type CrmCommandType =
  | 'create_order'    // Order Manager: create order with contact
  | 'edit_order'      // Future: Edit Order agent
  | 'search_contact'  // Future: Search Contact agent

/** Order Manager operating modes */
export type OrderManagerMode = 'full' | 'no_promo' | 'draft'

/** A command to be executed by a CRM agent */
export interface CrmCommand {
  /** Command type determines which agent handles it */
  type: CrmCommandType
  /** Command-specific payload */
  payload: Record<string, unknown>
  /** Source of the command */
  source: 'orchestrator' | 'manual'
  /** Order Manager specific: operating mode */
  orderMode?: OrderManagerMode
}

/** Result from a CRM agent execution */
export interface CrmAgentResult {
  /** Whether the operation succeeded */
  success: boolean
  /** Agent that executed the command */
  agentId: string
  /** Command type that was executed */
  commandType: CrmCommandType
  /** Result data (mock in dry-run, real in live) */
  data?: Record<string, unknown>
  /** Tool calls made during execution (for debug visibility) */
  toolCalls: ToolExecution[]
  /** Token usage per model (if Claude was used) */
  tokensUsed: ModelTokenEntry[]
  /** Execution mode */
  mode: CrmExecutionMode
  /** Execution timestamp */
  timestamp: string
  /** Error info if failed */
  error?: { code: string; message: string }
}

/** CRM agent interface - all CRM agents must implement this */
export interface CrmAgent {
  /** Unique identifier */
  id: string
  /** Human-readable name */
  name: string
  /** Description of what this agent does */
  description: string
  /** Command types this agent can handle */
  supportedCommands: CrmCommandType[]
  /** Execute a command in dry-run or live mode */
  execute(command: CrmCommand, mode: CrmExecutionMode): Promise<CrmAgentResult>
}

/** Configuration for CRM agent UI display in sandbox */
export interface CrmAgentInfo {
  id: string
  name: string
  description: string
  supportedCommands: CrmCommandType[]
}
```

**2. Create `src/lib/agents/crm/base-crm-agent.ts`:**

Abstract base class providing common utilities for CRM agents:

```typescript
/**
 * Base CRM Agent
 * Phase 15.6: Sandbox Evolution
 *
 * Abstract base class for all CRM agents.
 * Provides common utilities: mock generation, test-data prefixing, logging.
 */

import type { CrmAgent, CrmAgentResult, CrmCommand, CrmCommandType, CrmExecutionMode } from './types'
import type { ToolExecution } from '@/lib/sandbox/types'
import type { ModelTokenEntry } from '@/lib/agents/types'

export abstract class BaseCrmAgent implements CrmAgent {
  abstract id: string
  abstract name: string
  abstract description: string
  abstract supportedCommands: CrmCommandType[]

  abstract execute(command: CrmCommand, mode: CrmExecutionMode): Promise<CrmAgentResult>

  /** Generate a mock ID for dry-run mode */
  protected generateMockId(prefix: string): string {
    return `mock-${prefix}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`
  }

  /** Prefix test data in live mode per CONTEXT.md: "test-" prefix */
  protected prefixTestData(input: Record<string, unknown>): Record<string, unknown> {
    const result = { ...input }
    if (typeof result.name === 'string' && !result.name.startsWith('test-')) {
      result.name = `test-${result.name}`
    }
    if (typeof result.nombre === 'string' && !result.nombre.startsWith('test-')) {
      result.nombre = `test-${result.nombre}`
    }
    return result
  }

  /** Build a successful CrmAgentResult */
  protected buildResult(params: {
    commandType: CrmCommandType
    data: Record<string, unknown>
    toolCalls: ToolExecution[]
    tokensUsed: ModelTokenEntry[]
    mode: CrmExecutionMode
  }): CrmAgentResult {
    return {
      success: true,
      agentId: this.id,
      commandType: params.commandType,
      data: params.data,
      toolCalls: params.toolCalls,
      tokensUsed: params.tokensUsed,
      mode: params.mode,
      timestamp: new Date().toISOString(),
    }
  }

  /** Build a failed CrmAgentResult */
  protected buildError(params: {
    commandType: CrmCommandType
    mode: CrmExecutionMode
    code: string
    message: string
  }): CrmAgentResult {
    return {
      success: false,
      agentId: this.id,
      commandType: params.commandType,
      toolCalls: [],
      tokensUsed: [],
      mode: params.mode,
      timestamp: new Date().toISOString(),
      error: { code: params.code, message: params.message },
    }
  }

  /** Build a ToolExecution for dry-run display */
  protected buildMockToolExecution(params: {
    name: string
    input: Record<string, unknown>
    result: { success: boolean; data?: unknown; error?: { code: string; message: string } }
    durationMs?: number
  }): ToolExecution {
    return {
      name: params.name,
      input: params.input,
      result: params.result,
      durationMs: params.durationMs ?? Math.floor(Math.random() * 200) + 50,
      timestamp: new Date().toISOString(),
    }
  }
}
```

**3. Create `src/lib/agents/crm/crm-agent-registry.ts`:**

Registry for CRM agents (similar pattern to the existing agent registry):

```typescript
/**
 * CRM Agent Registry
 * Phase 15.6: Sandbox Evolution
 *
 * Singleton registry for CRM agents. Agents self-register.
 */

import type { CrmAgent, CrmAgentInfo, CrmCommandType } from './types'

class CrmAgentRegistryImpl {
  private agents = new Map<string, CrmAgent>()

  /** Register a CRM agent */
  register(agent: CrmAgent): void {
    if (this.agents.has(agent.id)) {
      console.warn(`[CrmAgentRegistry] Agent already registered: ${agent.id}`)
      return
    }
    this.agents.set(agent.id, agent)
  }

  /** Get a CRM agent by ID. Throws if not found. */
  get(id: string): CrmAgent {
    const agent = this.agents.get(id)
    if (!agent) {
      throw new Error(`CRM agent not found: ${id}`)
    }
    return agent
  }

  /** Find the agent that handles a given command type */
  getAgentForCommand(commandType: CrmCommandType): CrmAgent | undefined {
    for (const agent of this.agents.values()) {
      if (agent.supportedCommands.includes(commandType)) {
        return agent
      }
    }
    return undefined
  }

  /** List all registered CRM agents (for UI dropdown) */
  listAgents(): CrmAgentInfo[] {
    return Array.from(this.agents.values()).map(agent => ({
      id: agent.id,
      name: agent.name,
      description: agent.description,
      supportedCommands: agent.supportedCommands,
    }))
  }

  /** Check if an agent is registered */
  has(id: string): boolean {
    return this.agents.has(id)
  }
}

/** Singleton CRM agent registry */
export const crmAgentRegistry = new CrmAgentRegistryImpl()
```
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty 2>&1 | head -30
```
New files should compile without errors.
  </verify>
  <done>
- CrmAgent interface defined with execute(command, mode) signature
- CrmCommand type with type, payload, source, orderMode
- CrmAgentResult with toolCalls, tokensUsed, mode for debug visibility
- BaseCrmAgent provides generateMockId, prefixTestData, buildResult, buildError
- crmAgentRegistry singleton with register, get, getAgentForCommand, listAgents
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CRM Orchestrator and Order Manager agent</name>
  <files>
    src/lib/agents/crm/crm-orchestrator.ts
    src/lib/agents/crm/order-manager/tools.ts
    src/lib/agents/crm/order-manager/agent.ts
    src/lib/agents/crm/index.ts
  </files>
  <action>
**1. Create `src/lib/agents/crm/crm-orchestrator.ts`:**

Routes CRM commands to the appropriate agent:

```typescript
/**
 * CRM Orchestrator
 * Phase 15.6: Sandbox Evolution
 *
 * Routes CRM commands from the conversational flow to the appropriate CRM agent.
 * The conversational agent (Somnio) never calls CRM agents directly.
 */

import { crmAgentRegistry } from './crm-agent-registry'
import type { CrmCommand, CrmAgentResult, CrmExecutionMode } from './types'

export class CrmOrchestrator {
  /**
   * Route a command to the appropriate CRM agent and execute it.
   *
   * @param command - The CRM command to execute
   * @param mode - dry-run (mock) or live (real DB operations)
   * @returns Result from the CRM agent
   */
  async route(command: CrmCommand, mode: CrmExecutionMode): Promise<CrmAgentResult> {
    const agent = crmAgentRegistry.getAgentForCommand(command.type)

    if (!agent) {
      return {
        success: false,
        agentId: 'unknown',
        commandType: command.type,
        toolCalls: [],
        tokensUsed: [],
        mode,
        timestamp: new Date().toISOString(),
        error: {
          code: 'NO_AGENT',
          message: `No CRM agent registered for command type: ${command.type}`,
        },
      }
    }

    return agent.execute(command, mode)
  }

  /**
   * Check if a command type has a registered handler.
   */
  canHandle(commandType: string): boolean {
    return crmAgentRegistry.getAgentForCommand(commandType as any) !== undefined
  }
}

/** Singleton orchestrator instance */
export const crmOrchestrator = new CrmOrchestrator()
```

**2. Create `src/lib/agents/crm/order-manager/tools.ts`:**

Mock data generators for dry-run mode:

```typescript
/**
 * Order Manager Tool Definitions
 * Phase 15.6: Sandbox Evolution
 *
 * Mock data generators for dry-run mode.
 * In live mode, these are replaced by real Action DSL tool calls.
 */

import type { ToolExecution } from '@/lib/sandbox/types'

/** Generate mock contact creation result */
export function mockCreateContact(input: Record<string, unknown>): ToolExecution {
  return {
    name: 'crm.contact.create',
    input,
    result: {
      success: true,
      data: {
        id: `mock-contact-${Date.now()}`,
        nombre: input.nombre ?? input.name,
        telefono: input.telefono ?? input.phone,
        ciudad: input.ciudad ?? input.city,
        departamento: input.departamento ?? input.department,
        direccion: input.direccion ?? input.address,
        created_at: new Date().toISOString(),
      },
    },
    durationMs: Math.floor(Math.random() * 150) + 80,
    timestamp: new Date().toISOString(),
  }
}

/** Generate mock order creation result */
export function mockCreateOrder(input: Record<string, unknown>): ToolExecution {
  const pack = input.pack as string ?? '1x'
  const prices: Record<string, number> = { '1x': 77900, '2x': 109900, '3x': 139900 }

  return {
    name: 'crm.order.create',
    input,
    result: {
      success: true,
      data: {
        id: `mock-order-${Date.now()}`,
        contactId: input.contactId ?? `mock-contact-${Date.now()}`,
        pack,
        total: prices[pack] ?? 77900,
        status: 'pending',
        pipeline_stage: 'nuevo',
        created_at: new Date().toISOString(),
      },
    },
    durationMs: Math.floor(Math.random() * 200) + 100,
    timestamp: new Date().toISOString(),
  }
}

/** Generate mock tag assignment result */
export function mockAssignTag(input: Record<string, unknown>): ToolExecution {
  return {
    name: 'crm.contact.tag',
    input,
    result: {
      success: true,
      data: {
        contactId: input.contactId,
        tag: input.tag ?? 'somnio-lead',
        assigned: true,
      },
    },
    durationMs: Math.floor(Math.random() * 80) + 30,
    timestamp: new Date().toISOString(),
  }
}
```

**3. Create `src/lib/agents/crm/order-manager/agent.ts`:**

The Order Manager CRM agent with 3 modes:
- `full`: All 8 fields + pack selection (normal flow)
- `no_promo`: All 8 fields, default to 1x pack (skip pack selection)
- `draft`: Only nombre + telefono (create order draft)

```typescript
/**
 * Order Manager CRM Agent
 * Phase 15.6: Sandbox Evolution
 *
 * Creates orders with contacts. Has 3 operating modes:
 * - full: All 8 customer fields + pack selection
 * - no_promo: All 8 fields, default 1x pack (skip promo selection)
 * - draft: Only nombre + telefono (creates draft order)
 */

import { BaseCrmAgent } from '../base-crm-agent'
import type { CrmCommand, CrmAgentResult, CrmCommandType, CrmExecutionMode } from '../types'
import type { ToolExecution } from '@/lib/sandbox/types'
import { mockCreateContact, mockCreateOrder, mockAssignTag } from './tools'

const REQUIRED_FIELDS_FULL = ['nombre', 'telefono', 'ciudad', 'departamento', 'direccion', 'barrio', 'quien_recibe', 'documento']
const REQUIRED_FIELDS_NO_PROMO = ['nombre', 'telefono', 'ciudad', 'departamento', 'direccion', 'barrio', 'quien_recibe', 'documento']
const REQUIRED_FIELDS_DRAFT = ['nombre', 'telefono']

export class OrderManagerAgent extends BaseCrmAgent {
  id = 'order-manager'
  name = 'Order Manager'
  description = 'Crea contactos y ordenes. Soporta 3 modos: completo, sin promo, borrador.'
  supportedCommands: CrmCommandType[] = ['create_order']

  async execute(command: CrmCommand, mode: CrmExecutionMode): Promise<CrmAgentResult> {
    if (command.type !== 'create_order') {
      return this.buildError({
        commandType: command.type,
        mode,
        code: 'UNSUPPORTED_COMMAND',
        message: `Order Manager does not handle command: ${command.type}`,
      })
    }

    const orderMode = command.orderMode ?? 'full'
    const payload = command.payload

    // Validate required fields based on mode
    const requiredFields =
      orderMode === 'full' ? REQUIRED_FIELDS_FULL
      : orderMode === 'no_promo' ? REQUIRED_FIELDS_NO_PROMO
      : REQUIRED_FIELDS_DRAFT

    const missingFields = requiredFields.filter(f => !payload[f])
    if (missingFields.length > 0) {
      return this.buildError({
        commandType: command.type,
        mode,
        code: 'MISSING_FIELDS',
        message: `Missing required fields for mode '${orderMode}': ${missingFields.join(', ')}`,
      })
    }

    if (mode === 'dry-run') {
      return this.executeDryRun(command, orderMode, payload)
    }

    // Live mode: execute real tools (to be wired in Plan 05)
    return this.executeLive(command, orderMode, payload)
  }

  private async executeDryRun(
    command: CrmCommand,
    orderMode: string,
    payload: Record<string, unknown>
  ): Promise<CrmAgentResult> {
    const toolCalls: ToolExecution[] = []

    // Step 1: Create contact
    const contactTool = mockCreateContact({
      nombre: payload.nombre,
      telefono: payload.telefono,
      ciudad: payload.ciudad,
      departamento: payload.departamento,
      direccion: payload.direccion,
    })
    toolCalls.push(contactTool)

    const contactId = (contactTool.result?.data as Record<string, unknown>)?.id as string

    // Step 2: Assign tag
    const tagTool = mockAssignTag({
      contactId,
      tag: 'somnio-lead',
    })
    toolCalls.push(tagTool)

    // Step 3: Create order
    const pack = orderMode === 'no_promo' ? '1x' : (payload.pack as string ?? '1x')
    const orderTool = mockCreateOrder({
      contactId,
      pack,
      nombre: payload.nombre,
      telefono: payload.telefono,
      direccion: payload.direccion,
      ciudad: payload.ciudad,
    })
    toolCalls.push(orderTool)

    return this.buildResult({
      commandType: command.type,
      data: {
        contactId,
        orderId: (orderTool.result?.data as Record<string, unknown>)?.id,
        mode: orderMode,
        pack,
      },
      toolCalls,
      tokensUsed: [], // No Claude calls in dry-run
      mode: 'dry-run',
    })
  }

  private async executeLive(
    command: CrmCommand,
    orderMode: string,
    payload: Record<string, unknown>
  ): Promise<CrmAgentResult> {
    // Live mode: Real tool execution via Action DSL
    // This will be wired in Plan 05 (CRM Sandbox Integration)
    // For now, return same as dry-run with a note
    const dryRunResult = await this.executeDryRun(command, orderMode, payload)
    return {
      ...dryRunResult,
      mode: 'live',
      data: {
        ...dryRunResult.data,
        _note: 'Live mode execution will be wired in Plan 05',
      },
    }
  }
}
```

**4. Create `src/lib/agents/crm/index.ts`:**

```typescript
/**
 * CRM Agent System
 * Phase 15.6: Sandbox Evolution
 *
 * Self-registers CRM agents on import.
 */

export { crmAgentRegistry } from './crm-agent-registry'
export { crmOrchestrator, CrmOrchestrator } from './crm-orchestrator'
export type { CrmAgent, CrmCommand, CrmAgentResult, CrmCommandType, CrmExecutionMode, OrderManagerMode, CrmAgentInfo } from './types'

// Self-register agents
import { OrderManagerAgent } from './order-manager/agent'
import { crmAgentRegistry } from './crm-agent-registry'

crmAgentRegistry.register(new OrderManagerAgent())
```

**IMPORTANT:** The `index.ts` self-registers agents on import, following the same pattern as `src/lib/agents/somnio/index.ts` which self-registers the Somnio agent.
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty 2>&1 | head -30
```
All CRM agent files compile. Registry has Order Manager registered.
  </verify>
  <done>
- CRM agent types fully defined (CrmAgent, CrmCommand, CrmAgentResult)
- BaseCrmAgent provides mock generation, test-prefix, result builders
- crmAgentRegistry singleton with register/get/getAgentForCommand/listAgents
- CrmOrchestrator routes commands to agents
- OrderManagerAgent handles create_order with 3 modes (full, no_promo, draft)
- Dry-run generates realistic mock data for contact + tag + order tool calls
- Live mode stub ready for wiring in Plan 05
- Self-registration via index.ts import
  </done>
</task>

</tasks>

<verification>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty
```
All CRM agent files compile without errors.
</verification>

<success_criteria>
1. CRM agent interface defined with execute(command, mode) method
2. Registry supports register/get/list operations
3. Orchestrator routes commands to correct agent
4. Order Manager handles create_order in 3 modes
5. Dry-run generates mock contact, tag, and order tool calls
6. All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/15.6-sandbox-evolution/15.6-03-SUMMARY.md`
</output>
