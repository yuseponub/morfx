---
phase: 15.6-sandbox-evolution
plan: 05
type: execute
wave: 2
depends_on: ["15.6-01", "15.6-02", "15.6-03"]
files_modified:
  - src/app/(dashboard)/sandbox/components/sandbox-header.tsx
  - src/app/(dashboard)/sandbox/components/sandbox-layout.tsx
  - src/app/(dashboard)/sandbox/components/debug-panel/tools-tab.tsx
  - src/lib/sandbox/sandbox-engine.ts
  - src/lib/sandbox/types.ts
  - src/app/api/sandbox/process/route.ts
  - src/lib/agents/crm/order-manager/agent.ts
autonomous: true

must_haves:
  truths:
    - "Sandbox header has CRM agent multi-select dropdown alongside conversational agent selector"
    - "Tools tab shows dry-run tool calls with inputs and simulated outputs"
    - "Toggle switches between dry-run and live mode per CRM agent"
    - "CRM agent commands are triggered when conversational agent signals order creation"
    - "Live mode executes real Action DSL tools (executeToolFromAgent) with test- prefix on contact names"
    - "Existing Somnio conversational flow still works without CRM agents selected"
  artifacts:
    - path: "src/app/(dashboard)/sandbox/components/sandbox-header.tsx"
      provides: "CRM agent multi-select dropdown with dry-run/live toggles"
      contains: "CrmAgentMultiSelect"
    - path: "src/app/(dashboard)/sandbox/components/debug-panel/tools-tab.tsx"
      provides: "Enhanced tools tab showing dry-run tool calls"
      contains: "dry-run"
    - path: "src/app/(dashboard)/sandbox/components/sandbox-layout.tsx"
      provides: "CRM agent state management and wiring"
      contains: "crmAgents"
    - path: "src/lib/sandbox/sandbox-engine.ts"
      provides: "CRM orchestration integration when shouldCreateOrder is true"
      contains: "crmOrchestrator"
  key_links:
    - from: "sandbox-layout.tsx"
      to: "sandbox-header.tsx"
      via: "Passes CRM agent state and handlers"
      pattern: "crmAgents"
    - from: "sandbox-layout.tsx"
      to: "sandbox-engine.ts"
      via: "Sends CRM agent modes with process request"
      pattern: "crmModes"
    - from: "sandbox-engine.ts"
      to: "crm-orchestrator.ts"
      via: "Routes create_order command when shouldCreateOrder is true"
      pattern: "crmOrchestrator.route"
    - from: "order-manager/agent.ts"
      to: "@/lib/tools/executor"
      via: "executeLive calls executeToolFromAgent for real DB operations"
      pattern: "executeToolFromAgent"
---

<objective>
Wire CRM agents into the sandbox: add multi-select dropdown in header, enhance tools tab for dry-run visibility, integrate CRM orchestrator into SandboxEngine when conversational agent signals order creation.

Purpose: Success Criteria 1 ("Tab Tools muestra que tools se ejecutarian"), 2 ("Toggle permite ejecutar tools reales"), and 3 ("Agentes separados") all depend on this wiring plan.
Output: Working CRM agent integration in sandbox with dry-run tool visibility.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15.6-sandbox-evolution/15.6-01-SUMMARY.md
@.planning/phases/15.6-sandbox-evolution/15.6-02-SUMMARY.md
@.planning/phases/15.6-sandbox-evolution/15.6-03-SUMMARY.md
@src/app/(dashboard)/sandbox/components/sandbox-header.tsx
@src/app/(dashboard)/sandbox/components/sandbox-layout.tsx
@src/app/(dashboard)/sandbox/components/debug-panel/tools-tab.tsx
@src/lib/sandbox/sandbox-engine.ts
@src/lib/sandbox/types.ts
@src/app/api/sandbox/process/route.ts
@src/lib/agents/crm/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CRM agent multi-select dropdown to sandbox header</name>
  <files>
    src/app/(dashboard)/sandbox/components/sandbox-header.tsx
    src/lib/sandbox/types.ts
  </files>
  <action>
**Add CRM agent state type to sandbox types (if not already from Plan 01):**

Verify `CrmAgentState` type exists in `src/lib/sandbox/types.ts` (added in Plan 01). If already present, skip.

**Modify `sandbox-header.tsx`:**

Add a CRM agent multi-select section after the existing conversational agent selector. Use a Popover + Checkbox list pattern (both already installed via Radix UI).

1. Import Popover, Checkbox from shadcn components.
2. Import `CrmAgentState` from sandbox types.
3. Import `Switch` from '@/components/ui/switch'.

4. Add new props to `SandboxHeaderProps`:
```typescript
interface SandboxHeaderProps {
  // ... existing props ...
  crmAgents: CrmAgentState[]
  onCrmAgentToggle: (agentId: string) => void
  onCrmAgentModeChange: (agentId: string, mode: 'dry-run' | 'live') => void
}
```

5. Add CRM agent section between the conversational agent selector and the "Activo" status badge:

```tsx
{/* CRM Agents multi-select */}
<Popover>
  <PopoverTrigger asChild>
    <Button variant="outline" size="sm" className="gap-1.5">
      <Settings className="h-3.5 w-3.5" />
      CRM Agents
      {activeCrmCount > 0 && (
        <Badge variant="secondary" className="ml-1 text-[10px]">
          {activeCrmCount}
        </Badge>
      )}
    </Button>
  </PopoverTrigger>
  <PopoverContent className="w-80 p-0" align="start">
    <div className="p-3 border-b">
      <h4 className="text-sm font-medium">Agentes CRM</h4>
      <p className="text-xs text-muted-foreground mt-1">
        Selecciona agentes CRM para ejecutar operaciones de datos
      </p>
    </div>
    <div className="p-2 space-y-1">
      {crmAgents.map(agent => (
        <div key={agent.agentId} className="flex items-center justify-between p-2 rounded hover:bg-muted/50">
          <div className="flex items-center gap-2">
            <Checkbox
              id={`crm-${agent.agentId}`}
              checked={agent.enabled}
              onCheckedChange={() => onCrmAgentToggle(agent.agentId)}
            />
            <label htmlFor={`crm-${agent.agentId}`} className="text-sm cursor-pointer">
              {agent.name}
            </label>
          </div>
          {agent.enabled && (
            <div className="flex items-center gap-1.5">
              <span className="text-[10px] text-muted-foreground">Dry</span>
              <Switch
                checked={agent.mode === 'live'}
                onCheckedChange={(checked) =>
                  onCrmAgentModeChange(agent.agentId, checked ? 'live' : 'dry-run')
                }
                className="h-4 w-7"
              />
              <span className="text-[10px] text-muted-foreground">Live</span>
            </div>
          )}
        </div>
      ))}
    </div>
  </PopoverContent>
</Popover>
```

Import Popover, PopoverContent, PopoverTrigger from `@/components/ui/popover`.
Import Checkbox from `@/components/ui/checkbox`.
Import Switch from `@/components/ui/switch`.
Import Settings from `lucide-react`.
Import Badge (already imported).

Calculate `activeCrmCount` as `crmAgents.filter(a => a.enabled).length`.
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty 2>&1 | head -30
```
Header compiles. Note: sandbox-layout.tsx will show errors because it doesn't pass the new props yet - that's handled in Task 2.
  </verify>
  <done>
- CRM agent multi-select popover visible in header
- Each agent has checkbox (enable/disable) and dry-run/live toggle
- Active agent count shown as badge
- Props interface extended with CRM agent handlers
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CRM agents into sandbox-layout and sandbox-engine</name>
  <files>
    src/app/(dashboard)/sandbox/components/sandbox-layout.tsx
    src/lib/sandbox/sandbox-engine.ts
    src/app/api/sandbox/process/route.ts
  </files>
  <action>
**Modify `sandbox-layout.tsx`:**

1. Import `CrmAgentState` from sandbox types.
2. **CRITICAL:** Import `'@/lib/agents/crm'` at the top of the file to trigger CRM agent self-registration (the index.ts barrel calls `crmAgentRegistry.register(new OrderManagerAgent())`). Without this import, the registry will be empty.
3. Import `crmAgentRegistry` from `@/lib/agents/crm` to get initial CRM agent list.

```typescript
// At the top of sandbox-layout.tsx, add BOTH imports:
import '@/lib/agents/crm'  // Triggers CRM agent self-registration
import { crmAgentRegistry } from '@/lib/agents/crm'
```

3. Add CRM agent state:
```typescript
// CRM agent state (Phase 15.6)
const [crmAgents, setCrmAgents] = useState<CrmAgentState[]>(() => {
  // Dynamic import pattern - try to get agents from registry
  try {
    // Import triggers self-registration
    const agents = crmAgentRegistry.listAgents()
    return agents.map(a => ({
      agentId: a.id,
      name: a.name,
      description: a.description,
      enabled: false,
      mode: 'dry-run' as const,
    }))
  } catch {
    return []
  }
})
```

But since `crmAgentRegistry` is imported from a library module (not dynamically imported), this should work directly. Add `import { crmAgentRegistry } from '@/lib/agents/crm'` at the top.

4. Add handlers:
```typescript
const handleCrmAgentToggle = useCallback((agentId: string) => {
  setCrmAgents(prev => prev.map(a =>
    a.agentId === agentId ? { ...a, enabled: !a.enabled } : a
  ))
}, [])

const handleCrmAgentModeChange = useCallback((agentId: string, mode: 'dry-run' | 'live') => {
  setCrmAgents(prev => prev.map(a =>
    a.agentId === agentId ? { ...a, mode } : a
  ))
}, [])
```

5. Pass CRM agent state to SandboxHeader:
```tsx
<SandboxHeader
  // ... existing props ...
  crmAgents={crmAgents}
  onCrmAgentToggle={handleCrmAgentToggle}
  onCrmAgentModeChange={handleCrmAgentModeChange}
/>
```

6. Include CRM agent modes in the API request:
```typescript
const enabledCrmAgents = crmAgents
  .filter(a => a.enabled)
  .map(a => ({ agentId: a.agentId, mode: a.mode }))

const response = await fetch('/api/sandbox/process', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    message: content,
    state,
    history,
    turnNumber,
    crmAgents: enabledCrmAgents,
  }),
})
```

7. In `handleReset`, reset CRM agents to disabled:
```typescript
setCrmAgents(prev => prev.map(a => ({ ...a, enabled: false, mode: 'dry-run' as const })))
```

**Modify `src/app/api/sandbox/process/route.ts`:**

1. Import `@/lib/agents/crm` to trigger CRM agent registration (like existing `@/lib/agents/somnio`).
2. Pass CRM agent modes to engine:
```typescript
const { message, state, history, turnNumber, crmAgents: crmModes } = body as {
  message: string
  state: SandboxState
  history: { role: 'user' | 'assistant'; content: string }[]
  turnNumber: number
  crmAgents?: { agentId: string; mode: 'dry-run' | 'live' }[]
}

const result = await engine.processMessage(
  message,
  state,
  history ?? [],
  turnNumber ?? 1,
  crmModes ?? []
)
```

**Modify `src/lib/sandbox/sandbox-engine.ts`:**

1. Import `crmOrchestrator` from `@/lib/agents/crm`.
2. Import `CrmCommand`, `CrmAgentResult` from `@/lib/agents/crm/types`.

3. Add `crmModes` parameter to `processMessage`:
```typescript
async processMessage(
  message: string,
  currentState: SandboxState,
  history: { role: 'user' | 'assistant'; content: string }[],
  turnNumber: number,
  crmModes: { agentId: string; mode: 'dry-run' | 'live' }[] = []
): Promise<SandboxEngineResult> {
```

4. After the orchestrator response (step 7), if `orchestratorResult.shouldCreateOrder` and there are CRM agents enabled, execute CRM:
```typescript
// 9. Execute CRM agents if shouldCreateOrder and CRM agents enabled
if (orchestratorResult.shouldCreateOrder && crmModes.length > 0) {
  const orderManagerMode = crmModes.find(m => m.agentId === 'order-manager')
  if (orderManagerMode) {
    try {
      const crmResult = await crmOrchestrator.route(
        {
          type: 'create_order',
          payload: newState.datosCapturados,
          source: 'orchestrator',
          orderMode: 'full',
        },
        orderManagerMode.mode
      )

      // Add CRM tool calls to debug info
      tools.push(...crmResult.toolCalls)

      // Add CRM token usage
      if (crmResult.tokensUsed.length > 0) {
        tokenDetails.push(...crmResult.tokensUsed)
      }

      // Add CRM result message instead of the sandbox note
      if (crmResult.success) {
        // Remove the "[SANDBOX: Order would be created here...]" message
        // Replace with CRM result
        const lastIdx = messages.findIndex(m => m.startsWith('[SANDBOX: Order would be'))
        if (lastIdx >= 0) {
          messages[lastIdx] = `[CRM ${orderManagerMode.mode}: Order created - ${JSON.stringify(crmResult.data)}]`
        } else {
          messages.push(`[CRM ${orderManagerMode.mode}: Order created - ${JSON.stringify(crmResult.data)}]`)
        }
      }
    } catch (error) {
      messages.push(`[CRM Error: ${error instanceof Error ? error.message : 'Unknown'}]`)
    }
  }
}
```

Move this BEFORE the debugTurn construction so tool calls are included.

**IMPORTANT:** When no CRM agents are enabled, the existing behavior is preserved (the "[SANDBOX: Order would be created here...]" message). This ensures backward compatibility.
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty 2>&1 | head -50
```
All files compile. Existing flow works without CRM agents. With CRM agents enabled, Order Manager executes on shouldCreateOrder.
  </verify>
  <done>
- sandbox-layout.tsx manages CRM agent state (enabled, mode)
- sandbox-header.tsx shows CRM agent multi-select with dry-run/live toggles
- API route passes crmModes to engine
- SandboxEngine routes to CRM orchestrator when shouldCreateOrder + CRM agents enabled
- Tool calls from CRM agents appear in DebugTurn.tools
- Existing flow unchanged when no CRM agents selected
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance Tools tab for dry-run visibility with mode badges</name>
  <files>
    src/app/(dashboard)/sandbox/components/debug-panel/tools-tab.tsx
    src/app/(dashboard)/sandbox/components/debug-panel/index.ts
  </files>
  <action>
**Enhance `tools-tab.tsx`:**

The tools tab currently shows "No se han ejecutado tools todavia" because the existing sandbox never populates tool calls. With CRM agents in dry-run mode, tool calls will now appear.

1. Add a mode badge to tool execution items showing if it was dry-run or live:
```typescript
// Add mode indicator if the tool name starts with "crm." (CRM agent tools)
// or is prefixed with a mode indicator
```

Actually, ToolExecution doesn't currently have a `mode` field. Add an optional `mode` field to the `ToolExecution` interface in `types.ts`:

In `src/lib/sandbox/types.ts`, modify ToolExecution:
```typescript
export interface ToolExecution {
  name: string
  input: Record<string, unknown>
  result?: {
    success: boolean
    data?: unknown
    error?: { code: string; message: string }
  }
  durationMs?: number
  timestamp: string
  /** Execution mode for CRM tools (Phase 15.6) */
  mode?: 'dry-run' | 'live'
}
```

2. In `tools-tab.tsx`, update the `ToolExecutionItem` component to show mode badge:

After the tool name, before the success/error badge:
```tsx
{tool.mode && (
  <Badge
    variant={tool.mode === 'dry-run' ? 'outline' : 'secondary'}
    className={cn(
      'shrink-0 text-[10px]',
      tool.mode === 'live' && 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300'
    )}
  >
    {tool.mode === 'dry-run' ? 'DRY' : 'LIVE'}
  </Badge>
)}
```

3. Add a summary at the top showing tool counts by mode:
```typescript
const dryRunCount = allTools.filter(t => t.mode === 'dry-run').length
const liveCount = allTools.filter(t => t.mode === 'live').length

// Show summary line:
<div className="text-xs text-muted-foreground mb-2">
  {allTools.length} tool{allTools.length !== 1 ? 's' : ''}
  {dryRunCount > 0 && <span className="ml-2">({dryRunCount} dry-run)</span>}
  {liveCount > 0 && <span className="ml-2">({liveCount} live)</span>}
</div>
```

4. In the CRM agent tool mock generators (order-manager/tools.ts from Plan 03), add `mode: 'dry-run'` to mock tool executions. But actually, the mode should be set when the tools are added to the debug turn.

In `sandbox-engine.ts`, after getting CRM result, set mode on tool calls:
```typescript
tools.push(...crmResult.toolCalls.map(t => ({ ...t, mode: orderManagerMode.mode as 'dry-run' | 'live' })))
```

5. Update `index.ts` to export IngestTab:
```typescript
export { IngestTab } from './ingest-tab'
```

**IMPORTANT:** The tools tab must gracefully handle the case where `tool.mode` is undefined (for non-CRM tools) - just don't show the mode badge.
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty 2>&1 | head -30
```
Tools tab compiles and shows mode badges for CRM tools.
  </verify>
  <done>
- ToolExecution has optional `mode` field
- Tools tab shows DRY/LIVE badges for CRM tool calls
- Summary shows count by mode
- Non-CRM tools (mode undefined) render without mode badge
- IngestTab exported from index.ts
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire OrderManagerAgent.executeLive to real Action DSL tools</name>
  <files>
    src/lib/agents/crm/order-manager/agent.ts
  </files>
  <action>
**Replace the `executeLive` stub** in `OrderManagerAgent` with real Action DSL tool calls, following the pattern established in `src/lib/agents/somnio/order-creator.ts`.

1. Import `executeToolFromAgent` from `@/lib/tools/executor`.

2. The `executeLive` method currently falls back to dry-run. Replace it with real tool execution:

```typescript
private async executeLive(
  command: CrmCommand,
  orderMode: string,
  payload: Record<string, unknown>
): Promise<CrmAgentResult> {
  const toolCalls: ToolExecution[] = []
  // Use sandbox workspace for live mode
  const workspaceId = (payload._workspaceId as string) ?? 'sandbox'
  const sessionId = `sandbox-crm-${Date.now()}`

  try {
    // Step 1: Prefix test data per CONTEXT.md ("test-" prefix for live mode)
    const testPayload = this.prefixTestData(payload)

    // Step 2: Create contact via Action DSL (real DB call)
    const createContactResult = await executeToolFromAgent(
      'crm.contact.create',
      {
        name: testPayload.nombre ?? testPayload.name,
        phone: testPayload.telefono ?? testPayload.phone,
        address: [testPayload.direccion, testPayload.barrio].filter(Boolean).join(', '),
        city: testPayload.ciudad ?? testPayload.city,
      },
      workspaceId,
      sessionId,
      sessionId
    )

    const contactToolExec: ToolExecution = {
      name: 'crm.contact.create',
      input: { nombre: testPayload.nombre, telefono: testPayload.telefono, ciudad: testPayload.ciudad },
      result: {
        success: createContactResult.status === 'success',
        data: createContactResult.outputs,
        ...(createContactResult.error && { error: createContactResult.error }),
      },
      durationMs: createContactResult.durationMs ?? 0,
      timestamp: new Date().toISOString(),
      mode: 'live',
    }
    toolCalls.push(contactToolExec)

    const contactId = (createContactResult.outputs as Record<string, unknown>)?.id as string | undefined
    if (!contactId) {
      return this.buildError({
        commandType: command.type,
        mode: 'live',
        code: 'CONTACT_CREATION_FAILED',
        message: 'Failed to create contact in live mode',
      })
    }

    // Step 3: Create order via Action DSL (real DB call)
    const pack = orderMode === 'no_promo' ? '1x' : (payload.pack as string ?? '1x')
    const prices: Record<string, number> = { '1x': 77900, '2x': 109900, '3x': 139900 }

    const createOrderResult = await executeToolFromAgent(
      'crm.order.create',
      {
        contactId,
        products: [{ name: `Somnio 90 Caps${pack !== '1x' ? ' x' + pack.replace('x', '') : ''}`, quantity: parseInt(pack) || 1, price: prices[pack] ?? 77900 }],
        shippingAddress: [testPayload.direccion, testPayload.ciudad].filter(Boolean).join(', '),
      },
      workspaceId,
      sessionId,
      sessionId
    )

    const orderToolExec: ToolExecution = {
      name: 'crm.order.create',
      input: { contactId, pack, total: prices[pack] ?? 77900 },
      result: {
        success: createOrderResult.status === 'success',
        data: createOrderResult.outputs,
        ...(createOrderResult.error && { error: createOrderResult.error }),
      },
      durationMs: createOrderResult.durationMs ?? 0,
      timestamp: new Date().toISOString(),
      mode: 'live',
    }
    toolCalls.push(orderToolExec)

    const orderId = (createOrderResult.outputs as Record<string, unknown>)?.orderId as string | undefined

    return this.buildResult({
      commandType: command.type,
      data: {
        contactId,
        orderId: orderId ?? 'unknown',
        mode: orderMode,
        pack,
        live: true,
      },
      toolCalls,
      tokensUsed: [], // No Claude calls in order creation
      mode: 'live',
    })
  } catch (error) {
    return this.buildError({
      commandType: command.type,
      mode: 'live',
      code: 'LIVE_EXECUTION_ERROR',
      message: error instanceof Error ? error.message : 'Unknown error during live execution',
    })
  }
}
```

**IMPORTANT:**
- The `prefixTestData` method from `BaseCrmAgent` adds "test-" prefix to `nombre`/`name` fields per CONTEXT.md
- The `_workspaceId` is passed through the payload from `sandbox-engine.ts`. Update the CRM route call in Task 2 to include the workspace ID in the payload: `payload: { ...newState.datosCapturados, _workspaceId: 'sandbox' }`
- `executeToolFromAgent` follows the exact same pattern as `order-creator.ts` (already in production)
- The `ToolExecution` items have `mode: 'live'` so the Tools tab shows LIVE badges
- Error handling wraps the entire flow and returns a proper error result

**Also update Task 2 action** to pass `_workspaceId` in the CRM command payload:
```typescript
const crmResult = await crmOrchestrator.route(
  {
    type: 'create_order',
    payload: { ...newState.datosCapturados, _workspaceId: 'sandbox' },
    source: 'orchestrator',
    orderMode: 'full',
  },
  orderManagerMode.mode
)
```
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty 2>&1 | head -30
```
OrderManagerAgent compiles with real executeToolFromAgent import. Live mode path executes real tools.
  </verify>
  <done>
- OrderManagerAgent.executeLive calls executeToolFromAgent for real DB operations
- Contact names are prefixed with "test-" in live mode
- Tool calls from live mode have `mode: 'live'` for UI badge display
- Error handling wraps the entire live flow
- Workspace ID passed through from sandbox-engine
- SC2 (Toggle permite ejecutar tools reales desde sandbox) fully addressed
  </done>
</task>

</tasks>

<verification>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit --pretty
```
All files compile. Full sandbox flow works:
1. Without CRM agents: Same as before
2. With Order Manager in dry-run: Tool calls appear in Tools tab with DRY badge
3. With Order Manager in live: Tool calls appear with LIVE badge (live execution stubbed)
</verification>

<success_criteria>
1. CRM agent multi-select visible in sandbox header
2. Each CRM agent has enable checkbox and dry-run/live toggle
3. Tools tab shows dry-run tool calls with DRY badge and mock inputs/outputs
4. CRM orchestration triggers on shouldCreateOrder when agents enabled
5. Existing Somnio flow unchanged when no CRM agents selected
6. API route passes CRM modes to engine
7. Live mode executes real Action DSL tools via executeToolFromAgent with test- prefix
</success_criteria>

<output>
After completion, create `.planning/phases/15.6-sandbox-evolution/15.6-05-SUMMARY.md`
</output>
