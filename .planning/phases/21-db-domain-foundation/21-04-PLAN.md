---
phase: 21-db-domain-foundation
plan: 04
type: execute
wave: 3
depends_on: ["21-02", "21-03"]
files_modified:
  - src/lib/domain/robot-jobs.ts
  - src/inngest/events.ts
  - src/lib/domain/index.ts
autonomous: true

must_haves:
  truths:
    - "A robot job can be created with N order IDs, producing 1 job row + N item rows"
    - "Creating a job with a duplicate idempotency_key returns an error (not a duplicate job)"
    - "All orders in a job must belong to the same workspace (validated before creation)"
    - "Individual job items can be updated with success (tracking_number) or error (error_type + message)"
    - "When all items complete, job status is updated to 'completed' or 'failed'"
    - "When an item succeeds, the order's tracking_number field is updated via the orders domain module"
    - "Robot-related Inngest event types are defined for job submission and result callbacks"
  artifacts:
    - path: "src/lib/domain/robot-jobs.ts"
      provides: "createRobotJob, updateJobItemResult, updateJobStatus, getJobWithItems, retryFailedItems domain functions"
      exports: ["createRobotJob", "updateJobItemResult", "updateJobStatus", "getJobWithItems", "retryFailedItems"]
    - path: "src/inngest/events.ts"
      provides: "RobotEvents type added to AllAgentEvents"
      contains: "robot/job.submitted"
    - path: "src/lib/domain/index.ts"
      provides: "Barrel exports for new domain modules"
      contains: "carrier-coverage"
  key_links:
    - from: "src/lib/domain/robot-jobs.ts"
      to: "src/lib/domain/orders.ts"
      via: "imports updateOrder to set tracking_number on success"
      pattern: "import.*updateOrder.*from.*orders"
    - from: "src/lib/domain/robot-jobs.ts"
      to: "src/lib/supabase/admin"
      via: "createAdminClient() for DB access"
      pattern: "import.*createAdminClient.*from.*supabase/admin"
    - from: "src/inngest/events.ts"
      to: "src/lib/logistics/constants.ts"
      via: "imports PedidoInput type for robot event payload"
      pattern: "import.*PedidoInput.*from.*logistics/constants"
    - from: "src/lib/domain/index.ts"
      to: "new domain modules"
      via: "barrel re-exports"
      pattern: "export \\* from './robot-jobs'"
---

<objective>
Create the robot-jobs domain module (job lifecycle management), add robot Inngest event types, and update barrel exports.

Purpose: The robot-jobs domain module is the core mutation layer for robot batch operations. It creates jobs with per-order items, updates individual item results (success/error), aggregates job completion status, and updates order tracking numbers through the existing orders domain module. The Inngest events enable Phase 23 (orchestrator) to communicate with the robot service asynchronously. The barrel export update makes all new domain modules importable from `@/lib/domain`.

Output: robot-jobs.ts domain module, updated events.ts with RobotEvents, updated domain/index.ts barrel.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/21-db-domain-foundation/21-CONTEXT.md
@.planning/phases/21-db-domain-foundation/21-RESEARCH.md

# Domain layer patterns
@src/lib/domain/types.ts
@src/lib/domain/orders.ts
@src/lib/domain/index.ts

# Inngest event patterns
@src/inngest/events.ts

# Logistics constants (created in Plan 03)
# @src/lib/logistics/constants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create robot-jobs domain module</name>
  <files>src/lib/domain/robot-jobs.ts</files>
  <action>
Create `src/lib/domain/robot-jobs.ts` following the exact domain module pattern from `orders.ts`.

1. **Header comment** following codebase style:
   ```typescript
   // ============================================================================
   // Domain Layer -- Robot Jobs
   // Single source of truth for ALL robot job mutations.
   // Manages job creation, item result updates, status aggregation,
   // and cross-module updates (order tracking_number on success).
   //
   // Pattern:
   //   1. createAdminClient() (bypasses RLS)
   //   2. Filter by ctx.workspaceId on every query
   //   3. Execute mutation
   //   4. Return DomainResult<T>
   // ============================================================================
   ```

2. **Imports:**
   ```typescript
   import { createAdminClient } from '@/lib/supabase/admin'
   import { updateOrder } from './orders'
   import type { DomainContext, DomainResult } from './types'
   ```

3. **Types:**
   ```typescript
   export interface RobotJob {
     id: string
     workspace_id: string
     carrier: string
     status: 'pending' | 'processing' | 'completed' | 'failed'
     total_items: number
     success_count: number
     error_count: number
     idempotency_key: string | null
     started_at: string | null
     completed_at: string | null
     created_at: string
     updated_at: string
   }

   export interface RobotJobItem {
     id: string
     job_id: string
     order_id: string
     status: 'pending' | 'processing' | 'success' | 'error'
     tracking_number: string | null
     validated_city: string | null
     value_sent: Record<string, unknown> | null
     error_type: 'validation' | 'portal' | 'timeout' | 'unknown' | null
     error_message: string | null
     retry_count: number
     last_retry_at: string | null
     started_at: string | null
     completed_at: string | null
     created_at: string
     updated_at: string
   }
   ```

4. **createRobotJob function:**
   ```typescript
   export interface CreateRobotJobParams {
     carrier?: string       // defaults to 'coordinadora'
     orderIds: string[]
     idempotencyKey?: string
   }

   export interface CreateRobotJobResult {
     jobId: string
     itemCount: number
     items: Array<{ itemId: string; orderId: string }>
   }

   export async function createRobotJob(
     ctx: DomainContext,
     params: CreateRobotJobParams
   ): Promise<DomainResult<CreateRobotJobResult>>
   ```

   Implementation (follow the research example closely):
   a. Default carrier to 'coordinadora'
   b. If idempotencyKey provided, check for existing pending/processing job with same key in workspace. If found, return error with existing job ID.
   c. Verify ALL orderIds belong to ctx.workspaceId (query orders table, compare count).
   d. INSERT into robot_jobs: workspace_id, carrier, total_items = orderIds.length, idempotency_key
   e. INSERT into robot_job_items: one row per orderId with job_id FK
   f. If items INSERT fails, DELETE the job (manual rollback since Supabase doesn't support transactions in JS client)
   g. Return jobId + itemCount + items array (itemId + orderId pairs)

5. **updateJobItemResult function** -- called when robot reports per-order result:
   ```typescript
   export interface UpdateJobItemResultParams {
     itemId: string
     status: 'success' | 'error'
     trackingNumber?: string    // set on success
     validatedCity?: string     // the Coordinadora city string used
     valueSent?: Record<string, unknown>  // PedidoInput snapshot
     errorType?: 'validation' | 'portal' | 'timeout' | 'unknown'
     errorMessage?: string
   }

   export async function updateJobItemResult(
     ctx: DomainContext,
     params: UpdateJobItemResultParams
   ): Promise<DomainResult<{ itemId: string; orderId: string }>>
   ```

   Implementation:
   a. Fetch item with job (to verify workspace): `.from('robot_job_items').select('id, job_id, order_id, robot_jobs!inner(workspace_id)').eq('id', params.itemId).single()`
   b. Verify workspace ownership: `item.robot_jobs.workspace_id === ctx.workspaceId`
   c. Update item: status, tracking_number, validated_city, value_sent, error_type, error_message, completed_at = now
   d. If params.status === 'success' AND trackingNumber is provided:
      - Call `updateOrder(ctx, { orderId: item.order_id, trackingNumber: params.trackingNumber })` to set tracking_number on the CRM order (this triggers automations via the orders domain module)
   e. Update job counters: increment success_count or error_count via raw increment
      ```typescript
      // Use RPC or manual select+update for atomic increment
      const { data: job } = await supabase
        .from('robot_jobs')
        .select('success_count, error_count, total_items')
        .eq('id', item.job_id)
        .single()

      const newSuccessCount = params.status === 'success' ? (job.success_count + 1) : job.success_count
      const newErrorCount = params.status === 'error' ? (job.error_count + 1) : job.error_count

      await supabase
        .from('robot_jobs')
        .update({
          success_count: newSuccessCount,
          error_count: newErrorCount,
        })
        .eq('id', item.job_id)
      ```
   f. Check if all items are complete (success_count + error_count === total_items). If so, auto-update job status to 'completed'.
   g. Return itemId + orderId

6. **updateJobStatus function** -- explicit job status update:
   ```typescript
   export interface UpdateJobStatusParams {
     jobId: string
     status: 'processing' | 'completed' | 'failed'
   }

   export async function updateJobStatus(
     ctx: DomainContext,
     params: UpdateJobStatusParams
   ): Promise<DomainResult<{ jobId: string }>>
   ```

   Implementation:
   a. Verify job belongs to workspace
   b. Update status + set started_at (if transitioning to 'processing') or completed_at (if transitioning to 'completed' or 'failed')
   c. Return jobId

7. **getJobWithItems function** -- read job + all items:
   ```typescript
   export async function getJobWithItems(
     ctx: DomainContext,
     jobId: string
   ): Promise<DomainResult<{ job: RobotJob; items: RobotJobItem[] }>>
   ```

   Implementation:
   a. Fetch job with workspace check
   b. Fetch all items for job_id
   c. Return both

8. **retryFailedItems function** -- reset failed items for retry:
   ```typescript
   export interface RetryFailedItemsParams {
     jobId: string
     itemIds?: string[]  // if provided, retry specific items; if omitted, retry ALL failed
   }

   export async function retryFailedItems(
     ctx: DomainContext,
     params: RetryFailedItemsParams
   ): Promise<DomainResult<{ retriedCount: number; itemIds: string[] }>>
   ```

   Implementation:
   a. Verify job belongs to workspace
   b. Fetch items to retry (status = 'error', optionally filtered by itemIds)
   c. Update each: status = 'pending', increment retry_count, set last_retry_at = now, clear error_type/error_message, clear completed_at
   d. If job status was 'completed' or 'failed', reset to 'pending'
   e. Update job counters: subtract retried items from error_count
   f. Return count + itemIds

**Critical patterns:**
- ALWAYS verify workspace ownership through robot_jobs.workspace_id before any mutation
- Use `createAdminClient()` for all queries
- updateOrder call on success MUST go through the domain module (not direct DB write) -- this ensures automation triggers fire
- All functions return DomainResult<T>
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/domain/robot-jobs.ts` or check build succeeds.
Verify imports: createAdminClient from supabase/admin, updateOrder from ./orders, types from ./types.
Verify exports: createRobotJob, updateJobItemResult, updateJobStatus, getJobWithItems, retryFailedItems, RobotJob type, RobotJobItem type.
Verify updateJobItemResult calls updateOrder on success (grep for 'updateOrder').
Verify workspace ownership is checked in every write function (grep for 'ctx.workspaceId').
  </verify>
  <done>
robot-jobs.ts exports createRobotJob (batch creation with idempotency), updateJobItemResult (per-order result with order tracking_number update via domain), updateJobStatus (explicit status transitions), getJobWithItems (read with items), retryFailedItems (reset failed for retry). All functions verify workspace ownership, use createAdminClient(), return DomainResult<T>. Success results trigger order tracking_number update through the orders domain module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add RobotEvents to Inngest events and update barrel exports</name>
  <files>src/inngest/events.ts, src/lib/domain/index.ts</files>
  <action>
**Part A: Update src/inngest/events.ts**

Add a new `RobotEvents` type section following the exact pattern of AutomationEvents:

1. Add the import for PedidoInput at the top of the file:
   ```typescript
   import type { PedidoInput } from '@/lib/logistics/constants'
   ```

2. Add the RobotEvents section AFTER the AutomationEvents section (before AllAgentEvents):
   ```typescript
   // ============================================================================
   // Robot Events (Phase 21: DB + Domain Foundation)
   // ============================================================================

   /**
    * Robot logistics events for job orchestration.
    * These events drive the robot batch processing workflow.
    *
    * Event naming convention: robot/{entity}.{action}
    * - job: Batch-level lifecycle events
    * - item: Per-order result events
    */
   export type RobotEvents = {
     /**
      * Emitted by MorfX to trigger robot job execution.
      * Consumed by Inngest orchestrator (Phase 23) to call robot service.
      */
     'robot/job.submitted': {
       data: {
         jobId: string
         workspaceId: string
         carrier: string
         credentials: {
           username: string
           password: string
         }
         orders: Array<{
           itemId: string
           orderId: string
           pedidoInput: PedidoInput
         }>
       }
     }

     /**
      * Emitted when robot reports a single order result (success or error).
      * Consumed by Inngest handler that calls updateJobItemResult domain function.
      */
     'robot/item.completed': {
       data: {
         jobId: string
         itemId: string
         workspaceId: string
         status: 'success' | 'error'
         trackingNumber?: string
         errorType?: 'validation' | 'portal' | 'timeout' | 'unknown'
         errorMessage?: string
       }
     }

     /**
      * Emitted when entire robot job completes (all items processed).
      * Used for job-level notifications and cleanup.
      */
     'robot/job.completed': {
       data: {
         jobId: string
         workspaceId: string
         successCount: number
         errorCount: number
       }
     }
   }
   ```

3. Update AllAgentEvents to include RobotEvents:
   ```typescript
   export type AllAgentEvents = AgentEvents & IngestEvents & AutomationEvents & RobotEvents
   ```

**Part B: Update src/lib/domain/index.ts**

Add barrel exports for the three new domain modules. Read the current file first, then append the new exports BEFORE the types export line:

Add these lines:
```typescript
export * from './carrier-coverage'   // Phase 21 Plan 03
export * from './carrier-configs'    // Phase 21 Plan 03
export * from './robot-jobs'         // Phase 21 Plan 04
```

Also add client-activation export if not already present:
```typescript
export * from './client-activation'  // Standalone
```

Keep the existing exports and the `export type { DomainContext, DomainResult } from './types'` line at the end.
  </action>
  <verify>
Run: `npx tsc --noEmit src/inngest/events.ts` -- should compile without errors.
Run: `npx tsc --noEmit src/lib/domain/index.ts` -- should compile without errors.
Verify events.ts has 'robot/job.submitted', 'robot/item.completed', 'robot/job.completed' events.
Verify AllAgentEvents includes RobotEvents: `grep "RobotEvents" src/inngest/events.ts`.
Verify domain/index.ts re-exports carrier-coverage, carrier-configs, robot-jobs: `grep "carrier-coverage\|carrier-configs\|robot-jobs" src/lib/domain/index.ts`.
Run full build check: `npx tsc --noEmit` from project root to verify no circular deps or type errors.
  </verify>
  <done>
events.ts has RobotEvents type with 3 events (robot/job.submitted, robot/item.completed, robot/job.completed) added to AllAgentEvents. domain/index.ts re-exports carrier-coverage, carrier-configs, and robot-jobs modules. Full TypeScript build passes with no errors.
  </done>
</task>

</tasks>

<verification>
1. robot-jobs.ts has 5 exported functions: createRobotJob, updateJobItemResult, updateJobStatus, getJobWithItems, retryFailedItems
2. updateJobItemResult calls updateOrder from orders domain module on success (not direct DB write)
3. createRobotJob checks idempotency_key and verifies order workspace ownership
4. retryFailedItems resets status to pending and increments retry_count
5. events.ts has RobotEvents type with PedidoInput import from logistics/constants
6. AllAgentEvents = AgentEvents & IngestEvents & AutomationEvents & RobotEvents
7. domain/index.ts re-exports all 3 new domain modules
8. `npx tsc --noEmit` passes from project root
</verification>

<success_criteria>
- Robot job lifecycle fully managed through domain functions (create, update items, update status, read, retry)
- Order tracking_number updated through orders domain module on item success (triggers automations)
- Workspace ownership verified on every mutation
- Idempotency protection via unique key check
- Failed item retry support with count tracking
- Robot Inngest events defined for Phase 23 orchestrator
- All new domain modules accessible via `@/lib/domain` barrel import
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/21-db-domain-foundation/21-04-SUMMARY.md`
</output>
