---
phase: 12-action-dsl-real
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/lib/tools/handlers/whatsapp/index.ts
autonomous: true

must_haves:
  truths:
    - "whatsapp.message.send sends a real message via 360dialog API and saves to DB"
    - "whatsapp.message.send checks 24h window and returns error with suggestion for templates if closed"
    - "whatsapp.template.send sends a template message via 360dialog even outside 24h window"
    - "whatsapp.message.list returns real messages from a conversation"
    - "whatsapp.template.list returns available templates from DB"
    - "whatsapp.conversation.list returns real conversations with filters"
    - "whatsapp.conversation.assign assigns a conversation to an agent"
    - "whatsapp.conversation.close closes a conversation"
    - "All handlers use createAdminClient and filter by workspace_id"
  artifacts:
    - path: "src/lib/tools/handlers/whatsapp/index.ts"
      provides: "Real WhatsApp tool handler implementations"
      exports: ["whatsappHandlers"]
      min_lines: 300
  key_links:
    - from: "src/lib/tools/handlers/whatsapp/index.ts"
      to: "src/lib/whatsapp/api.ts"
      via: "sendTextMessage, sendTemplateMessage for 360dialog"
      pattern: "sendTextMessage|sendTemplateMessage"
    - from: "src/lib/tools/handlers/whatsapp/index.ts"
      to: "src/lib/supabase/admin.ts"
      via: "createAdminClient() for DB operations"
      pattern: "createAdminClient"
    - from: "src/lib/tools/handlers/whatsapp/index.ts"
      to: "src/lib/tools/types.ts"
      via: "ToolResult<T> return types"
      pattern: "ToolResult"
---

<objective>
Replace all 7 placeholder WhatsApp tool handlers with real implementations that send messages via 360dialog API and read from Supabase.

Purpose: WhatsApp handlers are critical for the sales agent to communicate with customers. Message sending and template sending must work for real.
Output: Real handlers in src/lib/tools/handlers/whatsapp/index.ts returning ToolResult<T>.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-action-dsl-real/12-RESEARCH.md
@.planning/phases/12-action-dsl-real/12-CONTEXT.md
@.planning/phases/12-action-dsl-real/12-01-SUMMARY.md
@src/lib/tools/types.ts
@src/lib/tools/handlers/whatsapp/index.ts
@src/lib/whatsapp/api.ts
@src/app/actions/messages.ts
@src/lib/supabase/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WhatsApp send handlers (message.send, template.send)</name>
  <files>src/lib/tools/handlers/whatsapp/index.ts</files>
  <action>
  REPLACE the entire content of `src/lib/tools/handlers/whatsapp/index.ts`. Remove all placeholder code and implement real handlers.

  **Imports needed:**
  ```typescript
  import type { ToolHandler, ExecutionContext, ToolResult } from '../../types'
  import { createAdminClient } from '@/lib/supabase/admin'
  import { sendTextMessage, sendTemplateMessage as send360Template } from '@/lib/whatsapp/api'
  ```

  **Helper: `getWhatsAppApiKey(supabase, workspaceId)`**
  - Query `workspaces` table for `settings` by workspace ID
  - Extract `settings.whatsapp_api_key`, fallback to `process.env.WHATSAPP_API_KEY`
  - If neither exists, return error: `{ type: 'external_api_error', code: 'WHATSAPP_NOT_CONFIGURED', message: 'API key de WhatsApp no configurada', suggestion: 'Configure la API key en Configuracion > WhatsApp', retryable: false }`

  **Handler: `whatsapp.message.send`** (ADSL-R06)
  - Adapt from `sendMessage()` in `src/app/actions/messages.ts:97`
  - Input: `contactId`, `message`, optional `replyToMessageId`
  - Multi-step process:
    1. Look up contact by ID (`.eq('id', input.contactId).eq('workspace_id', context.workspaceId)`) to get phone
    2. If not found: return not_found error with suggestion "Verifique el contactId o use crm.contact.list"
    3. Find most recent conversation for this contact (`.eq('contact_id', input.contactId).eq('workspace_id', context.workspaceId).order('last_message_at', { ascending: false }).limit(1).single()`)
    4. If no conversation: return not_found error "No hay conversacion activa con este contacto", suggestion "El contacto debe enviar un mensaje primero para iniciar la conversacion"
    5. Check 24h window: calculate hours since `conversation.last_customer_message_at`. If null or >= 24 hours: return `{ type: 'external_api_error', code: 'WINDOW_CLOSED', message: 'Ventana de 24h cerrada', suggestion: 'Use whatsapp.template.send para enviar fuera de la ventana', retryable: false }`
    6. If dryRun: return preview `{ message_id: 'dry_run_preview', sent: true, timestamp: now, _dry_run: true }`
    7. Get API key via helper
    8. Send via `sendTextMessage(apiKey, conversation.phone, input.message)`
    9. Extract wamid from `response.messages[0]?.id`
    10. Insert message to `messages` table: conversation_id, workspace_id, wamid, direction: 'outbound', type: 'text', content: { body: input.message }, status: 'sent', timestamp: now
    11. Update conversation: last_message_at, last_message_preview (truncate to 100 chars)
    12. Return `{ success: true, data: { message_id: wamid, sent: true, timestamp: now }, message_id: wamid }`
  - Wrap 360dialog API call in try/catch. On failure: return `{ type: 'external_api_error', code: 'WHATSAPP_SEND_FAILED', message: 'Error al enviar mensaje: ${error.message}', retryable: true }`

  **Handler: `whatsapp.template.send`** (ADSL-R07)
  - Adapt from `sendTemplateMessage()` in `src/app/actions/messages.ts:440`
  - Input: `contactId`, `templateName`, optional `templateParams` (object), optional `language` (default 'es')
  - Multi-step process:
    1. Look up contact to get phone (same as message.send)
    2. Find or verify conversation exists for contact
    3. If no conversation: return not_found error
    4. Look up template by name in `templates` table (`.eq('name', input.templateName).eq('workspace_id', context.workspaceId)`)
    5. If not found: return `{ type: 'not_found', code: 'TEMPLATE_NOT_FOUND', message: 'Template no encontrado', suggestion: 'Use whatsapp.template.list para ver templates disponibles' }`
    6. If template status !== 'APPROVED': return `{ type: 'validation_error', code: 'TEMPLATE_NOT_APPROVED', message: 'Template no aprobado por Meta' }`
    7. If dryRun: return preview
    8. Get API key
    9. Build template components from templateParams (map params to body component parameters, same as messages.ts:492-501)
    10. Send via `send360Template(apiKey, conversation.phone, input.templateName, language, components)`
    11. Extract wamid
    12. Insert message to DB with type: 'template', content: { template_name: templateName, params: templateParams }
    13. Update conversation last_message_at
    14. Return `{ success: true, data: { message_id: wamid, sent: true, templateUsed: templateName, timestamp: now }, message_id: wamid }`
  - Same error handling pattern for 360dialog failures

  **CRITICAL rules:**
  - Use `createAdminClient()` (NOT createClient)
  - EVERY query MUST include `.eq('workspace_id', context.workspaceId)`
  - Do NOT call `revalidatePath()`, `cookies()`, or `auth.getUser()`
  - Return `ToolResult<T>` always, never throw
  - For 360dialog errors: catch, classify, return structured error
  </action>
  <verify>
  `npx tsc --noEmit` passes. `grep -n "sendTextMessage\|send360Template" src/lib/tools/handlers/whatsapp/index.ts` confirms 360dialog API usage.
  </verify>
  <done>
  whatsapp.message.send and whatsapp.template.send implemented with 24h window check, 360dialog API integration, DB persistence, and structured error responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WhatsApp read-only and management handlers</name>
  <files>src/lib/tools/handlers/whatsapp/index.ts</files>
  <action>
  Add the remaining 5 handlers to the same file (continuing from Task 1):

  **Handler: `whatsapp.message.list`**
  - Query `messages` table for a conversation
  - Input: `conversationId`, optional `limit` (default 50), optional `before`, `after` (cursor-based pagination by timestamp)
  - Verify conversation belongs to workspace: `.eq('id', input.conversationId)` on `conversations` table with `.eq('workspace_id', context.workspaceId)`
  - If conversation not found: return not_found error
  - Query messages: `.eq('conversation_id', input.conversationId).order('timestamp', { ascending: false }).limit(input.limit || 50)`
  - If `before` provided: add `.lt('timestamp', beforeTimestamp)`
  - Return `{ success: true, data: { messages: [...], hasMore: messages.length === limit } }`

  **Handler: `whatsapp.template.list`**
  - Query `templates` table for workspace
  - Input: optional `status` filter ('approved', 'pending', 'rejected')
  - Filter by workspace_id
  - If status filter: add `.eq('status', input.status.toUpperCase())`
  - Return `{ success: true, data: { templates: [...] } }`

  **Handler: `whatsapp.conversation.list`**
  - Query `conversations` table with joins for contact info
  - Input: optional `status` ('open'|'closed'|'all', default 'open'), optional `assignedTo`, optional `unassignedOnly`, optional `page`/`pageSize`
  - Filter by workspace_id
  - Status filter: if not 'all', filter by status (map 'open' to 'active')
  - assignedTo: filter `.eq('assigned_to', input.assignedTo)`
  - unassignedOnly: filter `.is('assigned_to', null)`
  - Pagination with `.range()` and count
  - Return paginated result: `{ conversations, total, page, totalPages }`

  **Handler: `whatsapp.conversation.assign`**
  - Input: `conversationId`, `agentId`
  - Verify conversation belongs to workspace
  - Get current assigned_to value
  - Update `assigned_to` to agentId
  - Return `{ success: true, data: { conversationId, previousAgent, newAgent: agentId, assigned: true } }`

  **Handler: `whatsapp.conversation.close`**
  - Input: `conversationId`, optional `resolution`
  - Verify conversation belongs to workspace
  - Update status to 'closed', add closed_at timestamp
  - If resolution provided, could store in notes or metadata
  - Return `{ success: true, data: { conversationId, closed: true, closedAt: timestamp } }`

  Ensure ALL 7 handlers are exported in the `whatsappHandlers` record with the same keys as the original placeholders.
  </action>
  <verify>
  `npx tsc --noEmit` passes. Verify all 7 handler keys: `grep "'whatsapp\." src/lib/tools/handlers/whatsapp/index.ts` returns 7 keys. `grep -c "workspace_id" src/lib/tools/handlers/whatsapp/index.ts` confirms workspace isolation on every handler.
  </verify>
  <done>
  All 7 WhatsApp handlers implemented: message.send, message.list, template.send, template.list, conversation.list, conversation.assign, conversation.close. All use createAdminClient, all filter by workspace_id, all return ToolResult<T>.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 7 WhatsApp handler keys present in whatsappHandlers export
3. whatsapp.message.send checks 24h window before sending
4. whatsapp.template.send verifies template is APPROVED before sending
5. Every handler uses createAdminClient (no createClient)
6. Every Supabase query filters by workspace_id
7. No calls to revalidatePath, cookies(), or auth.getUser()
8. 360dialog API errors return structured ToolError with type 'external_api_error'
</verification>

<success_criteria>
- whatsapp.message.send sends real WhatsApp message and saves to DB
- whatsapp.template.send sends template via 360dialog even outside 24h window
- 24h window enforcement prevents free-form messages when window closed
- All handlers return ToolResult<T> with proper error classification
</success_criteria>

<output>
After completion, create `.planning/phases/12-action-dsl-real/12-03-SUMMARY.md`
</output>
