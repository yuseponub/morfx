# Phase 15.7: Ingest Timer Pluggable - Research

**Researched:** 2026-02-08
**Domain:** Frontend timer simulation, state machine, sandbox debug UI
**Confidence:** HIGH (all findings verified from codebase investigation)

## Summary

This phase makes the ingest timer functional, configurable, and pluggable within the sandbox. The current codebase has the timer infrastructure partially built:
- IngestManager (Phase 15.5) correctly classifies messages, extracts data, and returns `shouldEmitTimerStart` signals
- SandboxEngine **ignores** these signals entirely (line 421: `timerExpiresAt: null, // Timer simulation not needed in sandbox`)
- The Ingest tab has timer preset UI (Real/Rapido/Instantaneo) and 2 sliders, but `onTimerChange` is never wired to anything
- The debug panel shows a `TimerCountdown` component that checks `timerExpiresAt`, which is always null

The work requires: (1) a new timer simulation engine that runs in the frontend via `setTimeout`/`setInterval`, (2) expanding from 2 timer levels to 5, (3) wiring the timer config from the UI through to the simulation, and (4) timer actions that inject messages into the chat.

**Primary recommendation:** Build an `IngestTimerSimulator` class that manages a state machine with 5 levels, runs countdowns via `setInterval`, and emits timer actions (messages + state transitions) via callbacks. The simulator lives in the frontend (React context or hook), NOT on the server. Timer config flows from IngestTab sliders to the simulator. Timer actions flow from the simulator back into the chat as agent messages.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| React 19 | 19.2.3 | State management for timer, hooks for lifecycle | Already in stack |
| TypeScript | strict | Type-safe timer state machine | Already in stack |
| Next.js 16 | 16.1.5 | App Router, API routes | Already in stack |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| date-fns | (installed) | Timer display formatting | Already used in ingest-tab.tsx |
| lucide-react | 0.563.0 | Timer/Pause/Play icons | Already used in ingest-tab.tsx |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `setInterval` for countdown | `requestAnimationFrame` | rAF is smoother but overkill for 1-second resolution countdown; setInterval is simpler and already used in TimerCountdown |
| Frontend timer class | Server-sent events | SSE adds network complexity; setTimeout/setInterval in frontend is the locked decision from CONTEXT.md |
| Custom state machine | XState/Zustand | Overkill for 5-level linear state machine; plain TypeScript class is sufficient |

**Installation:** No new dependencies needed.

## Architecture Patterns

### Current Architecture (What Exists)

```
src/
├── lib/
│   ├── agents/somnio/
│   │   ├── ingest-manager.ts      # Classification + extraction + accumulation (WORKS)
│   │   ├── data-extractor.ts      # Claude-based field extraction (WORKS)
│   │   └── message-classifier.ts  # datos/pregunta/mixto/irrelevante (WORKS)
│   └── sandbox/
│       ├── sandbox-engine.ts      # Server-side message processing (IGNORES timer signals)
│       └── types.ts               # IngestStatus with timerExpiresAt (always null)
└── app/(dashboard)/sandbox/
    └── components/
        ├── debug-panel/
        │   ├── ingest-tab.tsx     # Timer presets + 2 sliders (NOT wired)
        │   └── panel-container.tsx # Renders IngestTab WITHOUT onTimerChange
        └── sandbox-layout.tsx     # Main layout (no timer state management)
```

### Recommended Architecture (Phase 15.7)

```
src/
├── lib/
│   ├── agents/somnio/
│   │   └── ingest-manager.ts      # UNCHANGED (already works correctly)
│   └── sandbox/
│       ├── sandbox-engine.ts      # ADD: return shouldEmitTimerStart in result
│       ├── types.ts               # EXTEND: IngestStatus with timer level, 5-level config
│       └── ingest-timer.ts        # NEW: IngestTimerSimulator class (pure logic, no React)
└── app/(dashboard)/sandbox/
    └── components/
        ├── debug-panel/
        │   ├── ingest-tab.tsx     # EXTEND: 5 sliders, toggle, countdown, pause
        │   └── panel-container.tsx # WIRE: onTimerChange through prop chain
        └── sandbox-layout.tsx     # ADD: timer state, IngestTimerSimulator instance
```

### Pattern 1: Timer Simulation Engine (Pure Logic Class)

**What:** A class that manages the 5-level timer state machine without React dependencies.
**When to use:** When the timer needs to track levels, manage countdowns, and emit actions.

```typescript
// Source: Codebase analysis of existing patterns
interface TimerLevel {
  id: number
  name: string
  condition: (state: TimerEvalContext) => boolean
  defaultDurationMs: number
  action: TimerAction
}

interface TimerAction {
  type: 'send_message' | 'transition_mode' | 'create_order'
  message?: string
  targetMode?: string
  orderConfig?: { valor: number; pack?: string }
}

interface TimerEvalContext {
  fieldsCollected: string[]
  totalFields: number
  currentMode: string
  packSeleccionado: string | null
  promosOffered: boolean
}

class IngestTimerSimulator {
  private currentLevel: number | null = null
  private timerId: ReturnType<typeof setTimeout> | null = null
  private tickId: ReturnType<typeof setInterval> | null = null
  private startedAt: number | null = null
  private durationMs: number = 0
  private paused: boolean = false
  private pausedRemainingMs: number = 0

  // Callbacks
  onTick: (remainingMs: number, level: number) => void
  onExpire: (level: number, action: TimerAction) => void

  start(level: number, durationMs: number): void
  stop(): void
  pause(): void
  resume(): void
  reevaluateLevel(context: TimerEvalContext): void
}
```

### Pattern 2: Timer State Lifted to SandboxLayout

**What:** Timer state lives in `sandbox-layout.tsx` alongside other sandbox state, managed via a `useIngestTimer` custom hook.
**When to use:** When the timer needs to coordinate with chat messages, sandbox state, and debug panel.

```typescript
// Pattern: Custom hook wrapping IngestTimerSimulator
function useIngestTimer(config: TimerConfig) {
  const [timerState, setTimerState] = useState<TimerState>({
    active: false,
    level: null,
    remainingMs: 0,
    paused: false,
  })

  const simulatorRef = useRef<IngestTimerSimulator | null>(null)

  // Cleanup on unmount
  useEffect(() => {
    return () => simulatorRef.current?.stop()
  }, [])

  const startTimer = useCallback((level: number) => { ... }, [config])
  const stopTimer = useCallback(() => { ... }, [])
  const pauseTimer = useCallback(() => { ... }, [])
  const reevaluateLevel = useCallback((context: TimerEvalContext) => { ... }, [config])

  return { timerState, startTimer, stopTimer, pauseTimer, reevaluateLevel }
}
```

### Pattern 3: Timer Actions as Chat Messages

**What:** Timer expiration injects messages into the sandbox chat as normal agent messages.
**When to use:** When timer fires and needs to send "Quedamos pendientes..." style messages.

```typescript
// Pattern: Timer action handler in sandbox-layout.tsx
const handleTimerExpire = useCallback((level: number, action: TimerAction) => {
  if (action.type === 'send_message' && action.message) {
    const timerMessage: SandboxMessage = {
      id: `msg-${Date.now()}-timer`,
      role: 'assistant',
      content: action.message,
      timestamp: new Date().toISOString(),
    }
    setMessages(prev => [...prev, timerMessage])
  }

  if (action.targetMode) {
    setState(prev => ({ ...prev, currentMode: action.targetMode! }))
  }

  if (action.type === 'create_order') {
    // Simulate order creation (sandbox placeholder)
    // Similar to existing shouldCreateOrder handling in sandbox-engine.ts
  }
}, [])
```

### Anti-Patterns to Avoid

- **Running timer on server:** The sandbox API route (`/api/sandbox/process`) is stateless and request-based. Timer simulation MUST run in the browser. The server only evaluates data and returns `shouldEmitTimerStart` signals.
- **Mixing timer logic into SandboxEngine:** SandboxEngine processes individual messages. Timer is a long-running process that exists between messages. Keep them separated.
- **Restarting timer on every data message:** CONTEXT.md [15.5-02] explicitly states "Timer starts on FIRST data only, does NOT restart on additional data." Re-evaluation changes the level but does NOT restart the countdown from zero (it adjusts the remaining time based on new level's duration minus elapsed time).
- **Using production Inngest patterns:** Inngest uses `step.waitForEvent` and `step.sleep`. Sandbox timer uses `setTimeout`/`setInterval`. Don't try to abstract over both.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Timer countdown formatting | Custom mm:ss formatter | Reuse `formatSeconds()` from ingest-tab.tsx | Already handles 0s, Ns, Nmin, Nmin Ns |
| Field evaluation logic | Custom field counting | Reuse `hasMinimumData()`, `hasCriticalData()`, `getFieldCounts()` from data-extractor.ts | Already handles N/A, empty strings, critical vs additional |
| Human-readable field names | Hardcoded mapping | Reuse/extend `buildTimeoutMessage()` from agent-timers.ts (fieldLabels map) | Already maps nombre, telefono, etc. to readable labels |
| Timer configuration structure | Ad-hoc config objects | Use the same shape as `TIMER_PRESETS` from ingest-tab.tsx | Already defines Real/Rapido/Instantaneo pattern |

**Key insight:** Most building blocks exist. The 2-level timer (partial/no_data) in ingest-tab.tsx needs to be extended to 5 levels, and the simulation logic needs to be created. But field evaluation, message formatting, and UI patterns are all reusable.

## Common Pitfalls

### Pitfall 1: Timer Level Re-evaluation Race Condition
**What goes wrong:** When new data arrives and causes a level change while a timer is counting down, the old setTimeout fires with stale level information.
**Why it happens:** `setTimeout` captures the level at the time of creation, not at the time of firing.
**How to avoid:** On reevaluation: (1) clear existing timeout, (2) calculate new level, (3) if level changed, start new timer with new duration adjusted for elapsed time. Store timer state in a ref, not in the timeout closure.
**Warning signs:** Timer fires an action for the wrong level after data was received.

### Pitfall 2: Timer Not Restarting When Preset Changes
**What goes wrong:** User changes preset from "Real" to "Rapido" while timer is running, but timer continues with old duration.
**Why it happens:** Preset change UI updates state but doesn't notify the timer simulator.
**How to avoid:** Preset/slider changes must call `simulator.restart(currentLevel, newDurationMs)` with the updated duration. The timer should recalculate remaining time proportionally or restart with new total.
**Warning signs:** Countdown shows old values after changing preset.

### Pitfall 3: State Desync Between Timer and SandboxEngine
**What goes wrong:** Timer fires level 2 (transition to ofrecer_promos) but SandboxEngine still thinks we're in collecting_data when the next message arrives.
**Why it happens:** Timer actions update `state` in sandbox-layout but the next API call sends this state to the server. If the state update didn't include mode change, the server processes incorrectly.
**How to avoid:** Timer actions that change mode MUST update `state.currentMode` via `setState` before the next message is processed. Level 2 (silent transition) and level 3/4 (order creation) both change mode.
**Warning signs:** After timer fires, the next user message is processed in the wrong mode.

### Pitfall 4: Timer Continues After Session Reset
**What goes wrong:** User clicks "Nueva Sesion" but timer from previous session keeps counting and fires.
**Why it happens:** `handleReset` in sandbox-layout doesn't clear the timer.
**How to avoid:** Add `simulator.stop()` call to `handleReset` callback.
**Warning signs:** Ghost messages appear in new session from old timer.

### Pitfall 5: `timerExpiresAt` Always Null (Current Bug)
**What goes wrong:** The TimerCountdown component in ingest-tab.tsx checks `ingestStatus.timerExpiresAt` which is hardcoded to `null` in sandbox-engine.ts line 421.
**Why it happens:** Phase 15.5/15.6 deferred timer simulation to this phase.
**How to avoid:** The timer simulator should update `ingestStatus.timerExpiresAt` via the same `setState` callback that updates sandbox state. OR, better: the TimerCountdown component should read from the timer simulator's state directly (via prop or context) rather than from `ingestStatus.timerExpiresAt`.
**Warning signs:** Countdown always shows "-".

### Pitfall 6: Missing Fields Definition Mismatch
**What goes wrong:** CONTEXT.md says 6 minimum fields: nombre, apellido, telefono, direccion, ciudad, departamento. But CRITICAL_FIELDS in data-extractor.ts has only 5: nombre, telefono, direccion, ciudad, departamento (no apellido). And `hasMinimumData()` checks for count >= 5 of critical fields.
**Why it happens:** CONTEXT.md for phase 15.7 added apellido to the "minimum" set, but the existing code's CRITICAL_FIELDS was defined earlier.
**How to avoid:** The timer level evaluation function should use its OWN field list for "minimum 6" (adding apellido), distinct from the data-extractor's CRITICAL_FIELDS which is used for different purposes (order creation validation). Define `TIMER_MINIMUM_FIELDS` separately.
**Warning signs:** Level transitions happen at wrong field counts.

## Code Examples

### Example 1: Timer Level Definitions (5 Levels)

```typescript
// Source: CONTEXT.md decisions, mapped to code structure
const TIMER_MINIMUM_FIELDS = [
  'nombre', 'apellido', 'telefono', 'direccion', 'ciudad', 'departamento'
] as const // 6 fields

const TIMER_ALL_FIELDS = [
  ...TIMER_MINIMUM_FIELDS, 'barrio', 'correo'  // or indicaciones_extra
] as const // 8 fields

const FIELD_LABELS: Record<string, string> = {
  nombre: 'Nombre completo',
  apellido: 'Apellido',
  telefono: 'Numero de telefono',
  direccion: 'Direccion completa',
  ciudad: 'Ciudad o municipio',
  departamento: 'Departamento',
  barrio: 'Barrio',
  correo: 'Correo electronico',
}

interface TimerLevelConfig {
  id: number
  name: string
  defaultDurationS: number  // seconds
  evaluate: (ctx: TimerEvalContext) => boolean
  buildAction: (ctx: TimerEvalContext) => TimerAction
}

const TIMER_LEVELS: TimerLevelConfig[] = [
  {
    id: 0,
    name: 'Sin datos',
    defaultDurationS: 600, // 10 min
    evaluate: (ctx) => ctx.currentMode === 'collecting_data' && ctx.totalFields === 0,
    buildAction: () => ({
      type: 'send_message',
      message: 'Quedamos pendientes a tus datos, o si tienes alguna pregunta acerca del producto no dudes en hacerla',
    }),
  },
  {
    id: 1,
    name: 'Datos parciales',
    defaultDurationS: 360, // 6 min
    evaluate: (ctx) => {
      const hasMinimum = TIMER_MINIMUM_FIELDS.every(f => ctx.fieldsCollected.includes(f))
      return ctx.currentMode === 'collecting_data' && ctx.totalFields > 0 && !hasMinimum
    },
    buildAction: (ctx) => {
      const missing = TIMER_MINIMUM_FIELDS
        .filter(f => !ctx.fieldsCollected.includes(f))
        .map(f => `- ${FIELD_LABELS[f]}`)
      return {
        type: 'send_message',
        message: `Para poder despachar tu producto nos faltaria:\n${missing.join('\n')}\nQuedamos pendientes`,
      }
    },
  },
  {
    id: 2,
    name: 'Datos minimos',
    defaultDurationS: 120, // 2 min
    evaluate: (ctx) => {
      const hasMinimum = TIMER_MINIMUM_FIELDS.every(f => ctx.fieldsCollected.includes(f))
      return ctx.currentMode === 'collecting_data' && hasMinimum
    },
    buildAction: () => ({
      type: 'transition_mode',
      targetMode: 'ofrecer_promos',
      // Silent - no message
    }),
  },
  {
    id: 3,
    name: 'Promos sin respuesta',
    defaultDurationS: 600, // 10 min
    evaluate: (ctx) => ctx.currentMode === 'ofrecer_promos' && !ctx.packSeleccionado,
    buildAction: () => ({
      type: 'create_order',
      message: 'Quedamos pendientes a la promocion que desees para poder despachar tu orden',
      orderConfig: { valor: 0 },
    }),
  },
  {
    id: 4,
    name: 'Pack sin confirmar',
    defaultDurationS: 600, // 10 min
    evaluate: (ctx) => ctx.currentMode === 'ofrecer_promos' && !!ctx.packSeleccionado,
    buildAction: (ctx) => ({
      type: 'create_order',
      message: 'Quedamos pendientes a la confirmacion de tu compra para poder despachar tu orden',
      orderConfig: { valor: 0, pack: ctx.packSeleccionado ?? undefined },
    }),
  },
]
```

### Example 2: Timer Config with 5 Sliders

```typescript
// Source: Extending existing TIMER_PRESETS from ingest-tab.tsx
interface TimerConfig {
  levels: {
    [levelId: number]: number  // seconds per level
  }
}

const TIMER_DEFAULTS: TimerConfig = {
  levels: {
    0: 600,  // 10 min - sin datos
    1: 360,  // 6 min  - datos parciales
    2: 120,  // 2 min  - datos minimos
    3: 600,  // 10 min - promos sin respuesta
    4: 600,  // 10 min - pack sin confirmar
  },
}

type TimerPreset = 'real' | 'rapido' | 'instantaneo'

const TIMER_PRESETS: Record<TimerPreset, TimerConfig> = {
  real: {
    levels: { 0: 600, 1: 360, 2: 120, 3: 600, 4: 600 },
  },
  rapido: {
    levels: { 0: 60, 1: 30, 2: 10, 3: 60, 4: 60 },
  },
  instantaneo: {
    levels: { 0: 2, 1: 2, 2: 1, 3: 2, 4: 2 }, // Minimum 1-2s, not actual 0
  },
}
```

### Example 3: SandboxEngine Timer Signal Propagation

```typescript
// Source: sandbox-engine.ts handleIngestMode, currently ignoring shouldEmitTimerStart
// The SandboxEngineResult needs to carry timer signals to the frontend

// In types.ts - extend SandboxEngineResult:
export interface SandboxEngineResult {
  success: boolean
  messages: string[]
  debugTurn: DebugTurn
  newState: SandboxState
  error?: { code: string; message: string }
  // NEW: Timer control signals
  timerSignal?: {
    type: 'start' | 'reevaluate' | 'cancel'
    level?: number       // For start/reevaluate
    reason?: string      // For cancel
  }
}
```

### Example 4: Timer Countdown in Debug Panel

```typescript
// Source: Extending existing TimerCountdown from ingest-tab.tsx
// Current: checks timerExpiresAt (always null)
// New: receives timer state from simulator via props

interface TimerDisplayProps {
  active: boolean
  level: number | null
  levelName: string
  remainingMs: number
  paused: boolean
  onPause: () => void
  onResume: () => void
}

function TimerDisplay({ active, level, levelName, remainingMs, paused, onPause, onResume }: TimerDisplayProps) {
  if (!active || level === null) {
    return <span className="text-xs text-muted-foreground">-</span>
  }

  const totalSeconds = Math.ceil(remainingMs / 1000)
  const minutes = Math.floor(totalSeconds / 60)
  const seconds = totalSeconds % 60
  const display = `${minutes}:${seconds.toString().padStart(2, '0')}`

  return (
    <div className="flex items-center gap-1.5">
      <Timer className="h-3.5 w-3.5 text-muted-foreground" />
      <span className="text-sm font-medium font-mono">{display}</span>
      <span className="text-xs text-muted-foreground">
        (L{level}: {levelName})
      </span>
      <button onClick={paused ? onResume : onPause}>
        {paused ? <Play /> : <Pause />}
      </button>
    </div>
  )
}
```

## State of the Art

| Old Approach (Current) | New Approach (Phase 15.7) | What Changes |
|------------------------|---------------------------|-------------|
| 2 timer types: partial / no_data | 5 timer levels: 0-4 with distinct actions | Richer state machine |
| Timer signals ignored in sandbox | Timer simulated via setTimeout in frontend | Actually functional |
| timerExpiresAt always null | Timer countdown driven by simulator state | Real countdown display |
| 2 sliders (partial, noData) | 5 independent sliders (one per level) | Granular control |
| Presets are cosmetic (UI only) | Presets drive actual timer durations | Functional config |
| Timer never fires actions | Timer fires messages, mode transitions, order creation | Full lifecycle |

## Codebase Analysis: Files to Modify

### Files to CREATE

| File | Purpose |
|------|---------|
| `src/lib/sandbox/ingest-timer.ts` | IngestTimerSimulator class + TimerLevelConfig + TimerConfig constants |

### Files to MODIFY

| File | What Changes | Why |
|------|-------------|-----|
| `src/lib/sandbox/types.ts` | Add `timerSignal` to SandboxEngineResult, extend IngestStatus with timer level, add timer config types | Type definitions for 5-level timer |
| `src/lib/sandbox/sandbox-engine.ts` | Propagate `shouldEmitTimerStart` and timer level info in result instead of hardcoding `timerExpiresAt: null` | Bug fix: timer signal propagation |
| `src/app/(dashboard)/sandbox/components/sandbox-layout.tsx` | Add timer state management, instantiate IngestTimerSimulator, handle timer actions (inject messages, update mode), wire timer config | Main integration point |
| `src/app/(dashboard)/sandbox/components/debug-panel/ingest-tab.tsx` | Expand from 2 sliders to 5, add timer toggle, replace TimerCountdown with simulator-driven display, add pause button | UI for 5-level timer |
| `src/app/(dashboard)/sandbox/components/debug-panel/panel-container.tsx` | Pass timer props through to IngestTab | Prop drilling for timer state/callbacks |
| `src/app/(dashboard)/sandbox/components/debug-panel/debug-tabs.tsx` | Add timer-related props to DebugTabsProps | Prop drilling |

### Files NOT to modify

| File | Why Not |
|------|---------|
| `src/lib/agents/somnio/ingest-manager.ts` | Already works correctly. Timer is separate from ingest. |
| `src/lib/agents/somnio/somnio-engine.ts` | Production engine uses Inngest, not sandbox timer. |
| `src/inngest/functions/agent-timers.ts` | Production timer functions. Phase 15.7 is sandbox-only. |
| `src/lib/agents/somnio/data-extractor.ts` | Field extraction logic unchanged. |

## Critical Implementation Details

### 1. Timer Level Evaluation Logic

The timer evaluates which level applies based on current state. Level evaluation happens:
- When timer is first started (after `shouldEmitTimerStart` from IngestManager)
- When new data arrives (re-evaluate level, possibly change timer)
- When mode transitions (e.g., collecting_data -> ofrecer_promos activates levels 3-4)

**Level precedence:** Evaluate levels 0-4 in order. First matching level wins. Levels 0-2 only apply in `collecting_data` mode. Levels 3-4 only apply in `ofrecer_promos` mode.

### 2. Timer Behavior on Data Arrival

From CONTEXT.md: "datos re-evaluan nivel, preguntas no interrumpen"

When data arrives:
1. IngestManager processes the data (extraction, accumulation)
2. SandboxEngine returns result with updated fields and timer reevaluation signal
3. Frontend calls `simulator.reevaluateLevel(newContext)`
4. If level changed (e.g., from 1 to 2): restart timer with new level's duration
5. If level unchanged: timer continues counting down (no restart)

When question arrives:
1. IngestManager classifies as 'pregunta'
2. Normal orchestrator processes the response
3. Timer is NOT affected (continues counting)

### 3. Timer-to-Chat Message Injection

Timer messages must appear as normal assistant messages in the chat. They should NOT be processed by the server (no API call). They are purely frontend-injected messages.

```typescript
// In sandbox-layout.tsx handleTimerExpire callback
const timerMessage: SandboxMessage = {
  id: `msg-${Date.now()}-timer`,
  role: 'assistant',
  content: action.message,
  timestamp: new Date().toISOString(),
}
setMessages(prev => [...prev, timerMessage])
```

### 4. Level 2 Silent Transition

Level 2 (datos minimos) fires silently - no message. It transitions to `ofrecer_promos` mode. The next time the user sends a message, the server will process it in ofrecer_promos mode and return the promo templates.

But wait: the user might NOT send another message after the transition. In that case, the timer should immediately start level 3 (promos sin respuesta, 10 min). So the timer system needs to chain: level 2 expires -> transition to ofrecer_promos -> immediately start level 3.

### 5. Levels 3-4 Order Creation

Levels 3 and 4 involve creating an order. In sandbox, this should:
- If CRM agents are enabled: route through CRM orchestrator (existing pattern from sandbox-engine.ts lines 291-336)
- If CRM agents are NOT enabled: show placeholder `[SANDBOX: Order would be created here]`
- In both cases: inject the timer message into chat

### 6. IngestTab Toggle Location

CONTEXT.md says: "El toggle ON/OFF del timer vive en el tab de Ingest del debug panel (no en el header)."

The toggle enables/disables the timer simulation. When disabled, data collection still works (IngestManager classifies and extracts) but no timer actions fire.

### 7. Preset Change While Timer Active

CONTEXT.md says: "Cambiar preset con timer activo: reinicia el timer con nuevos tiempos."

When preset changes: stop current timer, recalculate duration for current level using new preset values, restart timer with full new duration.

### 8. Data Flow Diagram

```
User types message
       |
       v
sandbox-layout.tsx sends to /api/sandbox/process
       |
       v
sandbox-engine.ts processes via IngestManager
       |
       v
Returns SandboxEngineResult with:
  - messages (agent responses)
  - newState (updated fields, mode, ingestStatus)
  - timerSignal (start/reevaluate/cancel)
       |
       v
sandbox-layout.tsx receives result
  - Updates state, messages, debug turns
  - If timerSignal.type === 'start': simulator.start(level, durationMs)
  - If timerSignal.type === 'reevaluate': simulator.reevaluateLevel(context)
  - If timerSignal.type === 'cancel': simulator.stop()
       |
       v
IngestTimerSimulator runs countdown via setInterval
  - Every 1000ms: onTick(remainingMs, level) -> updates timerState in layout
  - timerState flows to IngestTab via props
       |
       v
Timer expires:
  - onExpire(level, action) fires
  - sandbox-layout injects message into chat
  - Updates state.currentMode if needed
  - If level 2: chains to level 3 immediately
```

## Open Questions

1. **Level 2 -> Level 3 chaining:** When level 2 fires (silent transition to ofrecer_promos), should level 3 start immediately with its full 10-minute duration, or should there be a brief pause? The CONTEXT.md implies immediate chaining since level 2 is "silent transition."
   - What we know: Level 2 transitions to ofrecer_promos, level 3 checks if mode is ofrecer_promos and no pack selected.
   - Recommendation: Immediately chain - after level 2 fires, evaluate levels again which will match level 3, start its timer.

2. **Timer toggle persistence:** Should the timer ON/OFF state persist across session resets?
   - What we know: Session reset (`handleReset`) resets all state to INITIAL_STATE.
   - Recommendation: Timer toggle should reset to OFF on new session (matches "clean slate" philosophy of reset). Timer config (preset + slider values) could persist via localStorage (low priority).

3. **Order creation from timer (levels 3-4):** Should timer-triggered orders go through the CRM orchestrator or be simulated differently?
   - What we know: Existing sandbox order creation (on compra_confirmada) already routes through CRM orchestrator when enabled.
   - Recommendation: Reuse the same CRM orchestrator pattern. This requires the timer action handler in sandbox-layout to have access to crmModes state, which it already does.

4. **"apellido" in minimum fields:** CONTEXT.md Phase 15.7 says 6 minimum fields include apellido. But existing CRITICAL_FIELDS (5 fields) doesn't include apellido, and `hasMinimumData()` checks count >= 5 of CRITICAL_FIELDS.
   - What we know: The timer level evaluation is separate from the existing field validation functions.
   - Recommendation: Define `TIMER_MINIMUM_FIELDS` (6 fields including apellido) separately from `CRITICAL_FIELDS` (5 fields). The timer uses its own field list; existing functions remain unchanged.

## Sources

### Primary (HIGH confidence)
- Codebase: `src/lib/sandbox/sandbox-engine.ts` - Full analysis of timer signal handling (or lack thereof)
- Codebase: `src/lib/agents/somnio/ingest-manager.ts` - IngestManager shouldEmitTimerStart logic
- Codebase: `src/app/(dashboard)/sandbox/components/debug-panel/ingest-tab.tsx` - Existing timer UI
- Codebase: `src/lib/sandbox/types.ts` - IngestStatus type with timerExpiresAt
- Codebase: `src/app/(dashboard)/sandbox/components/sandbox-layout.tsx` - State management patterns
- Codebase: `src/inngest/functions/agent-timers.ts` - Production timer patterns (reference only)
- Codebase: `src/lib/agents/somnio/data-extractor.ts` - CRITICAL_FIELDS, hasMinimumData, hasCriticalData

### Secondary (MEDIUM confidence)
- CONTEXT.md: Phase 15.7 decisions - 5 timer levels, presets, sliders, messages
- STATE.md: Prior decisions from phases 15.5, 15.6

### Tertiary (LOW confidence)
- None. All findings verified directly from codebase.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new libraries needed, all from existing codebase
- Architecture: HIGH - Patterns directly derived from existing sandbox architecture
- Pitfalls: HIGH - Identified from concrete code analysis (null timerExpiresAt, unconnected onTimerChange, field count mismatch)
- Code examples: HIGH - Modeled directly from existing code patterns

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (stable - internal codebase patterns don't change externally)
