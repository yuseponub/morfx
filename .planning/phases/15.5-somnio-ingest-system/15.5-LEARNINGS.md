# Phase 15.5: Somnio Ingest System - Learnings

**Fecha:** 2026-02-07
**Duraci√≥n:** 19 minutos (4min plan 01 + 7min plan 02 + 8min plan 03)
**Plans ejecutados:** 3 de 4 (plan 04 pendiente - verificaci√≥n)

---

## Bugs Encontrados

| Bug | Causa | Fix | Prevenci√≥n |
|-----|-------|-----|------------|
| Model ID incorrecto en MessageClassifier | Se uso `claude-sonnet-4-5-20250514` en lugar de `claude-sonnet-4-20250514` (falta el segundo guion) | Commit `9c79492`: Corregir a `claude-sonnet-4-20250514` en message-classifier.ts | Verificar model IDs contra documentaci√≥n oficial de Anthropic; crear constantes reutilizables para model IDs |
| SandboxEngine perd√≠a ingestStatus al construir newState | Al hacer spread de `newState`, no se preservaba `ingestStatus` del estado anterior | Commit `cbc6954`: Agregar `ingestStatus: currentState.ingestStatus` al construir newState | Siempre preservar campos de estado opcionales al hacer spread; considerar helper function para state merging |
| ingestStatus no se inicializaba en transici√≥n a collecting_data | Al entrar a collecting_data, ingestStatus quedaba undefined | Commit `74df919`: Inicializar ingestStatus con valores por defecto en transici√≥n de modo | Inicializar todos los campos de estado en las transiciones de modo; agregar validaci√≥n de estado completo |
| No se enviaban templates de ofrecer_promos cuando ingest completaba | Cuando se alcanzaban 8 campos, faltaba la l√≥gica para enviar las 2 templates antes de ofrecer_promos | Commit `736f1a1`: Agregar dispatch de templates en completion de ingest | Verificar que todas las transiciones de modo incluyan sus templates correspondientes; revisar CONTEXT.md para requisitos de templates |
| S√≠ impl√≠cito con 8 campos completos no manejado correctamente | Si cliente enviaba todos los 8 campos de una vez, no se saltaba directo a ofrecer_promos como especificaba CONTEXT.md | Commit `1947e97`: Detectar cuando implicit yes incluye 8 campos y saltar directo a ofrecer_promos | Leer cuidadosamente todos los edge cases en CONTEXT.md; crear tests para flujos completos vs parciales |

## Decisiones T√©cnicas

| Decisi√≥n | Alternativas Descartadas | Raz√≥n |
|----------|-------------------------|-------|
| Claude Haiku con fallback a Sonnet | Usar solo Sonnet; usar regex patterns | Haiku es m√°s r√°pido y barato para clasificaci√≥n simple; regex no puede manejar "mixto" o lenguaje natural complejo |
| 4 categor√≠as de clasificaci√≥n (datos, pregunta, mixto, irrelevante) | 2 categor√≠as (datos/no-datos); 3 categor√≠as sin "irrelevante" | "mixto" es cr√≠tico para "hola+datos"; "irrelevante" evita que "ok gracias" reinicie timer |
| Structured outputs con Zod schema | JSON en prompt con try/catch | Structured outputs garantiza JSON v√°lido sin retries; menos propenso a errores de parsing |
| Timer empieza en PRIMER dato, NO se reinicia | Timer se reinicia con cada mensaje; timer empieza al entrar collecting_data | Evita que cliente pueda extender indefinidamente el timer enviando datos gota a gota |
| Dual timeout: 6min parcial / 10min sin datos | Timeout √∫nico de 8min | Diferente urgencia: sin datos = dar m√°s tiempo; con datos parciales = empujar a completar |
| AllAgentEvents type combinando base + ingest | Modificar AgentEvents directamente | Permite separaci√≥n de concerns; ingest events son espec√≠ficos de esta fase |
| IngestResult con action discriminant | Boolean flags (silent, respond) | Discriminated union es type-safe y hace imposibles estados inv√°lidos |
| Silent accumulation (response=undefined) | Empty string; success=false | undefined es sem√°nticamente correcto para "no hay respuesta" vs "" que es respuesta vac√≠a |
| Hola+datos clasificado como mixto | Clasificar como datos puro | Per Pitfall 5: garantiza que se responda el saludo antes de entrar a collecting_data |

## Problemas de Integraci√≥n

| Componente A | Componente B | Problema | Soluci√≥n |
|--------------|--------------|----------|----------|
| IngestManager | Inngest client | TypeScript errores al usar nuevos ingest events - no estaban en AgentEvents type | Crear AllAgentEvents type combinando AgentEvents + IngestEvents; actualizar Inngest client para usar AllAgentEvents |
| MessageClassifier | Claude API | Model ID con typo causaba fallback inmediato a Sonnet | Corregir model ID a `claude-sonnet-4-20250514`; agregar logging para detectar fallbacks inesperados |
| SandboxEngine | IngestStatus | Estado se perd√≠a al construir newState con spread operator | Preservar expl√≠citamente ingestStatus del currentState al hacer merge |
| SomnioEngine | IngestManager | S√≠ impl√≠cito con 8 campos no saltaba directo a ofrecer_promos | Agregar l√≥gica para detectar completion en implicit yes y saltar collecting_data |
| IngestManager | Template dispatcher | Templates de ofrecer_promos no se enviaban al completar ingest | Dispatch templates antes de transition a ofrecer_promos cuando ingest completa |

## Tips para Futuros Agentes

### Lo que funcion√≥ bien
- Separar concerns: MessageClassifier solo clasifica, DataExtractor solo extrae
- Haiku-first pattern: intentar modelo r√°pido primero, fallback a Sonnet autom√°tico
- Structured outputs elimin√≥ completamente errores de JSON parsing
- IngestResult con discriminated union hizo el flujo type-safe
- Signals (shouldEmitTimerStart, shouldEmitTimerComplete) para control fino de timer lifecycle
- Dynamic import de inngest client para evitar circular dependencies
- Preservar toda la l√≥gica de ingest en IngestManager, mantener SomnioEngine como router
- Tracking completo de ingest state (firstDataAt, fieldsAccumulated) permiti√≥ timeouts condicionales

### Lo que NO hacer
- NO usar el model ID sin verificar contra docs (typo en model ID caus√≥ bug cr√≠tico)
- NO asumir que spread operator preserva campos opcionales - verificar expl√≠citamente
- NO olvidar inicializar campos de estado en transiciones de modo
- NO saltarse edge cases del CONTEXT.md (ej: s√≠ impl√≠cito con 8 campos completos)
- NO responder a mensajes clasificados como "datos" - la clave es SILENCIO durante accumulation
- NO reiniciar timer con cada mensaje - solo empieza con PRIMER dato
- NO usar timeout √∫nico - debe ser condicional basado en hasPartialData
- NO clasificar "hola+datos" como solo "datos" - debe ser "mixto" para responder saludo

### Patrones a seguir
- **Haiku-first with Sonnet fallback:** Try fast model, catch error, fallback to capable model
- **Structured outputs pattern:** Define Zod schema, use `zodOutputFormat`, guaranteed valid JSON
- **Silent accumulation pattern:** `action='silent'` + `response=undefined` para no enviar mensaje
- **Timer signal pattern:** `shouldEmitTimerStart`, `shouldEmitTimerComplete` para control de lifecycle
- **IngestState tracking:** Siempre trackear `firstDataAt` para determinar tipo de timeout
- **Discriminated unions:** `action: 'silent' | 'respond' | 'complete'` previene estados inv√°lidos
- **Dynamic imports:** Usar cuando hay riesgo de circular dependencies (ej: inngest client)
- **State preservation:** Al hacer spread de newState, preservar campos opcionales del estado anterior

### Comandos √∫tiles
```bash
# Verificar model IDs disponibles
grep -r "claude-" src/lib/agents/

# Ver estado de ingest en logs
grep "clasificacion:" logs/inngest.log

# Verificar que timer events est√©n registrados
grep "agent/ingest" src/inngest/events.ts

# Ver todos los commits de esta fase
git log --oneline --all | grep "15.5"

# Verificar structured outputs en MessageClassifier
grep "zodOutputFormat" src/lib/agents/somnio/message-classifier.ts
```

## Deuda T√©cnica Identificada

| Item | Prioridad | Fase sugerida |
|------|-----------|---------------|
| Plan 04 pendiente - Verificaci√≥n end-to-end del ingest system en sandbox | Alta | Completar en 15.5-04 antes de cerrar fase |
| Tests unitarios para MessageClassifier (datos/pregunta/mixto/irrelevante) | Media | 15.6 o fase de testing dedicada |
| Tests de integraci√≥n para IngestManager con timer lifecycle | Media | 15.6 o fase de testing dedicada |
| Constantes compartidas para model IDs (evitar typos) | Baja | 16 - refactor general de agents |
| Helper function para state merging (evitar bugs de preservation) | Baja | 16 - refactor general de state management |
| Logging estructurado para classification results (debugging) | Baja | Post-MVP - observability phase |
| Metrics tracking: latency de Haiku vs Sonnet, fallback rate | Baja | Post-MVP - observability phase |

## Notas para el M√≥dulo

Informaci√≥n espec√≠fica que un agente de documentaci√≥n de este m√≥dulo necesitar√≠a saber:

### Arquitectura del Sistema de Ingest

El sistema consta de 3 componentes principales que trabajan juntos:

1. **MessageClassifier** (`src/lib/agents/somnio/message-classifier.ts`)
   - Usa Claude Haiku para clasificaci√≥n r√°pida en 4 categor√≠as
   - Fallback autom√°tico a Sonnet si Haiku falla
   - Structured outputs garantiza JSON v√°lido
   - Exporta: `MessageClassifier`, `MessageClassification`, `ClassificationResult`

2. **IngestManager** (`src/lib/agents/somnio/ingest-manager.ts`)
   - Coordina MessageClassifier + DataExtractor
   - Implementa silent accumulation pattern
   - Emite timer signals: `shouldEmitTimerStart`, `shouldEmitTimerComplete`
   - Retorna `IngestResult` con discriminated union
   - Exporta: `IngestManager`, `IngestResult`, `IngestState`

3. **SomnioEngine Integration** (`src/lib/agents/somnio/somnio-engine.ts`)
   - Router principal: detecta collecting_data mode y rutea a IngestManager
   - Maneja implicit yes: datos fuera de collecting_data ‚Üí transici√≥n autom√°tica
   - Emite eventos Inngest: `agent/ingest.started`, `agent/ingest.completed`
   - Retorna `response: undefined` para silent accumulation

### Flujo de Datos

```
User Message
    ‚Üì
SomnioEngine.processMessage()
    ‚Üì
¬øcollecting_data mode? ‚Üí NO ‚Üí detectar implicit yes ‚Üí datos found? ‚Üí YES ‚Üí transition + extract
    ‚Üì YES                                                   ‚Üì NO
IngestManager.processMessage()                         normal flow
    ‚Üì
MessageClassifier.classify() [Haiku ‚Üí Sonnet fallback]
    ‚Üì
datos ‚Üí extract + silent (no response)
pregunta ‚Üí respond via orchestrator
mixto ‚Üí extract + respond
irrelevante ‚Üí silent (ignore)
    ‚Üì
8 fields complete? ‚Üí YES ‚Üí emit ingest.completed + ofrecer_promos templates
    ‚Üì NO
silent accumulation contin√∫a
```

### Timer Lifecycle

```
FIRST datos message
    ‚Üì
emit agent/ingest.started { timerDurationMs: 6min or 10min }
    ‚Üì
Inngest ingestTimer.waitForEvent(
    event: 'agent/ingest.completed',
    timeout: timerDurationMs
)
    ‚Üì
completion event? ‚Üí YES ‚Üí timer cancelled
    ‚Üì NO (timeout)
buildTimeoutMessage(datosCapturados, timerType)
    ‚Üì
send timeout message to customer
```

### Eventos Inngest

Definidos en `src/inngest/events.ts`:

- `agent/ingest.started` - Emitido en PRIMER dato (inicia timer)
- `agent/ingest.data_received` - (definido pero no usado actualmente)
- `agent/ingest.completed` - Emitido cuando se alcanzan 8 campos (cancela timer)

### Clasificaciones y Comportamiento

| Clasificaci√≥n | Comportamiento | Ejemplo Mensaje |
|--------------|----------------|-----------------|
| `datos` | Extrae + silent (no response) | "Juan Perez", "Bogot√°", "Calle 123" |
| `pregunta` | Responde via orchestrator normal | "Cu√°nto cuesta?", "Hacen env√≠os?" |
| `mixto` | Extrae + responde | "Jose, de Medellin. Cu√°nto vale?" |
| `irrelevante` | Ignora silenciosamente | "ok", "gracias", "üëç", "perfecto" |

### Edge Cases Importantes

1. **S√≠ impl√≠cito con 8 campos completos:** Debe saltar directo a ofrecer_promos, no pasar por collecting_data
2. **Hola + datos:** Clasificado como "mixto" para garantizar respuesta al saludo
3. **Timer NO se reinicia:** Solo empieza con primer dato, adicionales no afectan
4. **Irrelevante NO afecta timer:** "ok gracias" no cuenta como actividad

### Configuraci√≥n de Modelos

- **Haiku:** `claude-haiku-4-5-20251101` (r√°pido, barato, clasificaci√≥n)
- **Sonnet:** `claude-sonnet-4-20250514` (fallback, m√°s capaz)
- **IMPORTANTE:** El model ID de Sonnet tiene formato `claude-sonnet-4-YYYYMMDD` (NO `claude-sonnet-4-5-YYYYMMDD`)

### Sandbox Integration

El SandboxEngine trackea ingest status en `SandboxState.ingestStatus`:

```typescript
ingestStatus?: {
  active: boolean;
  startedAt: string | null;
  firstDataAt: string | null;
  fieldsAccumulated: string[];
  timerType: 'partial' | 'no_data' | null;
  lastClassification: MessageClassification | null;
}
```

Debug output format: `[SANDBOX: Silent - clasificacion: datos, confidence: 85%]`

---
*Generado al completar la fase. Input para entrenamiento de agentes de documentaci√≥n.*
