---
phase: 19-ai-automation-builder
plan: 04
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/lib/builder/diagram-generator.ts
  - src/lib/builder/validation.ts
autonomous: true

must_haves:
  truths:
    - "Automation form data converts to React Flow nodes and edges with proper layout"
    - "Custom node types exist for trigger, condition, and action"
    - "Invalid resources produce error markers on diagram nodes"
    - "Cycle detection identifies and blocks circular automation references"
  artifacts:
    - path: "src/lib/builder/diagram-generator.ts"
      provides: "automationToDiagram function converting AutomationFormData to DiagramData"
      exports: ["automationToDiagram", "getTriggerLabel", "getActionLabel"]
      min_lines: 100
    - path: "src/lib/builder/validation.ts"
      provides: "Resource validation and cycle detection functions"
      exports: ["validateResources", "detectCycles", "findDuplicateAutomations"]
      min_lines: 80
  key_links:
    - from: "src/lib/builder/diagram-generator.ts"
      to: "src/lib/automations/constants.ts"
      via: "TRIGGER_CATALOG and ACTION_CATALOG for labels"
      pattern: "TRIGGER_CATALOG|ACTION_CATALOG"
    - from: "src/lib/builder/validation.ts"
      to: "src/lib/supabase/admin.ts"
      via: "DB queries for resource validation"
      pattern: "createAdminClient"
---

<objective>
Create the diagram generator that converts automation form data into React Flow nodes/edges, and the validation module that checks resource existence, detects cycles, and identifies duplicates.

Purpose: Core logic for visual preview generation and safety validation. Used by the generatePreview tool.
Output: Diagram generator and validation modules.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/automations/types.ts
@src/lib/automations/constants.ts
@src/lib/builder/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create diagram generator</name>
  <files>src/lib/builder/diagram-generator.ts</files>
  <action>
    Create `src/lib/builder/diagram-generator.ts` that converts automation data into React Flow diagram data.

    1. **Helper functions**:

    `getTriggerLabel(triggerType: string)`: Look up the Spanish label from TRIGGER_CATALOG. Fall back to the raw type string if not found.

    `getActionLabel(actionType: string)`: Look up the Spanish label from ACTION_CATALOG. Fall back to the raw type string.

    `getTriggerCategory(triggerType: string)`: Get category (CRM, WhatsApp, Tareas) from TRIGGER_CATALOG.

    `getActionCategory(actionType: string)`: Get category from ACTION_CATALOG.

    2. **Main function `automationToDiagram`**:

    Signature:
    ```typescript
    export function automationToDiagram(
      automation: {
        name: string
        trigger_type: string
        trigger_config: Record<string, unknown>
        conditions?: ConditionGroup | null
        actions: AutomationAction[]
      },
      validationResults: ResourceValidation[]
    ): DiagramData
    ```

    Layout logic (vertical top-to-bottom):
    - Center X position: 250
    - Y spacing: 120px between nodes
    - Starting Y: 0

    Node creation:

    a) **Trigger node** (always first, id='trigger'):
       - type: 'triggerNode'
       - position: { x: 250, y: 0 }
       - data: { label: getTriggerLabel(trigger_type), triggerType: trigger_type, config: trigger_config, category: getTriggerCategory(trigger_type), hasError: check if any validation for nodeId='trigger', errorMessage: first error for trigger if any }

    b) **Condition node** (if conditions not null, id='conditions'):
       - type: 'conditionNode'
       - position: { x: 250, y: yOffset }
       - data: { label: 'Condiciones', conditions, conditionCount: count leaf conditions }
       - Edge from previous node to this

    c) **Action nodes** (one per action, id=`action-${index}`):
       - type: 'actionNode'
       - position: { x: 250, y: yOffset }
       - data: { label: getActionLabel(action.type), actionType: action.type, params: action.params, delay: action.delay, category: getActionCategory(action.type), hasError: check validations for this nodeId, errorMessage: first error }
       - Edge from previous node to this
       - Increment yOffset by 120 for each

    Edge creation:
    - Simple sequential: each node connects to the next
    - Edge id: `${source}-${target}`
    - animated: true for all edges (shows flow direction)

    Validation errors:
    - Collect from validationResults: filter for items with valid=false
    - Map to { nodeId, message } format for the validationErrors array

    Return `{ nodes, edges, validationErrors }` matching DiagramData type.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports automationToDiagram, getTriggerLabel, getActionLabel
    - Given a simple automation (1 trigger, 1 action), produces 2 nodes and 1 edge
  </verify>
  <done>
    - Diagram generator converts any valid automation shape into React Flow nodes/edges
    - Nodes are vertically laid out with 120px spacing
    - Validation errors marked on individual nodes
    - Labels come from TRIGGER_CATALOG and ACTION_CATALOG
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation module</name>
  <files>src/lib/builder/validation.ts</files>
  <action>
    Create `src/lib/builder/validation.ts` with three exported functions:

    1. **`validateResources(workspaceId: string, automation: AutomationFormData): Promise<ResourceValidation[]>`**

    Uses `createAdminClient()` to check each referenced resource exists:

    - **Pipelines/Stages**: Check trigger_config.pipelineId, trigger_config.stageId, and action params that reference pipelineId/stageId/targetPipelineId/targetStageId. Query `pipelines` and `pipeline_stages` tables filtered by workspace_id.

    - **Tags**: Check action params.tagName for assign_tag/remove_tag actions. Query `tags` table filtered by workspace_id, match by name (case-insensitive).

    - **Templates**: Check action params.templateName for send_whatsapp_template actions. Query `whatsapp_templates` table filtered by workspace_id. Also check the `status` field â€” if not 'APPROVED', add a warning.

    - **Users**: Check action params.assignToUserId for create_task actions. Query `workspace_members` filtered by workspace_id.

    For each resource, return a `ResourceValidation` object:
    ```typescript
    { type: 'pipeline'|'stage'|'tag'|'template'|'user', name: string, found: boolean, id: string|null, details: string|null }
    ```

    If `found=false`, include helpful details like "No se encontro el tag 'VIP' en el workspace" or "El template 'promo_1' no esta aprobado por Meta (status: PENDING)".

    2. **`detectCycles(workspaceId: string, newAutomation: AutomationFormData): Promise<{hasCycles: boolean, cyclePath: string[]}>`**

    Strategy:
    - Load all existing enabled automations for the workspace
    - Build a directed graph: for each automation, the trigger_type is the "input" and each action's type is the "output"
    - Map which action types can trigger which trigger types:
      - `change_stage` -> `order.stage_changed`
      - `assign_tag` -> `tag.assigned`
      - `remove_tag` -> `tag.removed`
      - `create_order` -> `order.created`
      - `duplicate_order` -> `order.created`
      - `create_task` -> `task.completed` (indirect, but not immediate)
      - Other actions don't create triggers
    - Add the new automation to the graph
    - Run DFS from the new automation's trigger_type to see if we can reach it again
    - If a cycle is found, return the path (automation names)

    This is a simplified cycle detection. The graph is small (<50 automations max per workspace), so DFS is fast enough.

    3. **`findDuplicateAutomations(workspaceId: string, automation: AutomationFormData, excludeId?: string): Promise<{isDuplicate: boolean, existing: {id: string, name: string}[]}>`**

    Query existing automations with the same trigger_type. Compare trigger_config fields for meaningful overlap:
    - For order triggers: same pipelineId + stageId
    - For tag triggers: same tagId
    - For keyword_match: overlapping keywords
    - For others: same trigger_type alone is enough to warn

    If `excludeId` is provided (for updates), exclude that automation from the comparison.

    Return the list of potentially conflicting automations so the agent can warn the user.

    All three functions handle DB errors gracefully (return empty/safe defaults, log errors).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exports validateResources, detectCycles, findDuplicateAutomations
    - All DB queries use createAdminClient with workspace_id filter
  </verify>
  <done>
    - Resource validation checks pipelines, stages, tags, templates, and users
    - Template validation checks both existence AND Meta approval status
    - Cycle detection builds directed graph and runs DFS
    - Duplicate detection compares trigger_type + trigger_config overlap
  </done>
</task>

</tasks>

<verification>
- Both files exist and export their functions
- TypeScript compiles: `npx tsc --noEmit`
- Diagram generator uses TRIGGER_CATALOG/ACTION_CATALOG for labels
- Validation module queries DB with workspace isolation
</verification>

<success_criteria>
Diagram generator produces correct React Flow node/edge data for any automation shape. Validation module checks all resource types, detects cycles, and finds duplicates. Both modules are pure server-side code with no React dependencies.
</success_criteria>

<output>
After completion, create `.planning/phases/19-ai-automation-builder/19-04-SUMMARY.md`
</output>
