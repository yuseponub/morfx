# Phase 10.1: Task Notes & History - Research

**Researched:** 2026-02-04
**Domain:** Task notes system, change history tracking, postponement detection
**Confidence:** HIGH

## Summary

This phase extends the existing task system (Phase 10) with two capabilities: user-added notes and automatic change history tracking. The project already has proven patterns for both features in the contact system (`contact_notes` table for notes, `contact_activity` table with PostgreSQL trigger for history). The primary challenge is adapting these patterns for tasks while adding postponement detection - identifying when a task's due date has been changed multiple times.

The contact system provides a direct blueprint: notes are stored in a dedicated table with author tracking, and activity is logged via a trigger function that captures JSONB diffs of changed fields. For postponement detection, we need to track specifically when `due_date` changes and count these occurrences per task.

**Primary recommendation:** Follow the existing contact_notes/contact_activity pattern exactly, adapting for tasks. Add a `postponement_count` denormalized field on tasks for efficient querying, updated by the activity trigger when due_date changes.

## Standard Stack

### Core (Already Implemented in Project)

| Component | Source | Purpose | Why Standard |
|-----------|--------|---------|--------------|
| PostgreSQL triggers | `20260129000002_custom_fields_notes_activity.sql` | Automatic change logging | Already proven pattern in contacts |
| JSONB diff tracking | `log_contact_changes()` function | Store old/new values for each changed field | Enables detailed history view |
| Separate notes table | `contact_notes` | Store notes with author tracking | Clear separation, simple RLS |
| Timeline UI | `src/components/ui/timeline.tsx` | Display activity chronologically | Already built and tested |
| Server actions | `src/app/actions/notes.ts`, `activity.ts` | CRUD for notes, fetch activity | Consistent project pattern |

### Supporting (Existing Project Dependencies)

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| date-fns | ^4.1.0 | Relative date formatting | Timeline display ("hace 2 horas") |
| lucide-react | ^0.563.0 | Activity icons | Different icons per action type |
| sonner | (installed) | Toast notifications | Note CRUD feedback |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Trigger-based history | Application-level logging | Trigger guarantees all changes captured, even direct DB edits |
| JSONB for changes | Separate columns per change type | JSONB more flexible, same pattern as contacts |
| Denormalized postponement_count | Count via query | Query performance vs slight denormalization |

**Installation:**
```bash
# No new packages needed - all patterns exist in codebase
```

## Architecture Patterns

### Recommended Database Structure

```
supabase/migrations/
└── 2026020XNNNNNN_task_notes_history.sql
    ├── task_notes table (follows contact_notes pattern)
    ├── task_activity table (follows contact_activity pattern)
    ├── log_task_changes() trigger function
    └── task_notes RLS policies

src/
├── lib/tasks/
│   └── types.ts          # Extend with TaskNote, TaskActivity types
├── app/actions/
│   ├── task-notes.ts     # CRUD for task notes
│   └── task-activity.ts  # Fetch task history
└── components/tasks/
    ├── task-notes.tsx        # Notes section component
    ├── task-history.tsx      # Activity timeline component
    └── postponement-badge.tsx # Visual indicator
```

### Pattern 1: Task Notes Table (Mirror contact_notes)

**What:** Dedicated table for task notes with author tracking and workspace isolation.
**When to use:** All note storage for tasks.
**Example:**
```sql
-- Source: Existing contact_notes pattern in project
CREATE TABLE task_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT timezone('America/Bogota', NOW()),
  updated_at TIMESTAMPTZ DEFAULT timezone('America/Bogota', NOW())
);

CREATE INDEX idx_task_notes_task ON task_notes(task_id);
CREATE INDEX idx_task_notes_workspace ON task_notes(workspace_id);
CREATE INDEX idx_task_notes_created ON task_notes(created_at DESC);
```

### Pattern 2: Task Activity Table with JSONB Diff

**What:** Immutable activity log capturing all task changes with field-level diffs.
**When to use:** Any task modification (via trigger) or explicit actions (via app code).
**Example:**
```sql
-- Source: Existing contact_activity pattern in project
CREATE TABLE task_activity (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  action TEXT NOT NULL,  -- 'created', 'updated', 'completed', 'reopened', 'due_date_changed', 'note_added', etc.
  changes JSONB,         -- {"due_date": {"old": "2026-02-01", "new": "2026-02-08"}}
  metadata JSONB,        -- Additional context like note preview
  created_at TIMESTAMPTZ DEFAULT timezone('America/Bogota', NOW())
);

-- Specific index for postponement queries
CREATE INDEX idx_task_activity_due_date ON task_activity(task_id, action)
  WHERE action = 'due_date_changed';
```

### Pattern 3: Trigger Function with Postponement Detection

**What:** PostgreSQL trigger that logs changes AND detects/tracks due date changes.
**When to use:** Automatically on INSERT/UPDATE/DELETE of tasks.
**Example:**
```sql
-- Source: Extended from log_contact_changes() in project
CREATE OR REPLACE FUNCTION log_task_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  changes_json JSONB := '{}';
  old_json JSONB;
  new_json JSONB;
  key TEXT;
  user_uuid UUID;
  action_type TEXT;
BEGIN
  -- Get current user from JWT
  BEGIN
    user_uuid := (auth.jwt() ->> 'sub')::UUID;
  EXCEPTION WHEN OTHERS THEN
    user_uuid := NULL;
  END;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO task_activity (task_id, workspace_id, user_id, action, changes)
    VALUES (NEW.id, NEW.workspace_id, user_uuid, 'created', to_jsonb(NEW));
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    old_json := to_jsonb(OLD);
    new_json := to_jsonb(NEW);

    -- Build diff of changed fields
    FOR key IN SELECT jsonb_object_keys(new_json)
    LOOP
      IF key NOT IN ('updated_at') AND old_json -> key IS DISTINCT FROM new_json -> key THEN
        changes_json := changes_json || jsonb_build_object(
          key, jsonb_build_object('old', old_json -> key, 'new', new_json -> key)
        );
      END IF;
    END LOOP;

    -- Determine action type
    IF changes_json ? 'due_date' THEN
      action_type := 'due_date_changed';
      -- Increment postponement counter on task if due_date moved forward
      IF (NEW.due_date IS NOT NULL AND OLD.due_date IS NOT NULL
          AND NEW.due_date > OLD.due_date) THEN
        NEW.postponement_count := COALESCE(OLD.postponement_count, 0) + 1;
      END IF;
    ELSIF changes_json ? 'status' THEN
      IF NEW.status = 'completed' THEN
        action_type := 'completed';
      ELSE
        action_type := 'reopened';
      END IF;
    ELSE
      action_type := 'updated';
    END IF;

    IF changes_json != '{}' THEN
      INSERT INTO task_activity (task_id, workspace_id, user_id, action, changes)
      VALUES (NEW.id, NEW.workspace_id, user_uuid, action_type, changes_json);
    END IF;
    RETURN NEW;
  END IF;

  IF TG_OP = 'DELETE' THEN
    INSERT INTO task_activity (task_id, workspace_id, user_id, action, changes)
    VALUES (OLD.id, OLD.workspace_id, user_uuid, 'deleted', to_jsonb(OLD));
    RETURN OLD;
  END IF;
END;
$$;
```

### Pattern 4: Postponement Visual Indicator

**What:** Badge component showing postponement count with color severity.
**When to use:** Task list items, task detail view.
**Example:**
```typescript
// Source: Project conventions
interface PostponementBadgeProps {
  count: number
}

function PostponementBadge({ count }: PostponementBadgeProps) {
  if (count === 0) return null

  // Severity: 1-2 = yellow warning, 3+ = red critical
  const severity = count >= 3 ? 'critical' : 'warning'

  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <Badge
          variant="outline"
          className={cn(
            "text-xs gap-1",
            severity === 'critical'
              ? "bg-red-100 text-red-700 border-red-300 dark:bg-red-900/30 dark:text-red-400"
              : "bg-yellow-100 text-yellow-700 border-yellow-300 dark:bg-yellow-900/30 dark:text-yellow-400"
          )}
        >
          <ClockIcon className="h-3 w-3" />
          Postergada {count}x
        </Badge>
      </TooltipTrigger>
      <TooltipContent>
        Esta tarea ha sido postergada {count} {count === 1 ? 'vez' : 'veces'}
      </TooltipContent>
    </Tooltip>
  )
}
```

### Anti-Patterns to Avoid

- **Storing notes in JSONB on tasks table:** Don't embed notes as array - loses RLS control, harder to query
- **Counting postponements via query every time:** Use denormalized counter for performance
- **Multiple triggers for different change types:** Single trigger handles all cases efficiently
- **Mutable activity log:** Activity records should NEVER be updateable - immutable audit trail
- **Detecting postponement only by count:** Track direction (due_date moved later, not earlier)

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Change diff calculation | Custom field comparison | PostgreSQL `to_jsonb()` + key iteration | Handles all types, nulls, JSONB consistently |
| Relative date formatting | Custom date math | `formatRelativeDate()` from timeline.tsx | Already handles es-CO locale, edge cases |
| User profile lookup | Manual joins | Pattern from notes.ts (fetch profiles separately) | Avoids N+1, handles missing profiles |
| Activity type icons | Hardcoded switch | Icon map constant | Easier to maintain, extend |

**Key insight:** The project already solved notes + activity for contacts. The implementation should be a direct port with task-specific additions (postponement tracking).

## Common Pitfalls

### Pitfall 1: Trigger Not Capturing User ID

**What goes wrong:** Activity records show null user_id even when user is authenticated.
**Why it happens:** `auth.jwt()` not available in trigger context or exception not handled.
**How to avoid:** Use try/catch in trigger (already in contact trigger). For SECURITY DEFINER functions, JWT is available if RLS is enabled on target table.
**Warning signs:** All activity.user_id values are null.

### Pitfall 2: Postponement Count Double-Increment

**What goes wrong:** Counter increments multiple times for single due_date change.
**Why it happens:** Multiple triggers firing (BEFORE + AFTER) or recursive updates.
**How to avoid:** Use single BEFORE UPDATE trigger that modifies NEW.postponement_count. Ensure trigger only fires once per statement.
**Warning signs:** Count jumps by 2+ for single reschedule action.

### Pitfall 3: Notes Not Appearing After Create

**What goes wrong:** User creates note, but it doesn't show in list immediately.
**Why it happens:** Missing `revalidatePath()` or wrong path.
**How to avoid:** Follow notes.ts pattern - call `revalidatePath('/tareas')` after mutations.
**Warning signs:** Need to refresh page to see new notes.

### Pitfall 4: Activity Log Performance

**What goes wrong:** Task detail page slow to load with many activity records.
**Why it happens:** Loading entire history without pagination.
**How to avoid:** Default limit (50) with "Load more" pattern, same as contact activity.
**Warning signs:** Query time increases linearly with task age.

### Pitfall 5: Postponement Not Counting Date Cleared Then Set

**What goes wrong:** Setting due_date from null doesn't count as postponement.
**Why it happens:** Only checking NEW.due_date > OLD.due_date, but null comparison fails.
**How to avoid:** Handle null cases explicitly - only count when BOTH old and new are non-null AND new > old.
**Warning signs:** Tasks with previously null dates show 0 postponements despite multiple reschedules.

## Code Examples

### Task Note Types (Extend types.ts)

```typescript
// Source: Adapted from src/lib/custom-fields/types.ts

/**
 * Note attached to a task.
 * All workspace members can see notes; author (or admin/owner) can edit/delete.
 */
export interface TaskNote {
  id: string
  task_id: string
  workspace_id: string
  user_id: string
  content: string
  created_at: string
  updated_at: string
}

/**
 * Note with user profile info for display.
 */
export interface TaskNoteWithUser extends TaskNote {
  user: {
    id: string
    email: string
  }
}

/**
 * Task activity action types.
 */
export type TaskActivityAction =
  | 'created'
  | 'updated'
  | 'completed'
  | 'reopened'
  | 'due_date_changed'
  | 'deleted'
  | 'note_added'
  | 'note_updated'
  | 'note_deleted'

/**
 * Activity log entry for a task.
 */
export interface TaskActivity {
  id: string
  task_id: string
  workspace_id: string
  user_id: string | null
  action: TaskActivityAction
  changes: Record<string, { old: unknown; new: unknown }> | null
  metadata: Record<string, unknown> | null
  created_at: string
}

/**
 * Activity with user profile info for display.
 */
export interface TaskActivityWithUser extends TaskActivity {
  user: {
    id: string
    email: string
  } | null
}
```

### Extend Task Type with Postponement Count

```typescript
// Add to existing Task interface in src/lib/tasks/types.ts
export interface Task {
  // ... existing fields ...

  /** Number of times due_date was pushed forward */
  postponement_count: number
}
```

### Task Notes Server Action Pattern

```typescript
// Source: Adapted from src/app/actions/notes.ts
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { cookies } from 'next/headers'
import type { TaskNoteWithUser } from '@/lib/tasks/types'

export async function createTaskNote(
  taskId: string,
  content: string
): Promise<{ success: true; data: TaskNoteWithUser } | { error: string }> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'No autenticado' }

  const trimmedContent = content.trim()
  if (!trimmedContent) return { error: 'El contenido es requerido' }

  const cookieStore = await cookies()
  const workspaceId = cookieStore.get('morfx_workspace')?.value
  if (!workspaceId) return { error: 'No hay workspace seleccionado' }

  // Insert note
  const { data: note, error } = await supabase
    .from('task_notes')
    .insert({
      task_id: taskId,
      workspace_id: workspaceId,
      user_id: user.id,
      content: trimmedContent,
    })
    .select()
    .single()

  if (error) return { error: 'Error al crear la nota' }

  // Log activity
  await supabase.from('task_activity').insert({
    task_id: taskId,
    workspace_id: workspaceId,
    user_id: user.id,
    action: 'note_added',
    metadata: { preview: trimmedContent.substring(0, 100) }
  })

  // Get user profile
  const { data: profile } = await supabase
    .from('profiles')
    .select('id, email')
    .eq('id', user.id)
    .single()

  revalidatePath('/tareas')

  return {
    success: true,
    data: {
      ...note,
      user: profile || { id: user.id, email: user.email || 'Usuario' }
    }
  }
}
```

### Activity Timeline Display

```typescript
// Source: Existing Timeline component + activity patterns
import { Timeline, TimelineItem, formatRelativeDate } from '@/components/ui/timeline'
import {
  PlusCircleIcon,
  PencilIcon,
  CheckCircleIcon,
  RotateCcwIcon,
  CalendarIcon,
  MessageSquareIcon,
  Trash2Icon
} from 'lucide-react'

const ACTION_ICONS: Record<string, typeof PlusCircleIcon> = {
  created: PlusCircleIcon,
  updated: PencilIcon,
  completed: CheckCircleIcon,
  reopened: RotateCcwIcon,
  due_date_changed: CalendarIcon,
  note_added: MessageSquareIcon,
  note_updated: PencilIcon,
  note_deleted: Trash2Icon,
}

const ACTION_LABELS: Record<string, string> = {
  created: 'Tarea creada',
  updated: 'Tarea actualizada',
  completed: 'Tarea completada',
  reopened: 'Tarea reabierta',
  due_date_changed: 'Fecha limite cambiada',
  note_added: 'Nota agregada',
  note_updated: 'Nota editada',
  note_deleted: 'Nota eliminada',
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Application-only logging | Database triggers | Always (for data integrity) | Captures all changes including direct DB edits |
| Flat text changes | JSONB diff per field | PostgreSQL 9.4+ | Enables field-level history queries |
| Count postponements on read | Denormalized counter | Performance optimization | O(1) instead of O(n) for display |
| Single "updated" action | Semantic action types | UX improvement | Better timeline readability |

**Deprecated/outdated:**
- Storing change history in application logs only (misses direct DB changes)
- Using separate columns for old/new values (JSONB is more flexible)

## Open Questions

1. **Postponement threshold for visual indicator**
   - What we know: User wants visual indicator when task postponed "multiple times"
   - What's unclear: What count triggers yellow vs red? 2? 3? Configurable?
   - Recommendation: Default to 1-2 = yellow warning, 3+ = red critical. Can make configurable later in settings.

2. **Should clearing due_date count as activity?**
   - What we know: Trigger will log it as due_date_changed
   - What's unclear: Should removing a due date show in timeline? Reset postponement count?
   - Recommendation: Log it (important for audit), don't reset count (task was still postponed).

3. **History retention policy**
   - What we know: Activity is immutable audit trail
   - What's unclear: Should old activity be purged? How long to keep?
   - Recommendation: Keep indefinitely for now (contacts do). Add retention policy later if storage becomes issue.

## Sources

### Primary (HIGH confidence)
- Existing project migration: `supabase/migrations/20260129000002_custom_fields_notes_activity.sql` - contact_notes, contact_activity patterns
- Existing project code: `src/app/actions/notes.ts` - CRUD pattern for notes
- Existing project code: `src/app/actions/activity.ts` - Activity fetch and formatting
- Existing project code: `src/components/ui/timeline.tsx` - Timeline UI component
- Existing project code: `src/lib/custom-fields/types.ts` - Type definitions for notes/activity

### Secondary (MEDIUM confidence)
- [PostgreSQL Wiki - Audit Trigger 91plus](https://wiki.postgresql.org/wiki/Audit_trigger_91plus) - Trigger function structure
- [PostgreSQL Audit Logging Best Practices](https://severalnines.com/blog/postgresql-audit-logging-best-practices/) - AFTER trigger for audit

### Tertiary (LOW confidence)
- WebSearch on postponement detection patterns - no specific industry standard found; custom implementation recommended

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All components already exist in project
- Architecture: HIGH - Direct adaptation of proven contact patterns
- Pitfalls: HIGH - Based on existing implementation and PostgreSQL best practices
- Postponement detection: MEDIUM - Custom logic, threshold values may need tuning

**Research date:** 2026-02-04
**Valid until:** 2026-03-04 (30 days - patterns are stable, based on existing project code)
