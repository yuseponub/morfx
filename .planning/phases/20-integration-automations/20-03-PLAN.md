---
phase: 20-integration-automations
plan: 03
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - src/lib/automations/action-executor.ts
  - src/app/api/webhooks/twilio/status/route.ts
  - src/lib/builder/validation.ts
autonomous: true

must_haves:
  truths:
    - "send_sms action executes via Twilio SDK and stores SMS record in sms_messages"
    - "Twilio status callback endpoint updates sms_messages with price and final status"
    - "send_sms is in ACTION_TO_TRIGGER_MAP with empty array (no cascading triggers)"
    - "Action executor exhaustive switch includes send_sms case"
  artifacts:
    - path: "src/lib/automations/action-executor.ts"
      provides: "executeSendSms handler in action dispatcher"
      contains: "executeSendSms"
    - path: "src/app/api/webhooks/twilio/status/route.ts"
      provides: "Twilio status callback endpoint for async price/status updates"
      exports: ["POST"]
    - path: "src/lib/builder/validation.ts"
      provides: "send_sms in ACTION_TO_TRIGGER_MAP"
      contains: "send_sms"
  key_links:
    - from: "src/lib/automations/action-executor.ts"
      to: "src/lib/twilio/client.ts"
      via: "getTwilioConfig + createTwilioClient for SMS sending"
      pattern: "getTwilioConfig|createTwilioClient"
    - from: "src/app/api/webhooks/twilio/status/route.ts"
      to: "sms_messages table"
      via: "Updates price/status by twilio_sid"
      pattern: "sms_messages.*update"
---

<objective>
Twilio SMS action: executeSendSms handler in action executor, status callback endpoint, and builder validation update.

Purpose: After this plan, automations can execute the send_sms action type, which sends SMS via Twilio SDK, stores the record in sms_messages table, and uses a status callback URL for async price/delivery updates. The AI builder's cycle detection also knows that send_sms produces no cascading triggers.

Output: Working send_sms action handler, Twilio status callback API route, updated builder validation.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-integration-automations/20-CONTEXT.md
@.planning/phases/20-integration-automations/20-RESEARCH.md
@src/lib/automations/action-executor.ts
@src/lib/twilio/client.ts
@src/lib/builder/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement executeSendSms in action executor</name>
  <files>src/lib/automations/action-executor.ts</files>
  <action>
1. Add imports at the top of action-executor.ts:
   ```typescript
   import { getTwilioConfig, createTwilioClient } from '@/lib/twilio/client'
   ```

2. Add `case 'send_sms':` to the `executeByType` switch, BEFORE the `default:` case:
   ```typescript
   case 'send_sms':
     return executeSendSms(params, context, workspaceId)
   ```

3. Implement `executeSendSms` function (add in the WhatsApp section area, or create a new "Twilio SMS Actions" section):

   ```typescript
   // ============================================================================
   // Twilio SMS Action — via Twilio SDK
   // Sends SMS, stores record in sms_messages, uses status callback for async price.
   // ============================================================================

   async function executeSendSms(
     params: Record<string, unknown>,
     context: TriggerContext,
     workspaceId: string
   ): Promise<unknown> {
     const body = String(params.body || '')
     if (!body) throw new Error('body is required for send_sms')

     // Resolve recipient phone: explicit param > contact phone from context
     const to = params.to ? String(params.to) : context.contactPhone
     if (!to) throw new Error('No phone number available for SMS — set "to" param or ensure trigger has contactPhone')

     // Load Twilio credentials (throws if not configured)
     const twilioConfig = await getTwilioConfig(workspaceId)
     const client = createTwilioClient(twilioConfig)

     // Build message params
     const statusCallbackUrl = process.env.NEXT_PUBLIC_APP_URL
       ? `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/twilio/status`
       : undefined

     const messageParams: Record<string, unknown> = {
       body,
       from: twilioConfig.phone_number,
       to,
       ...(statusCallbackUrl && { statusCallback: statusCallbackUrl }),
     }

     // Optional MMS media (only works for US/Canada numbers)
     if (params.mediaUrl) {
       messageParams.mediaUrl = [String(params.mediaUrl)]
     }

     // Send SMS via Twilio
     const message = await client.messages.create(messageParams)

     // Store SMS record for usage tracking
     const supabase = createAdminClient()
     await supabase.from('sms_messages').insert({
       workspace_id: workspaceId,
       twilio_sid: message.sid,
       from_number: twilioConfig.phone_number,
       to_number: to,
       body,
       status: message.status,
       direction: 'outbound',
       // Price may not be available immediately — updated via status callback
       price: message.price ? Math.abs(parseFloat(message.price)) : null,
       price_unit: message.priceUnit || 'USD',
       segments: message.numSegments ? parseInt(message.numSegments) : 1,
       media_url: params.mediaUrl ? String(params.mediaUrl) : null,
     })

     return { messageSid: message.sid, status: message.status, to, sent: true }
   }
   ```

   IMPORTANT:
   - Use `Math.abs` on price because Twilio returns negative values (outgoing cost).
   - The statusCallback URL is optional (won't break if NEXT_PUBLIC_APP_URL not set, just means no async price updates).
   - Do NOT add cascadeDepth param -- SMS doesn't produce any triggers.
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep "action-executor"` -- no errors in action-executor.ts. The exhaustive switch should now be complete for send_sms.</verify>
  <done>executeSendSms function exists, action dispatcher routes send_sms to it, exhaustive switch is complete with no TS errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create Twilio status callback endpoint and update builder validation</name>
  <files>src/app/api/webhooks/twilio/status/route.ts, src/lib/builder/validation.ts</files>
  <action>
1. Create `src/app/api/webhooks/twilio/status/route.ts`:

   This is a POST endpoint that Twilio calls when SMS status changes (sent -> delivered, or sent -> failed). It updates the sms_messages table with the final status and price.

   ```typescript
   import { NextRequest, NextResponse } from 'next/server'
   import { createAdminClient } from '@/lib/supabase/admin'

   /**
    * Twilio Status Callback Endpoint
    * Called by Twilio when SMS delivery status changes.
    * Updates sms_messages with final status, price, and error info.
    *
    * Twilio sends form-encoded data (not JSON).
    * Key fields: MessageSid, MessageStatus, Price, PriceUnit, ErrorCode, ErrorMessage
    */
   export async function POST(request: NextRequest) {
     try {
       const formData = await request.formData()

       const messageSid = formData.get('MessageSid') as string | null
       const messageStatus = formData.get('MessageStatus') as string | null
       const price = formData.get('Price') as string | null
       const priceUnit = formData.get('PriceUnit') as string | null
       const errorCode = formData.get('ErrorCode') as string | null
       const errorMessage = formData.get('ErrorMessage') as string | null

       if (!messageSid) {
         return NextResponse.json({ error: 'Missing MessageSid' }, { status: 400 })
       }

       const supabase = createAdminClient()

       const updateData: Record<string, unknown> = {
         status: messageStatus || 'unknown',
       }

       // Price: Twilio returns negative for outbound, we store absolute value
       if (price) {
         updateData.price = Math.abs(parseFloat(price))
       }
       if (priceUnit) {
         updateData.price_unit = priceUnit
       }
       if (errorCode) {
         updateData.error_code = errorCode
       }
       if (errorMessage) {
         updateData.error_message = errorMessage
       }

       await supabase
         .from('sms_messages')
         .update(updateData)
         .eq('twilio_sid', messageSid)

       return NextResponse.json({ received: true })
     } catch (error) {
       console.error('[twilio-status-callback] Error:', error)
       // Return 200 to prevent Twilio from retrying on our errors
       return NextResponse.json({ received: true, error: 'Processing failed' })
     }
   }
   ```

2. In `src/lib/builder/validation.ts`, add `send_sms` to `ACTION_TO_TRIGGER_MAP`:
   ```typescript
   send_sms: [],  // SMS doesn't produce any trigger events
   ```

   This goes alongside the existing entries like `send_whatsapp_template: []`, `send_whatsapp_text: []`, etc.
  </action>
  <verify>`ls src/app/api/webhooks/twilio/status/route.ts` -- file exists. `grep 'send_sms' src/lib/builder/validation.ts` -- entry found. `npx tsc --noEmit 2>&1 | grep "twilio/status"` -- no type errors.</verify>
  <done>Twilio status callback endpoint handles form-encoded Twilio status updates. Builder validation includes send_sms in ACTION_TO_TRIGGER_MAP with empty trigger array.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit 2>&1 | grep "error TS" | wc -l` -- reduced by at least 1 (send_sms exhaustive switch fixed)
- `grep 'executeSendSms' src/lib/automations/action-executor.ts` finds the function
- `grep "case 'send_sms'" src/lib/automations/action-executor.ts` finds the switch case
- `ls src/app/api/webhooks/twilio/status/route.ts` confirms endpoint exists
- `grep 'send_sms' src/lib/builder/validation.ts` confirms ACTION_TO_TRIGGER_MAP entry
</verification>

<success_criteria>
- send_sms action dispatches to executeSendSms which calls Twilio SDK
- SMS record stored in sms_messages with all fields
- Status callback endpoint updates sms_messages by twilio_sid
- Builder validation knows send_sms produces no cascading triggers
- No TypeScript errors in action-executor.ts or the callback route
</success_criteria>

<output>
After completion, create `.planning/phases/20-integration-automations/20-03-SUMMARY.md`
</output>
