---
phase: 08-whatsapp-extended
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/actions/teams.ts
  - src/app/actions/quick-replies.ts
  - src/app/actions/assignment.ts
  - src/app/actions/usage.ts
autonomous: true

must_haves:
  truths:
    - "Teams can be created, listed, and managed"
    - "Agents can be added to and removed from teams"
    - "Conversations can be assigned to agents"
    - "Agent availability can be toggled"
    - "Quick replies can be created and managed"
    - "Message costs can be aggregated by period"
  artifacts:
    - path: "src/app/actions/teams.ts"
      provides: "Team CRUD and member management"
      exports: ["getTeams", "createTeam", "updateTeam", "deleteTeam", "addTeamMember", "removeTeamMember"]
    - path: "src/app/actions/quick-replies.ts"
      provides: "Quick reply CRUD"
      exports: ["getQuickReplies", "createQuickReply", "updateQuickReply", "deleteQuickReply"]
    - path: "src/app/actions/assignment.ts"
      provides: "Conversation assignment logic"
      exports: ["assignConversation", "assignToNextAvailable", "setAgentAvailability", "getAvailableAgents"]
    - path: "src/app/actions/usage.ts"
      provides: "Cost tracking and aggregation"
      exports: ["recordMessageCost", "getUsageSummary", "getUsageByCategory", "getWorkspacesUsage"]
  key_links:
    - from: "src/app/actions/assignment.ts"
      to: "src/app/actions/teams.ts"
      via: "team lookup for round-robin"
      pattern: "getTeamMembers"
---

<objective>
Create Server Actions for teams, quick replies, agent assignment, and usage tracking.

Purpose: All data operations for Phase 8 features with proper business logic.
Output: Four Server Action files covering teams, quick replies, assignment, and cost tracking.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-whatsapp-extended/08-CONTEXT.md
@.planning/phases/08-whatsapp-extended/08-RESEARCH.md
@src/app/actions/conversations.ts
@src/lib/whatsapp/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Team and Team Member Server Actions</name>
  <files>src/app/actions/teams.ts</files>
  <action>
Create Server Actions for team management:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { getWorkspaceId } from '@/lib/workspace'
import { revalidatePath } from 'next/cache'
import { Team, TeamMember } from '@/lib/whatsapp/types'

// Get all teams with member count
export async function getTeams(): Promise<(Team & { member_count: number })[]> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) throw new Error('No workspace selected')

  const { data, error } = await supabase
    .from('teams')
    .select(`
      *,
      team_members(count)
    `)
    .eq('workspace_id', workspaceId)
    .order('created_at')

  if (error) throw error
  return (data || []).map(t => ({
    ...t,
    member_count: t.team_members?.[0]?.count || 0
  }))
}

// Get single team with members
export async function getTeamWithMembers(teamId: string): Promise<Team & { members: TeamMember[] }> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  const { data: team, error } = await supabase
    .from('teams')
    .select('*')
    .eq('id', teamId)
    .eq('workspace_id', workspaceId)
    .single()

  if (error) throw error

  // Get members with profile info
  const { data: members } = await supabase
    .from('team_members')
    .select(`
      *,
      profiles!user_id(email, full_name)
    `)
    .eq('team_id', teamId)

  return {
    ...team,
    members: (members || []).map(m => ({
      ...m,
      user_email: m.profiles?.email,
      user_name: m.profiles?.full_name
    }))
  }
}

// Create new team
export async function createTeam(params: { name: string; is_default?: boolean }): Promise<Team> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) throw new Error('No workspace selected')

  // If setting as default, unset other defaults first
  if (params.is_default) {
    await supabase
      .from('teams')
      .update({ is_default: false })
      .eq('workspace_id', workspaceId)
      .eq('is_default', true)
  }

  const { data, error } = await supabase
    .from('teams')
    .insert({
      workspace_id: workspaceId,
      name: params.name,
      is_default: params.is_default || false
    })
    .select()
    .single()

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/equipos')
  return data
}

// Update team
export async function updateTeam(id: string, params: { name?: string; is_default?: boolean }): Promise<void> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  // If setting as default, unset other defaults first
  if (params.is_default) {
    await supabase
      .from('teams')
      .update({ is_default: false })
      .eq('workspace_id', workspaceId)
      .eq('is_default', true)
  }

  const { error } = await supabase
    .from('teams')
    .update(params)
    .eq('id', id)
    .eq('workspace_id', workspaceId)

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/equipos')
}

// Delete team
export async function deleteTeam(id: string): Promise<void> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  // Check if team has members
  const { count } = await supabase
    .from('team_members')
    .select('*', { count: 'exact', head: true })
    .eq('team_id', id)

  if (count && count > 0) {
    throw new Error('No se puede eliminar un equipo con miembros. Elimina los miembros primero.')
  }

  const { error } = await supabase
    .from('teams')
    .delete()
    .eq('id', id)
    .eq('workspace_id', workspaceId)

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/equipos')
}

// Add member to team
export async function addTeamMember(teamId: string, userId: string): Promise<TeamMember> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('team_members')
    .insert({
      team_id: teamId,
      user_id: userId,
      is_online: false
    })
    .select()
    .single()

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/equipos')
  return data
}

// Remove member from team
export async function removeTeamMember(teamId: string, userId: string): Promise<void> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('team_members')
    .delete()
    .eq('team_id', teamId)
    .eq('user_id', userId)

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/equipos')
}

// Get workspace members not in any team (for adding)
export async function getUnassignedMembers(): Promise<{ id: string; email: string; name: string }[]> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  // Get all workspace members
  const { data: wsMembers } = await supabase
    .from('workspace_members')
    .select('user_id, profiles!user_id(email, full_name)')
    .eq('workspace_id', workspaceId)

  // Get all team members in workspace
  const { data: teams } = await supabase
    .from('teams')
    .select('id')
    .eq('workspace_id', workspaceId)

  const teamIds = (teams || []).map(t => t.id)

  const { data: teamMembers } = await supabase
    .from('team_members')
    .select('user_id')
    .in('team_id', teamIds)

  const assignedUserIds = new Set((teamMembers || []).map(m => m.user_id))

  return (wsMembers || [])
    .filter(m => !assignedUserIds.has(m.user_id))
    .map(m => ({
      id: m.user_id,
      email: m.profiles?.email || '',
      name: m.profiles?.full_name || ''
    }))
}
```

Follow existing patterns from src/app/actions/conversations.ts for Supabase client usage and error handling.
  </action>
  <verify>Run `pnpm tsc --noEmit` to verify TypeScript compiles. Check that Team and TeamMember types are imported correctly.</verify>
  <done>Team Server Actions created with full CRUD for teams and members. getTeams, getTeamWithMembers, createTeam, updateTeam, deleteTeam, addTeamMember, removeTeamMember, getUnassignedMembers all implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Quick Reply and Assignment Server Actions</name>
  <files>
    src/app/actions/quick-replies.ts
    src/app/actions/assignment.ts
  </files>
  <action>
**Create src/app/actions/quick-replies.ts:**

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { getWorkspaceId } from '@/lib/workspace'
import { revalidatePath } from 'next/cache'
import { QuickReply } from '@/lib/whatsapp/types'

// Get all quick replies for workspace
export async function getQuickReplies(): Promise<QuickReply[]> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) throw new Error('No workspace selected')

  const { data, error } = await supabase
    .from('quick_replies')
    .select('*')
    .eq('workspace_id', workspaceId)
    .order('shortcut')

  if (error) throw error
  return data || []
}

// Create quick reply
export async function createQuickReply(params: {
  shortcut: string
  content: string
  category?: string
}): Promise<QuickReply> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) throw new Error('No workspace selected')

  // Normalize shortcut (lowercase, no spaces)
  const normalizedShortcut = params.shortcut.toLowerCase().replace(/\s+/g, '_')

  const { data, error } = await supabase
    .from('quick_replies')
    .insert({
      workspace_id: workspaceId,
      shortcut: normalizedShortcut,
      content: params.content,
      category: params.category || null
    })
    .select()
    .single()

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/quick-replies')
  return data
}

// Update quick reply
export async function updateQuickReply(id: string, params: {
  shortcut?: string
  content?: string
  category?: string | null
}): Promise<void> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  const updates: Record<string, unknown> = { updated_at: new Date().toISOString() }
  if (params.shortcut) updates.shortcut = params.shortcut.toLowerCase().replace(/\s+/g, '_')
  if (params.content) updates.content = params.content
  if (params.category !== undefined) updates.category = params.category

  const { error } = await supabase
    .from('quick_replies')
    .update(updates)
    .eq('id', id)
    .eq('workspace_id', workspaceId)

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/quick-replies')
}

// Delete quick reply
export async function deleteQuickReply(id: string): Promise<void> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  const { error } = await supabase
    .from('quick_replies')
    .delete()
    .eq('id', id)
    .eq('workspace_id', workspaceId)

  if (error) throw error
  revalidatePath('/configuracion/whatsapp/quick-replies')
}

// Search quick replies by shortcut (for autocomplete)
export async function searchQuickReplies(query: string): Promise<QuickReply[]> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) return []

  const { data } = await supabase
    .from('quick_replies')
    .select('*')
    .eq('workspace_id', workspaceId)
    .ilike('shortcut', `${query}%`)
    .limit(10)

  return data || []
}
```

**Create src/app/actions/assignment.ts:**

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { getWorkspaceId } from '@/lib/workspace'
import { revalidatePath } from 'next/cache'

interface AssignmentResult {
  agentId: string
  agentName: string
  teamId: string
}

// Assign conversation to specific agent
export async function assignConversation(
  conversationId: string,
  agentId: string | null,  // null to unassign
  teamId?: string
): Promise<void> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  const updates: Record<string, unknown> = {
    assigned_to: agentId,
    updated_at: new Date().toISOString()
  }

  if (teamId !== undefined) {
    updates.team_id = teamId
  }

  const { error } = await supabase
    .from('conversations')
    .update(updates)
    .eq('id', conversationId)
    .eq('workspace_id', workspaceId)

  if (error) throw error
  revalidatePath('/whatsapp')
}

// Auto-assign to next available agent in team (round-robin)
export async function assignToNextAvailable(
  conversationId: string,
  teamId: string
): Promise<AssignmentResult | null> {
  const supabase = await createClient()

  // Get online agents in team, ordered by last assignment (oldest first)
  const { data: agents, error: agentsError } = await supabase
    .from('team_members')
    .select(`
      user_id,
      last_assigned_at,
      profiles!user_id(full_name, email)
    `)
    .eq('team_id', teamId)
    .eq('is_online', true)
    .order('last_assigned_at', { ascending: true, nullsFirst: true })

  if (agentsError) throw agentsError
  if (!agents || agents.length === 0) return null

  // Round-robin: pick agent with oldest last_assigned_at
  const nextAgent = agents[0]

  // Update last_assigned_at for this agent
  await supabase
    .from('team_members')
    .update({ last_assigned_at: new Date().toISOString() })
    .eq('team_id', teamId)
    .eq('user_id', nextAgent.user_id)

  // Assign conversation
  await assignConversation(conversationId, nextAgent.user_id, teamId)

  return {
    agentId: nextAgent.user_id,
    agentName: nextAgent.profiles?.full_name || nextAgent.profiles?.email || 'Agente',
    teamId
  }
}

// Toggle agent availability
export async function setAgentAvailability(
  userId: string,
  isOnline: boolean
): Promise<void> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('team_members')
    .update({ is_online: isOnline })
    .eq('user_id', userId)

  if (error) throw error
  revalidatePath('/whatsapp')
}

// Get my availability status
export async function getMyAvailability(): Promise<boolean> {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) return false

  const { data } = await supabase
    .from('team_members')
    .select('is_online')
    .eq('user_id', user.id)
    .limit(1)
    .single()

  return data?.is_online || false
}

// Get available agents for manual assignment dropdown
export async function getAvailableAgents(): Promise<{ id: string; name: string; team: string; is_online: boolean }[]> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) return []

  // Get all teams in workspace
  const { data: teams } = await supabase
    .from('teams')
    .select('id, name')
    .eq('workspace_id', workspaceId)

  if (!teams || teams.length === 0) return []

  const teamIds = teams.map(t => t.id)
  const teamNameMap = Object.fromEntries(teams.map(t => [t.id, t.name]))

  // Get all members in these teams
  const { data: members } = await supabase
    .from('team_members')
    .select(`
      user_id,
      team_id,
      is_online,
      profiles!user_id(full_name, email)
    `)
    .in('team_id', teamIds)

  return (members || []).map(m => ({
    id: m.user_id,
    name: m.profiles?.full_name || m.profiles?.email || 'Agente',
    team: teamNameMap[m.team_id] || '',
    is_online: m.is_online
  }))
}

// Get default team for new conversations
export async function getDefaultTeam(): Promise<{ id: string; name: string } | null> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) return null

  const { data } = await supabase
    .from('teams')
    .select('id, name')
    .eq('workspace_id', workspaceId)
    .eq('is_default', true)
    .single()

  return data
}
```

Both files follow existing Server Action patterns.
  </action>
  <verify>Run `pnpm tsc --noEmit` to verify both files compile correctly.</verify>
  <done>Quick reply Server Actions created with getQuickReplies, createQuickReply, updateQuickReply, deleteQuickReply, searchQuickReplies. Assignment Server Actions created with assignConversation, assignToNextAvailable, setAgentAvailability, getMyAvailability, getAvailableAgents, getDefaultTeam.</done>
</task>

<task type="auto">
  <name>Task 3: Usage and Cost Tracking Server Actions</name>
  <files>src/app/actions/usage.ts</files>
  <action>
Create Server Actions for message cost tracking and usage reporting:

```typescript
'use server'

import { createClient, createAdminClient } from '@/lib/supabase/server'
import { getWorkspaceId } from '@/lib/workspace'
import { CostCategory, MessageCost } from '@/lib/whatsapp/types'
import { startOfDay, endOfDay, subDays, startOfMonth, endOfMonth } from 'date-fns'

// Meta's approximate pricing per message (USD) - update monthly
const COST_RATES: Record<CostCategory, Record<string, number>> = {
  marketing: { CO: 0.0177, default: 0.02 },  // Colombia, default
  utility: { CO: 0.0064, default: 0.008 },
  authentication: { CO: 0.0064, default: 0.008 },
  service: { CO: 0.0, default: 0.0 }  // Service conversations are free within 24h
}

function getCostRate(category: CostCategory, countryCode?: string | null): number {
  const rates = COST_RATES[category]
  return rates[countryCode || 'default'] || rates.default
}

// Record message cost from webhook (called internally, not from UI)
// Uses admin client to bypass RLS
export async function recordMessageCost(params: {
  workspaceId: string
  wamid: string
  category: CostCategory
  recipientCountry?: string | null
}): Promise<void> {
  const supabase = await createAdminClient()

  const cost = getCostRate(params.category, params.recipientCountry)

  // Use upsert to prevent duplicates from webhook retries
  const { error } = await supabase
    .from('message_costs')
    .upsert({
      workspace_id: params.workspaceId,
      wamid: params.wamid,
      category: params.category,
      pricing_model: 'PMP',
      recipient_country: params.recipientCountry,
      cost_usd: cost,
      recorded_at: new Date().toISOString()
    }, {
      onConflict: 'wamid',
      ignoreDuplicates: true
    })

  if (error) {
    console.error('Failed to record message cost:', error)
  }
}

// Date range presets
type DatePreset = 'today' | '7days' | '30days' | 'month'

function getDateRange(preset: DatePreset): { start: Date; end: Date } {
  const now = new Date()
  switch (preset) {
    case 'today':
      return { start: startOfDay(now), end: endOfDay(now) }
    case '7days':
      return { start: startOfDay(subDays(now, 6)), end: endOfDay(now) }
    case '30days':
      return { start: startOfDay(subDays(now, 29)), end: endOfDay(now) }
    case 'month':
      return { start: startOfMonth(now), end: endOfMonth(now) }
    default:
      return { start: startOfMonth(now), end: endOfMonth(now) }
  }
}

// Get usage summary for current workspace
export async function getUsageSummary(
  preset: DatePreset = 'month',
  customRange?: { start: string; end: string }
): Promise<{
  totalMessages: number
  totalCost: number
  byCategory: Record<CostCategory, { count: number; cost: number }>
}> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) throw new Error('No workspace selected')

  const range = customRange
    ? { start: new Date(customRange.start), end: new Date(customRange.end) }
    : getDateRange(preset)

  const { data, error } = await supabase
    .from('message_costs')
    .select('category, cost_usd')
    .eq('workspace_id', workspaceId)
    .gte('recorded_at', range.start.toISOString())
    .lte('recorded_at', range.end.toISOString())

  if (error) throw error

  const byCategory: Record<CostCategory, { count: number; cost: number }> = {
    marketing: { count: 0, cost: 0 },
    utility: { count: 0, cost: 0 },
    authentication: { count: 0, cost: 0 },
    service: { count: 0, cost: 0 }
  }

  let totalMessages = 0
  let totalCost = 0

  for (const row of data || []) {
    const cat = row.category as CostCategory
    const cost = row.cost_usd || 0
    byCategory[cat].count++
    byCategory[cat].cost += cost
    totalMessages++
    totalCost += cost
  }

  return { totalMessages, totalCost, byCategory }
}

// Get daily usage for chart
export async function getUsageByDay(
  days: number = 30
): Promise<{ date: string; count: number; cost: number }[]> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) return []

  const startDate = startOfDay(subDays(new Date(), days - 1))

  const { data, error } = await supabase
    .from('message_costs')
    .select('recorded_at, cost_usd')
    .eq('workspace_id', workspaceId)
    .gte('recorded_at', startDate.toISOString())
    .order('recorded_at')

  if (error) throw error

  // Group by day
  const dayMap = new Map<string, { count: number; cost: number }>()

  for (const row of data || []) {
    const day = row.recorded_at.split('T')[0]
    const existing = dayMap.get(day) || { count: 0, cost: 0 }
    existing.count++
    existing.cost += row.cost_usd || 0
    dayMap.set(day, existing)
  }

  // Fill in missing days
  const result: { date: string; count: number; cost: number }[] = []
  for (let i = 0; i < days; i++) {
    const date = startOfDay(subDays(new Date(), days - 1 - i)).toISOString().split('T')[0]
    const data = dayMap.get(date) || { count: 0, cost: 0 }
    result.push({ date, ...data })
  }

  return result
}

// Get usage by category for pie chart
export async function getUsageByCategory(
  preset: DatePreset = 'month'
): Promise<{ category: string; count: number; cost: number }[]> {
  const summary = await getUsageSummary(preset)

  return Object.entries(summary.byCategory).map(([category, data]) => ({
    category,
    count: data.count,
    cost: data.cost
  }))
}

// SUPER ADMIN: Get usage for all workspaces
export async function getAllWorkspacesUsage(
  preset: DatePreset = 'month'
): Promise<{
  workspaceId: string
  workspaceName: string
  totalMessages: number
  totalCost: number
  limit: number | null
  usagePercent: number | null
}[]> {
  // Verify super admin access
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  const MORFX_OWNER_ID = process.env.MORFX_OWNER_USER_ID
  if (!user || user.id !== MORFX_OWNER_ID) {
    throw new Error('Unauthorized')
  }

  const adminClient = await createAdminClient()
  const range = getDateRange(preset)

  // Get all workspaces
  const { data: workspaces } = await adminClient
    .from('workspaces')
    .select('id, name')

  if (!workspaces) return []

  const result = []

  for (const ws of workspaces) {
    // Get costs
    const { data: costs } = await adminClient
      .from('message_costs')
      .select('cost_usd')
      .eq('workspace_id', ws.id)
      .gte('recorded_at', range.start.toISOString())
      .lte('recorded_at', range.end.toISOString())

    const totalMessages = costs?.length || 0
    const totalCost = costs?.reduce((sum, c) => sum + (c.cost_usd || 0), 0) || 0

    // Get limits
    const { data: limits } = await adminClient
      .from('workspace_limits')
      .select('monthly_spend_limit_usd')
      .eq('workspace_id', ws.id)
      .single()

    const limit = limits?.monthly_spend_limit_usd
    const usagePercent = limit ? (totalCost / limit) * 100 : null

    result.push({
      workspaceId: ws.id,
      workspaceName: ws.name,
      totalMessages,
      totalCost,
      limit,
      usagePercent
    })
  }

  return result.sort((a, b) => b.totalCost - a.totalCost)
}

// Get current month's spend vs limit
export async function getSpendingStatus(): Promise<{
  currentSpend: number
  limit: number | null
  percentUsed: number | null
  isOverLimit: boolean
  isNearLimit: boolean
}> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) throw new Error('No workspace selected')

  const summary = await getUsageSummary('month')

  // Get limit (need admin client since no RLS policy)
  const adminClient = await createAdminClient()
  const { data: limits } = await adminClient
    .from('workspace_limits')
    .select('monthly_spend_limit_usd, alert_threshold_percent')
    .eq('workspace_id', workspaceId)
    .single()

  const limit = limits?.monthly_spend_limit_usd
  const threshold = limits?.alert_threshold_percent || 80
  const percentUsed = limit ? (summary.totalCost / limit) * 100 : null

  return {
    currentSpend: summary.totalCost,
    limit,
    percentUsed,
    isOverLimit: limit ? summary.totalCost >= limit : false,
    isNearLimit: limit ? summary.totalCost >= limit * (threshold / 100) : false
  }
}
```

Note: createAdminClient may need to be created if it doesn't exist - use service role key for bypassing RLS.
  </action>
  <verify>Run `pnpm tsc --noEmit` to verify TypeScript compiles. Check date-fns imports are valid.</verify>
  <done>Usage Server Actions created: recordMessageCost (internal), getUsageSummary, getUsageByDay, getUsageByCategory, getAllWorkspacesUsage (super admin), getSpendingStatus. All use proper workspace isolation and date range handling.</done>
</task>

</tasks>

<verification>
1. All Server Actions compile without TypeScript errors
2. Team operations include member count and profile info
3. Quick replies support search for autocomplete
4. Assignment includes round-robin logic with last_assigned_at tracking
5. Usage tracking supports multiple date presets
6. Super admin function checks MORFX_OWNER_USER_ID
</verification>

<success_criteria>
- Four new Server Action files compile successfully
- Teams can be created with members added/removed
- Quick replies support CRUD and search
- Assignment supports manual and auto (round-robin)
- Usage summary provides by-category and by-day data
- Super admin can see all workspaces usage
</success_criteria>

<output>
After completion, create `.planning/phases/08-whatsapp-extended/08-02-SUMMARY.md`
</output>
