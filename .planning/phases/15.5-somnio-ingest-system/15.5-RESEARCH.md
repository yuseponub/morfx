# Phase 15.5: Somnio Ingest System - Research

**Researched:** 2026-02-07
**Domain:** LLM-based message classification, timer-based workflows, silent data accumulation
**Confidence:** HIGH

## Summary

This phase implements a data accumulation system for the Somnio sales agent during `collecting_data` mode. The core challenge is implementing intelligent message classification (datos/pregunta/mixto/irrelevante) using an LLM, combined with a silent accumulation pattern where the bot does not respond to data messages.

The research focused on three key areas:
1. **LLM-based classification** - Using Claude Haiku for fast, cheap message classification with structured outputs
2. **Timer management** - Inngest's waitForEvent for complex timeout scenarios (6 min partial / 10 min no data)
3. **Silent accumulation architecture** - Patterns for "wait before reply" with visual feedback in sandbox

**Primary recommendation:** Use Claude Haiku 4.5 with JSON structured outputs for the classifier, emit separate Inngest events for ingest lifecycle, and add ingestStatus to SandboxState for debug visibility.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @anthropic-ai/sdk | 0.39.0+ | Claude API for message classification | Already in project, supports structured outputs |
| inngest | 3.51.0 | Durable timer workflows | Already in project, proven pattern from Phase 13 |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| zod | 3.23.8 | Schema definition for structured outputs | Type-safe JSON parsing of classifier response |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Claude Haiku | Regex patterns | Regex can't handle natural language complexity (mixto detection) |
| Inngest | setTimeout | setTimeout doesn't survive server restarts |
| Structured outputs | JSON parsing with try/catch | Structured outputs guarantee valid JSON |

**Installation:**
```bash
# All dependencies already installed
```

## Architecture Patterns

### Recommended Project Structure
```
src/lib/agents/somnio/
â”œâ”€â”€ message-classifier.ts    # NEW: LLM-based datos/pregunta classifier
â”œâ”€â”€ ingest-manager.ts        # NEW: Silent accumulation logic
â”œâ”€â”€ data-extractor.ts        # EXISTING: Data extraction
â”œâ”€â”€ somnio-engine.ts         # MODIFY: Integrate classifier + ingest
â””â”€â”€ ...

src/inngest/functions/
â”œâ”€â”€ agent-timers.ts          # MODIFY: New ingest timer logic
â””â”€â”€ ...

src/lib/sandbox/
â””â”€â”€ types.ts                 # MODIFY: Add ingestStatus to SandboxState
```

### Pattern 1: Fast LLM Classification with Structured Outputs
**What:** Use Claude Haiku with JSON schema constraints for guaranteed-valid classification responses
**When to use:** Every message in `collecting_data` mode; also for detecting "implicit yes" (datos sent without saying "si")

```typescript
// Source: Anthropic Structured Outputs docs
import { z } from 'zod';
import { zodOutputFormat } from '@anthropic-ai/sdk/helpers/zod';

const MessageClassificationSchema = z.object({
  classification: z.enum(['datos', 'pregunta', 'mixto', 'irrelevante']),
  confidence: z.number().min(0).max(100),
  reasoning: z.string().optional(),
  // For 'mixto' - what data was detected
  extractedDataHint: z.record(z.string(), z.string()).optional(),
});

async function classifyMessage(message: string, context: ClaudeMessage[]): Promise<Classification> {
  const response = await client.messages.create({
    model: 'claude-haiku-4-5-20251101',
    max_tokens: 256,
    messages: [...context, { role: 'user', content: message }],
    system: CLASSIFIER_PROMPT,
    output_config: {
      format: zodOutputFormat(MessageClassificationSchema)
    }
  });

  return MessageClassificationSchema.parse(JSON.parse(response.content[0].text));
}
```

### Pattern 2: Ingest Timer with Two Timeouts
**What:** Single Inngest function with conditional timeout logic
**When to use:** When entering collecting_data mode with ingest active

```typescript
// Source: Inngest docs + existing agent-timers.ts pattern
export const ingestTimer = inngest.createFunction(
  { id: 'ingest-timer', name: 'Ingest Timer' },
  { event: 'agent/ingest.started' },
  async ({ event, step }) => {
    const { sessionId, hasPartialData, timerDurationMs } = event.data;

    // Wait for data completion OR timeout
    const completionEvent = await step.waitForEvent('wait-for-completion', {
      event: 'agent/ingest.completed',
      timeout: `${timerDurationMs}ms`, // 6 min or 10 min
      match: 'data.sessionId',
    });

    if (!completionEvent) {
      // Timeout expired - send appropriate message
      await step.run('handle-timeout', async () => {
        const session = await getSession(sessionId);
        const message = buildTimeoutMessage(session.state.datos_capturados);
        await sendWhatsAppMessage(sessionId, message);
      });
    }
  }
);
```

### Pattern 3: Silent Accumulation (No Response on Data)
**What:** When classification is 'datos', accumulate silently without sending any response
**When to use:** Every 'datos' message during collecting_data mode

```typescript
// In SomnioEngine.processMessage() or dedicated IngestManager
async processIngestMessage(input: ProcessInput): Promise<IngestResult> {
  const classification = await this.classifier.classify(input.message, history);

  if (classification.classification === 'datos') {
    // Extract and store data
    const extracted = await this.dataExtractor.extract(input.message, existingData, history);
    await this.sessionManager.updateState(sessionId, { datos_capturados: merged });

    // NO RESPONSE - silent accumulation
    return {
      responded: false,
      dataAccumulated: true,
      extractedFields: Object.keys(extracted.normalized),
    };
  }

  if (classification.classification === 'pregunta') {
    // Respond normally via existing flow
    return this.handleQuestion(input);
  }

  if (classification.classification === 'mixto') {
    // Extract data AND respond to question
    await this.extractAndStoreData(input.message);
    return this.handleQuestion(input);
  }

  // 'irrelevante' - ignore silently, don't affect timer
  return { responded: false, dataAccumulated: false };
}
```

### Pattern 4: Sandbox IngestStatus Display
**What:** Show ingest state in Estado tab, not as pseudo-tool
**When to use:** During collecting_data mode in sandbox

```typescript
// In SandboxState type
interface SandboxState {
  currentMode: string;
  intentsVistos: string[];
  // ... existing fields

  // NEW: Ingest tracking
  ingestStatus?: {
    active: boolean;
    startedAt: string | null;
    firstDataAt: string | null;
    fieldsAccumulated: string[];
    timerType: 'partial' | 'no_data' | null;
    timerExpiresAt: string | null;
  };
}
```

### Anti-Patterns to Avoid
- **Responding to every message:** The key insight is SILENCE during data accumulation. Only respond to preguntas.
- **Restarting timer on each message:** Timer starts with FIRST data, does not restart with additional data.
- **Single timer duration:** Must differentiate 6 min (partial data) vs 10 min (no data).
- **Polling for timeout:** Use event-driven waitForEvent, not polling loops.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JSON parsing from LLM | Try/catch JSON.parse | Claude Structured Outputs | Guaranteed valid JSON, no retries needed |
| Timer persistence | setTimeout + DB storage | Inngest waitForEvent | Survives restarts, automatic retry |
| Timeout message formatting | String concatenation | Template with campo faltante list | Already exists in n8n, reuse format |
| Phone normalization | Custom regex | `normalizePhone()` from normalizers.ts | Already handles edge cases |
| City normalization | Custom mapping | `normalizeCity()` from normalizers.ts | Already handles abbreviations |

**Key insight:** The existing DataExtractor already handles all data extraction and normalization. The new classifier only needs to determine message TYPE (datos/pregunta/mixto/irrelevante), not extract data.

## Common Pitfalls

### Pitfall 1: Classifier Model Mismatch
**What goes wrong:** Using claude-sonnet instead of claude-haiku for classification, causing latency and cost issues
**Why it happens:** Copy-paste from DataExtractor which uses Sonnet
**How to avoid:** Explicitly use `claude-haiku-4-5-20251101` for classifier
**Warning signs:** > 1s latency per message classification, high token costs

### Pitfall 2: Timer Not Cancelling on Completion
**What goes wrong:** Customer sends all 8 fields, but timeout message still fires after 6 minutes
**Why it happens:** Forgot to emit `agent/ingest.completed` event when data is complete
**How to avoid:** Emit completion event when 8 fields detected, before ofrecer_promos
**Warning signs:** Spurious "quedamos pendientes" messages after successful data collection

### Pitfall 3: Missing "Implicit Yes" Detection
**What goes wrong:** Customer sends "Jose Romero, Bogota" without first saying "si", but system doesn't enter collecting_data
**Why it happens:** Only checking for explicit "si" intent
**How to avoid:** Run classifier on messages outside collecting_data too; detect datos -> implicit yes flow
**Warning signs:** Customers providing data but getting no response (stuck in conversacion mode)

### Pitfall 4: Sandbox State Not Updating
**What goes wrong:** Ingest status shows in sandbox but doesn't reflect actual timer state
**Why it happens:** SandboxEngine doesn't have access to real Inngest timer state
**How to avoid:** Store ingestStatus in session state, update on each message
**Warning signs:** Sandbox shows stale timer information

### Pitfall 5: Mixed Message Classification
**What goes wrong:** "Hola, soy Jose de Bogota" classified as only 'datos', missing saludo
**Why it happens:** Classifier prompt doesn't handle saludo+datos combination
**How to avoid:** Include hola+datos as a mixto variant in classifier prompt
**Warning signs:** No greeting response when customer leads with saludo

## Code Examples

Verified patterns from official sources and existing codebase:

### Message Classifier Prompt Structure
```typescript
// Source: Existing INTENT_DETECTOR_PROMPT pattern + structured outputs docs
const CLASSIFIER_PROMPT = `Eres un clasificador de mensajes para el modo de captura de datos de Somnio.

Tu UNICA tarea es determinar si el mensaje del cliente contiene:
- DATOS: Informacion personal (nombre, telefono, ciudad, direccion, etc.)
- PREGUNTA: Una pregunta que requiere respuesta (precio, envio, producto, etc.)
- MIXTO: Contiene AMBOS datos y pregunta (ej: "Jose Romero, cuanto cuesta?")
- IRRELEVANTE: Acknowledgments sin informacion (ok, gracias, entendido, ðŸ‘)

## Ejemplos

"Juan Carlos Perez" -> datos (solo nombre)
"Mi direccion es calle 123" -> datos (direccion)
"Cuanto vale?" -> pregunta (precio)
"Jose, de Bogota. Hacen envios?" -> mixto (nombre+ciudad + pregunta envio)
"Ok" -> irrelevante
"ðŸ‘" -> irrelevante
"Perfecto, gracias" -> irrelevante
"Hola, soy Maria" -> mixto (saludo + nombre)

## Instrucciones
1. NO extraigas los datos, solo CLASIFICA el tipo de mensaje
2. Si hay CUALQUIER dato personal, es 'datos' o 'mixto'
3. Si hay pregunta pero sin datos, es 'pregunta'
4. Si es solo acknowledgment, es 'irrelevante'
5. En caso de duda entre datos y pregunta, usa 'mixto'`;
```

### Ingest Manager State Machine
```typescript
// Source: Existing state machine patterns from somnio-orchestrator.ts
interface IngestState {
  active: boolean;
  startedAt: string | null;
  firstDataAt: string | null;
  fieldsCollected: string[];
}

class IngestManager {
  async handleMessage(
    sessionId: string,
    message: string,
    currentIngestState: IngestState
  ): Promise<IngestResult> {
    // Classify the message
    const classification = await this.classifier.classify(message);

    switch (classification.classification) {
      case 'datos': {
        // Extract and accumulate
        const extracted = await this.dataExtractor.extract(message);
        await this.storeData(sessionId, extracted);

        // Start timer on first data if not already started
        if (!currentIngestState.firstDataAt) {
          await this.startIngestTimer(sessionId, 'partial'); // 6 min
        }

        // Check for completion (8 fields)
        if (this.isComplete(sessionId)) {
          await this.completeIngest(sessionId);
          return { action: 'ofrecer_promos' };
        }

        // SILENT - no response
        return { action: 'silent' };
      }

      case 'pregunta': {
        // Normal response flow
        return { action: 'respond', message: 'process via orchestrator' };
      }

      case 'mixto': {
        // Both: extract data AND respond
        const extracted = await this.dataExtractor.extract(message);
        await this.storeData(sessionId, extracted);
        return { action: 'respond', message: 'process via orchestrator' };
      }

      case 'irrelevante': {
        // Ignore, don't affect timer
        return { action: 'silent' };
      }
    }
  }
}
```

### Timeout Message Builder
```typescript
// Source: CONTEXT.md timeout message format
function buildTimeoutMessage(
  datosCapturados: Record<string, string>,
  timerType: 'partial' | 'no_data'
): string {
  if (timerType === 'no_data') {
    return 'Quedamos pendientes a tus datos, o si tienes alguna pregunta acerca del producto no dudes en hacerla';
  }

  // Partial data - list missing fields
  const criticalFields = ['nombre', 'telefono', 'direccion', 'ciudad', 'departamento'];
  const additionalFields = ['apellido', 'barrio', 'correo', 'indicaciones_extra'];

  const missingCritical = criticalFields.filter(f => !datosCapturados[f] || datosCapturados[f] === 'N/A');
  const missingAdditional = additionalFields.filter(f => !datosCapturados[f]);

  const fieldLabels: Record<string, string> = {
    nombre: 'Tu nombre completo',
    telefono: 'Numero de telefono',
    direccion: 'Direccion de entrega',
    ciudad: 'Ciudad',
    departamento: 'Departamento',
    apellido: 'Apellido',
    barrio: 'Barrio',
    correo: 'Correo electronico',
    indicaciones_extra: 'Indicaciones adicionales',
  };

  const missing = [...missingCritical, ...missingAdditional.slice(0, 3 - missingCritical.length)];
  const list = missing.map(f => `- ${fieldLabels[f]}`).join('\n');

  return `Para poder despachar tu producto nos faltaria:\n${list}\nQuedamos pendientes`;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| JSON parsing with try/catch | Structured outputs with schema | 2025-11 | Guaranteed valid JSON, no retries |
| Manual timeout tracking | Inngest waitForEvent | 2025-Q3 | Durable, survives restarts |
| Single model for all tasks | Haiku for fast tasks, Sonnet for complex | 2025-10 | Cost optimization, latency reduction |

**Deprecated/outdated:**
- `output_format` parameter: Replaced by `output_config.format` in Claude API (still works but deprecated)
- Beta headers for structured outputs: No longer required as of 2025-12

## Open Questions

Things that couldn't be fully resolved:

1. **Haiku 4.5 Availability**
   - What we know: Code currently maps `claude-haiku-4-5` to `claude-sonnet-4-20250514` as fallback
   - What's unclear: Whether Haiku 4.5 is now available (may have been released since training)
   - Recommendation: Test with `claude-haiku-4-5-20251101` model ID, fallback to sonnet if error

2. **Structured Outputs + Haiku Compatibility**
   - What we know: Structured outputs GA for "Claude Opus 4.6, Claude Sonnet 4.5, Claude Opus 4.5, and Claude Haiku 4.5"
   - What's unclear: If Haiku 4.5 is the same as `claude-haiku-4-5-20251101`
   - Recommendation: Test structured outputs with Haiku; if fails, fallback to JSON-in-prompt pattern

3. **Inngest Event Matching in WSL**
   - What we know: Inngest dev mode works, but real events may have timing issues
   - What's unclear: Whether `match: 'data.sessionId'` works correctly in local dev
   - Recommendation: Test thoroughly with multiple concurrent sessions

## Sources

### Primary (HIGH confidence)
- [Anthropic Structured Outputs](https://platform.claude.com/docs/en/build-with-claude/structured-outputs) - JSON schema, TypeScript/Zod integration, classification examples
- [Inngest Wait for Event](https://www.inngest.com/docs/features/inngest-functions/steps-workflows/wait-for-event) - timeout, match, conditional patterns
- Existing codebase: `src/lib/agents/somnio/*.ts` - proven patterns for data extraction, orchestration

### Secondary (MEDIUM confidence)
- [Prompt Engineering Guide - Classification](https://www.promptingguide.ai/prompts/classification) - LLM classification best practices
- [Lakera Prompt Engineering 2026](https://www.lakera.ai/blog/prompt-engineering-guide) - explicit instructions, structure

### Tertiary (LOW confidence)
- Web search results on "silent accumulation" pattern - limited direct matches, inference from related patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using existing project dependencies, well-documented APIs
- Architecture: HIGH - Follows established patterns from Phase 13 and 14
- Pitfalls: HIGH - Based on codebase analysis and official docs
- Classifier prompt: MEDIUM - Needs testing to validate mixto/irrelevante boundaries

**Research date:** 2026-02-07
**Valid until:** 2026-03-07 (30 days - stable domain, well-documented APIs)
