---
phase: 20-integration-automations
plan: 04
type: execute
wave: 3
depends_on: ["20-02"]
files_modified:
  - src/app/api/webhooks/shopify/route.ts
  - src/lib/shopify/webhook-handler.ts
autonomous: true

must_haves:
  truths:
    - "Shopify webhook route handles 3 topics: orders/create, orders/updated, draft_orders/create"
    - "orders/create with auto_sync=true creates contact+order AND emits shopify.order_created trigger"
    - "orders/create with auto_sync=false only emits shopify.order_created trigger (no CRM creation)"
    - "orders/updated emits shopify.order_updated trigger with full payload data"
    - "draft_orders/create emits shopify.draft_order_created trigger with draft-specific fields"
    - "Existing orders/create behavior unchanged when auto_sync_orders is undefined (defaults true)"
  artifacts:
    - path: "src/app/api/webhooks/shopify/route.ts"
      provides: "Webhook route handling 3 Shopify topics"
      contains: "draft_orders/create"
    - path: "src/lib/shopify/webhook-handler.ts"
      provides: "Dual-behavior processing with trigger emission"
      contains: "emitShopifyOrderCreated"
  key_links:
    - from: "src/lib/shopify/webhook-handler.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "Calls emitShopify* functions after processing"
      pattern: "emitShopify"
    - from: "src/app/api/webhooks/shopify/route.ts"
      to: "src/lib/shopify/webhook-handler.ts"
      via: "Dispatches to handler based on topic"
      pattern: "processShopifyWebhook|processShopifyOrderUpdated|processShopifyDraftOrder"
---

<objective>
Shopify webhook extension: handle orders/updated and draft_orders/create topics, implement dual-behavior toggle, and emit Shopify triggers.

Purpose: After this plan, the existing Shopify webhook endpoint handles all 3 topics. The auto-sync toggle controls whether orders/create auto-creates CRM records (existing behavior, default) or only emits the trigger for automations to handle. All 3 topics emit their respective Shopify triggers for the automations engine.

Output: Extended webhook route with 3-topic dispatch, dual-behavior toggle in handler, trigger emission.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-integration-automations/20-CONTEXT.md
@.planning/phases/20-integration-automations/20-RESEARCH.md
@src/app/api/webhooks/shopify/route.ts
@src/lib/shopify/webhook-handler.ts
@src/lib/shopify/types.ts
@src/lib/automations/trigger-emitter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Shopify webhook route for 3 topics</name>
  <files>src/app/api/webhooks/shopify/route.ts</files>
  <action>
1. The current route only processes `orders/create` and ignores all other topics. Modify it to handle 3 topics:

   a) Import new handler functions that will be created in Task 2:
   ```typescript
   import { processShopifyWebhook, processShopifyOrderUpdated, processShopifyDraftOrder } from '@/lib/shopify/webhook-handler'
   import type { ShopifyOrderWebhook, ShopifyDraftOrderWebhook, ShopifyIntegration } from '@/lib/shopify/types'
   ```

   b) Replace the single topic check (Step 6) with a topic dispatcher:
   ```typescript
   // Step 6: Dispatch by topic
   const supportedTopics = ['orders/create', 'orders/updated', 'draft_orders/create']
   if (!supportedTopics.includes(topic || '')) {
     console.log(`Ignoring Shopify webhook topic: ${topic}`)
     return NextResponse.json({ received: true, ignored: topic }, { status: 200 })
   }
   ```

   c) Replace the single processShopifyWebhook call (Step 7) with topic-specific dispatch:
   ```typescript
   // Step 7: Process by topic
   try {
     let result: { success: boolean; error?: string; orderId?: string; contactId?: string; contactCreated?: boolean; needsVerification?: boolean }

     switch (topic) {
       case 'orders/create':
         result = await processShopifyWebhook(payload as ShopifyOrderWebhook, integration, webhookId)
         break
       case 'orders/updated':
         result = await processShopifyOrderUpdated(payload as ShopifyOrderWebhook, integration, webhookId)
         break
       case 'draft_orders/create':
         result = await processShopifyDraftOrder(payload as ShopifyDraftOrderWebhook, integration, webhookId)
         break
       default:
         result = { success: true }
     }

     const duration = Date.now() - startTime
     console.log(`Shopify webhook [${topic}] processed in ${duration}ms: ${result.success ? 'success' : 'failed'}`)

     if (result.success) {
       return NextResponse.json({
         received: true,
         topic,
         orderId: result.orderId,
         contactId: result.contactId,
         contactCreated: result.contactCreated,
         needsVerification: result.needsVerification,
       }, { status: 200 })
     } else {
       console.error(`Shopify webhook [${topic}] processing failed:`, result.error)
       return NextResponse.json({ received: true, error: result.error }, { status: 200 })
     }
   } catch (error) { ... // keep existing catch block }
   ```

   d) For the payload parsing (Step 5), keep it as generic `JSON.parse(rawBody)` since both order and draft order payloads are valid JSON. The type cast happens in the switch.

   CRITICAL: Keep returning 200 for ALL cases (even errors) to prevent Shopify from retrying aggressively.
  </action>
  <verify>`grep "draft_orders/create" src/app/api/webhooks/shopify/route.ts` -- finds the topic. `grep "orders/updated" src/app/api/webhooks/shopify/route.ts` -- finds the topic.</verify>
  <done>Shopify webhook route dispatches to 3 handlers based on topic, ignores unsupported topics, returns 200 for all responses.</done>
</task>

<task type="auto">
  <name>Task 2: Implement dual-behavior toggle and 2 new handlers</name>
  <files>src/lib/shopify/webhook-handler.ts</files>
  <action>
1. Add import for Shopify trigger emitters at the top:
   ```typescript
   import {
     emitShopifyOrderCreated,
     emitShopifyDraftOrderCreated,
     emitShopifyOrderUpdated,
   } from '@/lib/automations/trigger-emitter'
   import type { ShopifyDraftOrderWebhook } from './types'
   ```

2. Modify the existing `processShopifyWebhook` function to implement dual-behavior:

   After the existing Step 5 (createOrderWithProducts), add trigger emission. Also, add the auto_sync toggle check:

   ```typescript
   // Read auto_sync setting (defaults to true for backward compatibility)
   const autoSync = config.auto_sync_orders !== false

   if (autoSync) {
     // EXISTING BEHAVIOR: create contact + order via domain
     const { contactId, contactCreated, needsVerification } = await resolveContact(...)
     const mapped = await mapShopifyOrder(...)
     const orderId = await createOrderWithProducts(...)

     // NEW: Also emit trigger for automations
     emitShopifyOrderCreated({
       workspaceId,
       shopifyOrderId: order.id,
       shopifyOrderNumber: order.name,
       total: order.total_price,
       financialStatus: order.financial_status,
       email: order.email,
       phone: extractPhoneFromOrder(order),
       note: order.note,
       products: order.line_items.map(li => ({ sku: li.sku, title: li.title, quantity: li.quantity, price: li.price })),
       shippingAddress: buildShippingAddressString(order),
       shippingCity: order.shipping_address?.city || null,
       tags: null, // orders/create doesn't include tags in standard payload
       contactId: contactId ?? undefined,
       contactName: /* build from order */ undefined,
       contactPhone: extractPhoneFromOrder(order) || undefined,
       orderId,
     })

     // ... rest of existing success flow
   } else {
     // NEW BEHAVIOR: only emit trigger, no CRM creation
     // Log webhook event
     await logWebhookEvent(supabase, integration.id, webhookId, 'orders/create', order, 'processed')

     emitShopifyOrderCreated({
       workspaceId,
       shopifyOrderId: order.id,
       shopifyOrderNumber: order.name,
       total: order.total_price,
       financialStatus: order.financial_status,
       email: order.email,
       phone: extractPhoneFromOrder(order),
       note: order.note,
       products: order.line_items.map(li => ({ sku: li.sku, title: li.title, quantity: li.quantity, price: li.price })),
       shippingAddress: buildShippingAddressString(order),
       shippingCity: order.shipping_address?.city || null,
       tags: null,
     })

     return { success: true }
   }
   ```

   The key refactoring: wrap the existing contact+order creation in an `if (autoSync)` block, and add the trigger emission to both branches.

3. Add new function `processShopifyOrderUpdated`:
   ```typescript
   export async function processShopifyOrderUpdated(
     order: ShopifyOrderWebhook,
     integration: ShopifyIntegration,
     webhookId: string
   ): Promise<ProcessResult> {
     const supabase = createAdminClient()
     const workspaceId = integration.workspace_id

     try {
       // Check for duplicate webhook
       const { data: existingEvent } = await supabase
         .from('webhook_events')
         .select('id')
         .eq('integration_id', integration.id)
         .eq('external_id', webhookId)
         .single()
       if (existingEvent) return { success: true, error: 'Duplicate webhook' }

       // Log webhook event
       await logWebhookEvent(supabase, integration.id, webhookId, 'orders/updated', order, 'processed')

       // Look up existing MorfX order by shopify_order_id to get contactId
       const { data: existingOrder } = await supabase
         .from('orders')
         .select('id, contact_id')
         .eq('workspace_id', workspaceId)
         .eq('shopify_order_id', order.id)
         .single()

       // Look up contact name/phone if we have a contact
       let contactName: string | undefined
       let contactPhone: string | undefined
       if (existingOrder?.contact_id) {
         const { data: contact } = await supabase
           .from('contacts')
           .select('name, phone')
           .eq('id', existingOrder.contact_id)
           .single()
         contactName = contact?.name || undefined
         contactPhone = contact?.phone || undefined
       }

       // Emit trigger for automations
       emitShopifyOrderUpdated({
         workspaceId,
         shopifyOrderId: order.id,
         shopifyOrderNumber: order.name,
         total: order.total_price,
         financialStatus: order.financial_status,
         fulfillmentStatus: order.fulfillment_status,
         email: order.email,
         phone: extractPhoneFromOrder(order),
         note: order.note,
         products: order.line_items.map(li => ({ sku: li.sku, title: li.title, quantity: li.quantity, price: li.price })),
         shippingAddress: buildShippingAddressString(order),
         shippingCity: order.shipping_address?.city || null,
         tags: null,
         contactId: existingOrder?.contact_id || undefined,
         contactName,
         contactPhone,
         orderId: existingOrder?.id || undefined,
       })

       return { success: true, orderId: existingOrder?.id }
     } catch (error) {
       console.error('Error processing Shopify order updated:', error)
       await updateWebhookEvent(supabase, integration.id, webhookId, 'failed', error instanceof Error ? error.message : 'Unknown error')
       return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
     }
   }
   ```

4. Add new function `processShopifyDraftOrder`:
   ```typescript
   export async function processShopifyDraftOrder(
     draftOrder: ShopifyDraftOrderWebhook,
     integration: ShopifyIntegration,
     webhookId: string
   ): Promise<ProcessResult> {
     const supabase = createAdminClient()
     const workspaceId = integration.workspace_id

     try {
       // Check for duplicate webhook
       const { data: existingEvent } = await supabase
         .from('webhook_events')
         .select('id')
         .eq('integration_id', integration.id)
         .eq('external_id', webhookId)
         .single()
       if (existingEvent) return { success: true, error: 'Duplicate webhook' }

       // Log webhook event
       await logWebhookEvent(supabase, integration.id, webhookId, 'draft_orders/create', draftOrder, 'processed')

       // Extract contact info from draft order
       const phone = extractPhoneFromOrder(draftOrder as unknown as ShopifyOrderWebhook)
       const customerName = draftOrder.customer
         ? [draftOrder.customer.first_name, draftOrder.customer.last_name].filter(Boolean).join(' ')
         : null

       // Emit trigger for automations (draft orders ALWAYS go through automations, no auto-sync)
       emitShopifyDraftOrderCreated({
         workspaceId,
         shopifyDraftOrderId: draftOrder.id,
         shopifyOrderNumber: draftOrder.name,
         total: draftOrder.total_price,
         status: draftOrder.status || 'open',
         email: draftOrder.email,
         phone,
         note: draftOrder.note,
         products: draftOrder.line_items.map(li => ({ sku: li.sku, title: li.title, quantity: li.quantity, price: li.price })),
         shippingAddress: draftOrder.shipping_address
           ? [draftOrder.shipping_address.address1, draftOrder.shipping_address.address2].filter(Boolean).join(', ') || null
           : null,
         contactName: customerName || undefined,
         contactPhone: phone || undefined,
       })

       return { success: true }
     } catch (error) {
       console.error('Error processing Shopify draft order:', error)
       await updateWebhookEvent(supabase, integration.id, webhookId, 'failed', error instanceof Error ? error.message : 'Unknown error')
       return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
     }
   }
   ```

   CRITICAL: For the `ShopifyDraftOrderWebhook` type, the `status` field (not financial_status) is used. The `extractPhoneFromOrder` function needs a type cast since it expects ShopifyOrderWebhook -- use `as unknown as ShopifyOrderWebhook` since the phone extraction fields (customer.phone, shipping_address.phone, phone) are shared.

   IMPORTANT: draft_orders NEVER auto-create CRM records -- they ONLY emit triggers. The user configures what to do via automations (per CONTEXT.md: "Draft orders emiten trigger y el usuario configura que hacer via automatizaciones").
  </action>
  <verify>`npx tsc --noEmit 2>&1 | grep "webhook-handler\|shopify/route"` -- no type errors in these files. `grep 'processShopifyOrderUpdated' src/lib/shopify/webhook-handler.ts` and `grep 'processShopifyDraftOrder' src/lib/shopify/webhook-handler.ts` both find the functions.</verify>
  <done>Shopify webhook handles 3 topics. orders/create respects auto_sync toggle (default true = backward compatible). All 3 topics emit corresponding Shopify triggers. Draft orders always go through automations only.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit 2>&1 | grep "shopify"` -- no errors in shopify files
- `grep 'emitShopify' src/lib/shopify/webhook-handler.ts | wc -l` -- at least 3 calls
- `grep 'auto_sync_orders' src/lib/shopify/webhook-handler.ts` -- toggle check present
- `grep 'draft_orders/create' src/app/api/webhooks/shopify/route.ts` -- topic handled
- `grep 'orders/updated' src/app/api/webhooks/shopify/route.ts` -- topic handled
</verification>

<success_criteria>
- orders/create with auto_sync=true: creates CRM records AND emits trigger (backward compatible)
- orders/create with auto_sync=false: only emits trigger
- orders/updated: emits trigger with order data, looks up existing MorfX order
- draft_orders/create: emits trigger with draft-specific data, no CRM creation
- All responses return 200 (Shopify webhook requirement)
- Duplicate webhook detection works for all 3 topics
</success_criteria>

<output>
After completion, create `.planning/phases/20-integration-automations/20-04-SUMMARY.md`
</output>
