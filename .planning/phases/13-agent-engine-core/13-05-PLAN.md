---
phase: 13-agent-engine-core
plan: 05
type: execute
wave: 4
depends_on: ["13-02", "13-03", "13-04"]
files_modified:
  - src/lib/agents/engine.ts
  - src/lib/agents/index.ts
autonomous: true

must_haves:
  truths:
    - "Engine can process a customer message end-to-end"
    - "Engine coordinates Intent Detector and Orchestrator"
    - "Engine executes tools via Action DSL and returns results"
    - "Engine handles version conflicts with retry logic"
    - "Token budget is checked before each Claude call"
    - "Engine emits Inngest events for timer workflows"
  artifacts:
    - path: "src/lib/agents/engine.ts"
      provides: "AgentEngine class with processMessage method"
      exports: ["AgentEngine"]
      min_lines: 200
  key_links:
    - from: "src/lib/agents/engine.ts"
      to: "src/lib/agents/intent-detector.ts"
      via: "IntentDetector.detect call"
      pattern: "this\\.intentDetector\\.detect"
    - from: "src/lib/agents/engine.ts"
      to: "src/lib/agents/orchestrator.ts"
      via: "Orchestrator.orchestrate call"
      pattern: "this\\.orchestrator\\.orchestrate"
    - from: "src/lib/agents/engine.ts"
      to: "src/lib/tools/executor.ts"
      via: "executeToolFromAgent call"
      pattern: "executeToolFromAgent"
    - from: "src/lib/agents/engine.ts"
      to: "src/inngest/client.ts"
      via: "inngest.send for timer events"
      pattern: "inngest\\.send"
---

<objective>
Create the main Agent Engine that orchestrates all components.

Purpose: The AgentEngine is the main entry point for processing customer messages. It coordinates the Intent Detector, Orchestrator, Session Manager, and Action DSL tool execution into a coherent flow with proper error handling and retry logic.

Output: AgentEngine class with processMessage method that returns AgentResponse.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-agent-engine-core/13-CONTEXT.md
@.planning/phases/13-agent-engine-core/13-RESEARCH.md
@.planning/phases/13-agent-engine-core/13-01-SUMMARY.md
@.planning/phases/13-agent-engine-core/13-02-SUMMARY.md
@.planning/phases/13-agent-engine-core/13-03-SUMMARY.md
@.planning/phases/13-agent-engine-core/13-04-SUMMARY.md

# All agent components
@src/lib/agents/types.ts
@src/lib/agents/errors.ts
@src/lib/agents/session-manager.ts
@src/lib/agents/claude-client.ts
@src/lib/agents/token-budget.ts
@src/lib/agents/intent-detector.ts
@src/lib/agents/orchestrator.ts

# Tool executor from Phase 12
@src/lib/tools/executor.ts

# Inngest client for event emission (will be created by Plan 13-06)
# Note: Engine imports inngest lazily or via injection to avoid circular deps
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Agent Engine</name>
  <files>src/lib/agents/engine.ts</files>
  <action>
Create the AgentEngine class that ties everything together:

```typescript
/**
 * Agent Engine
 * Phase 13: Agent Engine Core
 *
 * Main engine for processing customer messages.
 * Coordinates Intent Detector, Orchestrator, Session Manager,
 * Token Budget, and Action DSL tool execution.
 *
 * Flow:
 * 1. Load session (with version for optimistic locking)
 * 2. Check token budget
 * 3. Get conversation history
 * 4. Detect intent (fast, with Haiku)
 * 5. Record user turn
 * 6. Emit agent/customer.message event (for timer cancellation)
 * 7. Route based on confidence (handoff/clarify/proceed)
 * 8. Orchestrate response (with Sonnet, tools available)
 * 9. Execute tools if requested
 * 10. Update session state with version check
 * 11. Emit mode transition events (collecting_data.started, promos.offered)
 * 12. Record assistant turn
 * 13. Return response
 */

import { agentRegistry } from './registry'
import { SessionManager, type CreateSessionParams } from './session-manager'
import { ClaudeClient } from './claude-client'
import { TokenBudgetManager } from './token-budget'
import { IntentDetector } from './intent-detector'
import { Orchestrator } from './orchestrator'
import {
  VersionConflictError,
  BudgetExceededError,
  AgentNotFoundError,
  SessionError,
} from './errors'
import type {
  AgentConfig,
  AgentResponse,
  AgentSession,
  AgentSessionWithState,
  ClaudeMessage,
  IntentResult,
  ProcessMessageInput,
  SessionState,
  ToolExecutionResult,
  TurnToolCall,
} from './types'
import { executeToolFromAgent } from '@/lib/tools/executor'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('agent-engine')

/** Maximum retries for version conflicts */
const MAX_VERSION_CONFLICT_RETRIES = 3

/** Estimated tokens per Claude call (for budget pre-check) */
const ESTIMATED_TOKENS_PER_CALL = 2000

/**
 * Agent Engine - Main entry point for message processing.
 *
 * Usage:
 * ```typescript
 * const engine = new AgentEngine()
 *
 * const response = await engine.processMessage({
 *   sessionId: 'session-uuid',
 *   conversationId: 'conversation-uuid',
 *   contactId: 'contact-uuid',
 *   messageContent: 'Hola, cuanto cuesta?',
 *   workspaceId: 'workspace-uuid',
 * })
 * ```
 */
export class AgentEngine {
  private sessionManager: SessionManager
  private claudeClient: ClaudeClient
  private tokenBudget: TokenBudgetManager
  private intentDetector: IntentDetector
  private orchestrator: Orchestrator

  constructor(options?: {
    sessionManager?: SessionManager
    claudeClient?: ClaudeClient
    tokenBudget?: TokenBudgetManager
    intentDetector?: IntentDetector
    orchestrator?: Orchestrator
  }) {
    this.sessionManager = options?.sessionManager ?? new SessionManager()
    this.claudeClient = options?.claudeClient ?? new ClaudeClient()
    this.tokenBudget = options?.tokenBudget ?? new TokenBudgetManager()
    this.intentDetector = options?.intentDetector ?? new IntentDetector(this.claudeClient)
    this.orchestrator = options?.orchestrator ?? new Orchestrator(this.claudeClient)
  }

  // ============================================================================
  // Main Entry Point
  // ============================================================================

  /**
   * Process a customer message.
   *
   * This is the main entry point. Handles the full flow:
   * intent detection -> orchestration -> tool execution -> response
   *
   * @param input Message and context
   * @returns Agent response with optional tool results
   * @throws BudgetExceededError if token budget is exceeded
   * @throws AgentNotFoundError if agent is not registered
   */
  async processMessage(input: ProcessMessageInput): Promise<AgentResponse> {
    return this.processMessageWithRetry(input, 0)
  }

  /**
   * Process message with retry logic for version conflicts.
   */
  private async processMessageWithRetry(
    input: ProcessMessageInput,
    retryCount: number
  ): Promise<AgentResponse> {
    logger.info(
      {
        sessionId: input.sessionId,
        messageLength: input.messageContent.length,
        retryCount,
      },
      'Processing message'
    )

    try {
      // 1. Load session with current version
      const session = await this.sessionManager.getSession(input.sessionId)
      const agentConfig = agentRegistry.get(session.agent_id)
      const previousMode = session.current_mode

      // 2. Check token budget
      const budgetCheck = await this.tokenBudget.checkBudget(
        input.sessionId,
        ESTIMATED_TOKENS_PER_CALL * 2  // Intent + Orchestrator
      )
      if (!budgetCheck.allowed) {
        throw new BudgetExceededError(
          input.sessionId,
          budgetCheck.used,
          budgetCheck.used + budgetCheck.remaining
        )
      }

      // 3. Get conversation history
      const history = await this.buildConversationHistory(input.sessionId)
      const turnNumber = history.length + 1

      // 4. Detect intent
      const { intent, action, tokensUsed: intentTokens } = await this.intentDetector.detect(
        input.messageContent,
        history,
        {
          systemPrompt: agentConfig.intentDetector.systemPrompt,
          model: agentConfig.intentDetector.model,
          thresholds: agentConfig.confidenceThresholds,
        }
      )

      // 5. Record user turn
      const userTurn = await this.sessionManager.addTurn({
        sessionId: input.sessionId,
        turnNumber,
        role: 'user',
        content: input.messageContent,
        intentDetected: intent.intent,
        confidence: intent.confidence,
        tokensUsed: intentTokens,
      })

      // 6. Emit agent/customer.message event for timer cancellation
      await this.emitCustomerMessageEvent(input, session)

      // 7. Update intents_vistos
      await this.sessionManager.addIntentSeen(input.sessionId, intent.intent)

      // 8. Handle handoff action
      if (action === 'handoff') {
        const response = await this.handleHandoff(session, intent)
        await this.recordAssistantTurn(input.sessionId, turnNumber + 1, response, [])
        return response
      }

      // 9. Handle clarify action
      if (action === 'clarify') {
        const response = await this.handleClarification(session, intent)
        await this.recordAssistantTurn(input.sessionId, turnNumber + 1, response, [])
        return response
      }

      // 10. Orchestrate response
      const { result: orchestratorResult, tokensUsed: orchestratorTokens } =
        await this.orchestrator.orchestrate(
          {
            intent,
            action,
            message: input.messageContent,
            history,
            sessionState: session.state,
            currentMode: session.current_mode,
          },
          {
            systemPrompt: agentConfig.orchestrator.systemPrompt,
            model: agentConfig.orchestrator.model,
            tools: agentConfig.tools,
          }
        )

      // 11. Execute tools if requested
      let toolResults: ToolExecutionResult[] = []
      let toolCalls: TurnToolCall[] = []
      if (orchestratorResult.action === 'execute_tool' && orchestratorResult.toolCalls) {
        const execution = await this.executeTools(
          orchestratorResult.toolCalls,
          input.workspaceId,
          input.sessionId
        )
        toolResults = execution.results
        toolCalls = execution.calls
      }

      // 12. Update session state with version check
      const newMode = orchestratorResult.nextMode ?? session.current_mode
      const newState = this.computeNewState(session.state, intent, toolResults)
      try {
        await this.sessionManager.updateSessionWithVersion(
          input.sessionId,
          session.version,
          {
            currentMode: newMode,
            lastActivityAt: new Date().toISOString(),
          }
        )
        await this.sessionManager.updateState(input.sessionId, newState)
      } catch (error) {
        if (error instanceof VersionConflictError) {
          if (retryCount < MAX_VERSION_CONFLICT_RETRIES) {
            logger.warn(
              { sessionId: input.sessionId, retryCount },
              'Version conflict, retrying'
            )
            return this.processMessageWithRetry(input, retryCount + 1)
          }
          throw error
        }
        throw error
      }

      // 13. Emit mode transition events for timer workflows
      await this.emitModeTransitionEvent(input, previousMode, newMode)

      // 14. Record assistant turn
      await this.sessionManager.addTurn({
        sessionId: input.sessionId,
        turnNumber: turnNumber + 1,
        role: 'assistant',
        content: orchestratorResult.response ?? '',
        toolsCalled: toolCalls,
        tokensUsed: orchestratorTokens,
      })

      logger.info(
        {
          sessionId: input.sessionId,
          intent: intent.intent,
          action: orchestratorResult.action,
          toolCallCount: toolCalls.length,
          totalTokens: intentTokens + orchestratorTokens,
        },
        'Message processed successfully'
      )

      return {
        response: orchestratorResult.response ?? null,
        toolResults,
        sessionUpdated: true,
        intent,
        nextMode: orchestratorResult.nextMode,
        handedOff: false,
      }
    } catch (error) {
      if (error instanceof VersionConflictError && retryCount < MAX_VERSION_CONFLICT_RETRIES) {
        logger.warn({ sessionId: input.sessionId, retryCount }, 'Version conflict, retrying')
        return this.processMessageWithRetry(input, retryCount + 1)
      }
      throw error
    }
  }

  // ============================================================================
  // Inngest Event Emission
  // ============================================================================

  /**
   * Emit agent/customer.message event when user turn is recorded.
   * This allows timer workflows to cancel pending timeouts.
   */
  private async emitCustomerMessageEvent(
    input: ProcessMessageInput,
    session: AgentSessionWithState
  ): Promise<void> {
    try {
      // Dynamic import to avoid circular dependency
      const { inngest } = await import('@/inngest/client')

      await inngest.send({
        name: 'agent/customer.message',
        data: {
          sessionId: input.sessionId,
          conversationId: input.conversationId,
          messageId: `turn-${Date.now()}`, // Placeholder - actual message ID from webhook
          content: input.messageContent,
        },
      })

      logger.debug({ sessionId: input.sessionId }, 'Emitted agent/customer.message event')
    } catch (error) {
      // Non-critical - log but don't fail message processing
      logger.warn({ error, sessionId: input.sessionId }, 'Failed to emit customer.message event')
    }
  }

  /**
   * Emit mode transition events when session mode changes.
   * Triggers timer workflows for collecting_data and ofrecer_promos modes.
   */
  private async emitModeTransitionEvent(
    input: ProcessMessageInput,
    previousMode: string,
    newMode: string
  ): Promise<void> {
    // Only emit if mode actually changed
    if (previousMode === newMode) return

    try {
      // Dynamic import to avoid circular dependency
      const { inngest } = await import('@/inngest/client')

      // Emit collecting_data.started when transitioning TO collecting_data
      if (newMode === 'collecting_data' && previousMode !== 'collecting_data') {
        await inngest.send({
          name: 'agent/collecting_data.started',
          data: {
            sessionId: input.sessionId,
            conversationId: input.conversationId,
            workspaceId: input.workspaceId,
          },
        })
        logger.info({ sessionId: input.sessionId }, 'Emitted agent/collecting_data.started event')
      }

      // Emit promos.offered when transitioning TO ofrecer_promos
      if (newMode === 'ofrecer_promos' && previousMode !== 'ofrecer_promos') {
        await inngest.send({
          name: 'agent/promos.offered',
          data: {
            sessionId: input.sessionId,
            conversationId: input.conversationId,
            workspaceId: input.workspaceId,
            packOptions: ['1x', '2x', '3x'], // Default pack options
          },
        })
        logger.info({ sessionId: input.sessionId }, 'Emitted agent/promos.offered event')
      }
    } catch (error) {
      // Non-critical - log but don't fail message processing
      logger.warn({ error, sessionId: input.sessionId, newMode }, 'Failed to emit mode transition event')
    }
  }

  // ============================================================================
  // Session Management
  // ============================================================================

  /**
   * Create a new session for a conversation.
   */
  async createSession(params: CreateSessionParams): Promise<AgentSessionWithState> {
    // Verify agent exists
    if (!agentRegistry.has(params.agentId)) {
      throw new AgentNotFoundError(params.agentId)
    }

    return this.sessionManager.createSession(params)
  }

  /**
   * Get or create session for a conversation.
   * Returns existing active session or creates new one.
   */
  async getOrCreateSession(
    agentId: string,
    conversationId: string,
    contactId: string,
    workspaceId: string
  ): Promise<AgentSessionWithState> {
    // Try to find existing active session
    const existing = await this.sessionManager.getSessionByConversation(
      conversationId,
      agentId
    )

    if (existing) {
      return existing
    }

    // Create new session
    return this.createSession({
      agentId,
      conversationId,
      contactId,
      workspaceId,
    })
  }

  /**
   * Close a session.
   */
  async closeSession(sessionId: string): Promise<void> {
    const session = await this.sessionManager.getSession(sessionId)
    await this.sessionManager.closeSession(sessionId, session.version)
    logger.info({ sessionId }, 'Session closed')
  }

  /**
   * Hand off session to human agent.
   */
  async handoffSession(sessionId: string): Promise<void> {
    const session = await this.sessionManager.getSession(sessionId)
    await this.sessionManager.handoffSession(sessionId, session.version)
    logger.info({ sessionId }, 'Session handed off to human')
  }

  // ============================================================================
  // Private Helpers
  // ============================================================================

  /**
   * Build conversation history from turns.
   */
  private async buildConversationHistory(sessionId: string): Promise<ClaudeMessage[]> {
    const turns = await this.sessionManager.getTurns(sessionId)

    return turns
      .filter((turn) => turn.role !== 'system')
      .map((turn) => ({
        role: turn.role as 'user' | 'assistant',
        content: turn.content,
      }))
  }

  /**
   * Execute tools via Action DSL.
   */
  private async executeTools(
    toolCalls: Array<{ name: string; input: Record<string, unknown> }>,
    workspaceId: string,
    sessionId: string
  ): Promise<{
    results: ToolExecutionResult[]
    calls: TurnToolCall[]
  }> {
    const results: ToolExecutionResult[] = []
    const calls: TurnToolCall[] = []

    for (const call of toolCalls) {
      try {
        const result = await executeToolFromAgent(
          call.name,
          call.input,
          workspaceId,
          sessionId
        )

        results.push({
          name: call.name,
          success: result.success,
          data: result.success ? result.outputs : undefined,
          error: !result.success
            ? {
                code: result.error?.code ?? 'UNKNOWN',
                message: result.error?.message ?? 'Unknown error',
                retryable: result.error?.retryable ?? false,
              }
            : undefined,
        })

        calls.push({
          name: call.name,
          input: call.input,
          result: result.outputs,
          success: result.success,
        })

        logger.debug(
          { tool: call.name, success: result.success },
          'Tool executed'
        )
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error'
        results.push({
          name: call.name,
          success: false,
          error: {
            code: 'EXECUTION_ERROR',
            message: errorMessage,
            retryable: false,
          },
        })
        calls.push({
          name: call.name,
          input: call.input,
          result: { error: errorMessage },
          success: false,
        })
        logger.error({ tool: call.name, error: errorMessage }, 'Tool execution failed')
      }
    }

    return { results, calls }
  }

  /**
   * Handle handoff to human agent.
   */
  private async handleHandoff(
    session: AgentSessionWithState,
    intent: IntentResult
  ): Promise<AgentResponse> {
    await this.sessionManager.handoffSession(session.id, session.version)

    return {
      response: 'Voy a transferirte con un asesor humano para atenderte mejor. Un momento por favor.',
      toolResults: [],
      sessionUpdated: true,
      intent,
      handedOff: true,
    }
  }

  /**
   * Handle clarification request.
   */
  private async handleClarification(
    session: AgentSessionWithState,
    intent: IntentResult
  ): Promise<AgentResponse> {
    let response: string

    if (intent.alternatives && intent.alternatives.length > 0) {
      const alt = intent.alternatives[0]
      response = `Disculpa, no estoy seguro si te refieres a ${intent.intent} o a ${alt.intent}. ¿Podrias ser mas especifico?`
    } else {
      response = 'Disculpa, no entendi bien tu mensaje. ¿Podrias explicarme con mas detalle?'
    }

    return {
      response,
      toolResults: [],
      sessionUpdated: false,
      intent,
      handedOff: false,
    }
  }

  /**
   * Compute new session state after processing.
   */
  private computeNewState(
    currentState: SessionState,
    intent: IntentResult,
    toolResults: ToolExecutionResult[]
  ): Partial<SessionState> {
    const updates: Partial<SessionState> = {}

    // Extract captured data from tool results
    const contactCreateResult = toolResults.find(
      (r) => r.name === 'crm.contact.create' && r.success
    )
    if (contactCreateResult?.data && typeof contactCreateResult.data === 'object') {
      const data = contactCreateResult.data as Record<string, unknown>
      const newData: Record<string, string> = {}
      if (data.name) newData.nombre = String(data.name)
      if (data.phone) newData.telefono = String(data.phone)
      if (data.city) newData.ciudad = String(data.city)
      if (data.address) newData.direccion = String(data.address)

      if (Object.keys(newData).length > 0) {
        updates.datos_capturados = {
          ...currentState.datos_capturados,
          ...newData,
        }
      }
    }

    // Check for order creation
    const orderCreateResult = toolResults.find(
      (r) => r.name === 'crm.order.create' && r.success
    )
    if (orderCreateResult) {
      // Could extract order details if needed
    }

    return updates
  }

  /**
   * Record an assistant turn.
   */
  private async recordAssistantTurn(
    sessionId: string,
    turnNumber: number,
    response: AgentResponse,
    toolCalls: TurnToolCall[]
  ): Promise<void> {
    await this.sessionManager.addTurn({
      sessionId,
      turnNumber,
      role: 'assistant',
      content: response.response ?? '',
      toolsCalled: toolCalls,
      tokensUsed: 0,
    })
  }
}
```

Key implementation notes:
- processMessage is the main entry point
- Retry logic for version conflicts (up to 3 retries)
- Token budget checked before Claude calls
- Intent detection uses fast model (Haiku)
- Orchestration uses capable model (Sonnet)
- Tools executed via executeToolFromAgent from Phase 12
- State updates computed from tool results
- Session updates use optimistic locking
- **NEW: Inngest event emission for timer workflows:**
  - `agent/customer.message` emitted after user turn recorded (cancels pending timeouts)
  - `agent/collecting_data.started` emitted when transitioning to collecting_data mode
  - `agent/promos.offered` emitted when transitioning to ofrecer_promos mode
  - Dynamic import of inngest client to avoid circular dependencies
  - Non-critical: failures logged but don't stop message processing
  </action>
  <verify>
TypeScript compilation:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/engine.ts
```
Check main method:
```bash
grep "async processMessage" src/lib/agents/engine.ts
```
Verify tool execution:
```bash
grep "executeToolFromAgent" src/lib/agents/engine.ts
```
Verify version conflict handling:
```bash
grep "VersionConflictError" src/lib/agents/engine.ts
```
Verify Inngest event emission:
```bash
grep "inngest.send" src/lib/agents/engine.ts
```
Verify mode transition events:
```bash
grep -E "collecting_data.started|promos.offered" src/lib/agents/engine.ts
```
  </verify>
  <done>
- AgentEngine class with processMessage method
- Full flow: intent detection -> orchestration -> tool execution -> response
- Version conflict retry logic (max 3 retries)
- Token budget checking before Claude calls
- Session management: createSession, getOrCreateSession, closeSession, handoffSession
- Tool execution via executeToolFromAgent from Phase 12
- State updates computed from tool results
- Proper error handling and logging
- **Inngest event emission:**
  - emitCustomerMessageEvent: emits agent/customer.message after user turn
  - emitModeTransitionEvent: emits agent/collecting_data.started and agent/promos.offered on mode changes
  - Dynamic import to avoid circular dependencies
  - Non-blocking: failures don't stop message processing
  </done>
</task>

<task type="auto">
  <name>Task 2: Update index.ts exports</name>
  <files>src/lib/agents/index.ts</files>
  <action>
Update src/lib/agents/index.ts to export the AgentEngine:

```typescript
/**
 * Agent Engine Module
 * Phase 13: Agent Engine Core
 *
 * Public exports for the agent system.
 */

// Types
export * from './types'

// Errors
export * from './errors'

// Registry
export { AgentRegistry, agentRegistry } from './registry'

// Session Manager
export { SessionManager } from './session-manager'
export type { CreateSessionParams, AddTurnParams, UpdateSessionParams } from './session-manager'

// Claude Client
export { ClaudeClient } from './claude-client'

// Token Budget
export { TokenBudgetManager } from './token-budget'
export type { BudgetCheckResult } from './token-budget'

// Intent Detector
export { IntentDetector, DEFAULT_INTENT_PROMPT } from './intent-detector'
export type { IntentDetectionResult } from './intent-detector'

// Orchestrator
export { Orchestrator, DEFAULT_ORCHESTRATOR_PROMPT } from './orchestrator'
export type { OrchestrationInput, OrchestrationOutput } from './orchestrator'

// Agent Engine
export { AgentEngine } from './engine'
```
  </action>
  <verify>
Check all exports present:
```bash
grep -E "^export" src/lib/agents/index.ts | wc -l
```
Should be at least 12 export lines.

TypeScript compilation of full module:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/index.ts
```
  </verify>
  <done>
- All agent module exports in index.ts
- AgentEngine exported as main entry point
- Clean import path: `import { AgentEngine, agentRegistry } from '@/lib/agents'`
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. AgentEngine exports verified:
```bash
grep "export.*AgentEngine" src/lib/agents/index.ts
```

2. Main flow methods exist:
```bash
grep -E "async (processMessage|createSession|getOrCreateSession)" src/lib/agents/engine.ts
```

3. Integration with Phase 12 executor:
```bash
grep "import.*executeToolFromAgent" src/lib/agents/engine.ts
```

4. Version conflict handling:
```bash
grep -c "VersionConflictError" src/lib/agents/engine.ts
```
Should be at least 3 occurrences.

5. Inngest event emission:
```bash
grep -c "inngest.send" src/lib/agents/engine.ts
```
Should be at least 3 occurrences (customer.message, collecting_data.started, promos.offered).

6. TypeScript compiles:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit
```
</verification>

<success_criteria>
- AgentEngine.processMessage handles full message flow
- Intent detection uses IntentDetector component
- Orchestration uses Orchestrator component
- Tools executed via executeToolFromAgent from Phase 12
- Version conflicts trigger retry (up to 3 times)
- Token budget checked before Claude calls
- Session create/get/close/handoff operations work
- Inngest events emitted for timer workflows:
  - agent/customer.message after user turn
  - agent/collecting_data.started on mode transition
  - agent/promos.offered on mode transition
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-agent-engine-core/13-05-SUMMARY.md`
</output>
