---
phase: 16.1-engine-unification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/agents/engine/types.ts
  - src/lib/agents/engine/index.ts
autonomous: true

must_haves:
  truths:
    - "Plan 02 (SomnioAgent) can import and use StorageAdapter, TimerAdapter, EngineAdapters etc. without type errors"
    - "Plan 03 (Adapters) can implement all 5 interfaces without needing to add methods not in the interface"
    - "Plan 04 (UnifiedEngine) can accept EngineInput and return EngineOutput covering all sandbox and production fields"
    - "A sandbox mock session and a production DB session both satisfy AgentSessionLike without casting"
  artifacts:
    - path: "src/lib/agents/engine/types.ts"
      provides: "All adapter interfaces, engine types, and shared state shapes"
      contains: "StorageAdapter, TimerAdapter, MessagingAdapter, OrdersAdapter, DebugAdapter"
    - path: "src/lib/agents/engine/index.ts"
      provides: "Barrel exports for engine module"
  key_links:
    - from: "src/lib/agents/engine/types.ts"
      to: "src/lib/agents/types.ts"
      via: "imports SessionState, PackSelection, IntentRecord, ModelTokenEntry, ClaudeModel"
      pattern: "import.*from.*agents/types"
    - from: "src/lib/agents/engine/types.ts"
      to: "src/lib/sandbox/types.ts"
      via: "imports TimerSignal, DebugTurn, IngestStatus, ToolExecution"
      pattern: "import.*from.*sandbox/types"
---

<objective>
Define all TypeScript interfaces for the unified engine: 5 adapter ports, engine input/output, config, and shared state shapes.

Purpose: This is the foundation that all other plans depend on. Every adapter implementation, the engine, and both wiring plans need these types.
Output: `src/lib/agents/engine/types.ts` with all interfaces, `src/lib/agents/engine/index.ts` barrel.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/16.1-engine-unification/16.1-CONTEXT.md
@.planning/phases/16.1-engine-unification/16.1-RESEARCH.md

Key source files to reference:
@src/lib/agents/types.ts (SessionState, AgentSession, PackSelection, IntentRecord, ModelTokenEntry)
@src/lib/sandbox/types.ts (TimerSignal, DebugTurn, IngestStatus, ToolExecution, SandboxState, SandboxEngineResult)
@src/lib/agents/somnio/somnio-engine.ts (SomnioProcessMessageInput, SomnioEngineResult)
@src/lib/sandbox/sandbox-engine.ts (processMessage signature and return type)
@src/lib/agents/session-manager.ts (AgentSessionWithState interface)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create adapter interfaces and engine types</name>
  <files>src/lib/agents/engine/types.ts</files>
  <action>
Create `src/lib/agents/engine/types.ts` with the following types, derived from the research document and the actual source code:

**1. AgentSessionLike** — Shared session shape that both sandbox in-memory state and production DB session can satisfy. Must include:
- `id`, `agent_id`, `conversation_id`, `contact_id`, `workspace_id`, `version`, `status`, `current_mode`
- `state: SessionState` (import from `../types`)
- This is compatible with the existing `AgentSessionWithState` from session-manager (production uses that directly, sandbox builds a mock that matches this shape)

**2. EngineInput** — Input for processMessage:
- `sessionId: string`
- `conversationId: string`
- `contactId: string`
- `message: string`
- `workspaceId: string`
- `history: { role: 'user' | 'assistant'; content: string }[]`
- `forceIntent?: string`
- `turnNumber?: number`
- `phoneNumber?: string` (for production messaging)

**3. EngineOutput** — Unified output:
- `success: boolean`
- `messages: string[]`
- `newState?: any` (opaque to engine — sandbox returns SandboxState, production doesn't need it)
- `debugTurn?: any` (opaque to engine — sandbox returns DebugTurn, production doesn't need it)
- `timerSignal?: TimerSignal` (sandbox timer simulator consumes this)
- `orderCreated?: boolean`
- `orderId?: string`
- `contactId?: string`
- `newMode?: string`
- `tokensUsed?: number`
- `sessionId?: string`
- `messagesSent?: number`
- `response?: string` (for production backward compat with SomnioEngineResult)
- `error?: { code: string; message: string; retryable?: boolean }`

**4. EngineConfig** — Per-environment configuration:
- `workspaceId: string`
- `timerDurations?: Record<number, number>` (level -> seconds)
- `responseSpeed?: number` (multiplier)
- `crmModes?: Array<{ agentId: string; mode: 'dry-run' | 'live' }>`

**5. EngineAdapters** — Bundle of all 5 adapters:
```typescript
interface EngineAdapters {
  storage: StorageAdapter
  timer: TimerAdapter
  messaging: MessagingAdapter
  orders: OrdersAdapter
  debug: DebugAdapter
}
```

**6. StorageAdapter interface:**
- `getSession(sessionId: string): Promise<AgentSessionLike>`
- `getOrCreateSession(conversationId: string, contactId: string): Promise<AgentSessionLike>`
- `getHistory(sessionId: string): Promise<{ role: 'user' | 'assistant'; content: string }[]>`
- `saveState(sessionId: string, updates: Record<string, unknown>): Promise<void>`
- `updateMode(sessionId: string, version: number, newMode: string): Promise<void>`
- `addTurn(params: { sessionId: string; turnNumber: number; role: 'user' | 'assistant'; content: string; intentDetected?: string; confidence?: number; tokensUsed?: number }): Promise<void>`
- `addIntentSeen(sessionId: string, intent: string): Promise<void>`
- `handoff(sessionId: string, version: number): Promise<void>`

**7. TimerAdapter interface:**
- `signal(signal: TimerSignal): void` — Accumulate or emit timer signal
- `onCustomerMessage?(sessionId: string, conversationId: string, content: string): Promise<void>` — Production Inngest event
- `onModeTransition?(sessionId: string, previousMode: string, newMode: string): Promise<void>` — Production Inngest event
- `onIngestStarted?(session: AgentSessionLike, hasPartialData: boolean): Promise<void>` — Production Inngest event
- `onIngestCompleted?(sessionId: string, reason: string): Promise<void>` — Production Inngest event
- `getLastSignal(): TimerSignal | undefined` — For sandbox result

**8. MessagingAdapter interface:**
- `send(params: { sessionId: string; conversationId: string; messages: string[]; templates?: any[]; intent?: string; workspaceId: string; contactId?: string; phoneNumber?: string }): Promise<{ messagesSent: number }>`

**9. OrdersAdapter interface:**
- `createOrder(data: { datosCapturados: Record<string, string>; packSeleccionado: any; workspaceId: string; sessionId: string }, mode?: 'dry-run' | 'live'): Promise<{ success: boolean; orderId?: string; contactId?: string; toolCalls?: any[]; tokensUsed?: any[]; error?: { message: string } }>`

**10. DebugAdapter interface:**
- `recordIntent(info: any): void`
- `recordTools(tools: any[]): void`
- `recordTokens(tokens: any): void`
- `recordState(state: any): void`
- `getDebugTurn(turnNumber: number): any | undefined`

Use imports from `../types` for `SessionState`, `PackSelection`, `IntentRecord`, `ModelTokenEntry`, `AgentSession`.
Use imports from `../../sandbox/types` for `TimerSignal`.

IMPORTANT: Use generous `any` types for debug-related fields that are sandbox-specific (DebugTurn, ToolExecution, etc.) to keep the engine types environment-agnostic. The adapters will use specific types internally.

Add JSDoc comments on each interface explaining which environments implement them and the key behavioral difference.
  </action>
  <verify>Run `npx tsc --noEmit` — types.ts compiles with no errors. All imports resolve correctly.</verify>
  <done>All 5 adapter interfaces, EngineInput, EngineOutput, EngineConfig, EngineAdapters, and AgentSessionLike are defined and compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create barrel export</name>
  <files>src/lib/agents/engine/index.ts</files>
  <action>
Create `src/lib/agents/engine/index.ts` that re-exports all types from `./types`:

```typescript
export type {
  EngineInput,
  EngineOutput,
  EngineConfig,
  EngineAdapters,
  AgentSessionLike,
  StorageAdapter,
  TimerAdapter,
  MessagingAdapter,
  OrdersAdapter,
  DebugAdapter,
} from './types'
```

This barrel will also export `UnifiedEngine` in Plan 04 when the class is created. For now, only types.
  </action>
  <verify>Run `npx tsc --noEmit` — barrel compiles and all exports are valid.</verify>
  <done>Barrel file exports all engine types. Other plans can import from `../engine` or `@/lib/agents/engine`.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 5 adapter interfaces are present in types.ts with documented methods
3. EngineInput covers all fields from both SandboxEngine.processMessage and SomnioEngine.processMessage
4. EngineOutput covers all fields from both SandboxEngineResult and SomnioEngineResult
5. AgentSessionLike is structurally compatible with AgentSessionWithState (production) and sandbox mock session
</verification>

<success_criteria>
- 5 adapter interfaces defined with correct signatures
- Engine types (Input, Output, Config, Adapters) cover both environments
- All types compile without errors
- Barrel exports all public types
</success_criteria>

<output>
After completion, create `.planning/phases/16.1-engine-unification/16.1-01-SUMMARY.md`
</output>
