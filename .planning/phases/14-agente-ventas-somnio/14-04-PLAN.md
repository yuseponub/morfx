---
phase: 14-agente-ventas-somnio
plan: 04
type: execute
wave: 3
depends_on: ["14-03"]
files_modified:
  - src/lib/agents/somnio/message-sequencer.ts
  - src/lib/agents/somnio/interruption-handler.ts
  - src/lib/agents/somnio/index.ts
  - src/inngest/functions/agent-timers.ts
autonomous: true

must_haves:
  truths:
    - "Messages are sent with configurable delays (0-5 seconds)"
    - "Incoming customer message during sequence aborts remaining messages"
    - "Pending messages are remembered and can be resumed"
    - "Interruption prioritizes new response, then appends pending"
  artifacts:
    - path: "src/lib/agents/somnio/message-sequencer.ts"
      provides: "MessageSequencer class for delayed message sending with abort capability"
      exports: ["MessageSequencer", "MessageSequence", "SequenceStatus"]
    - path: "src/lib/agents/somnio/interruption-handler.ts"
      provides: "InterruptionHandler for detecting and managing sequence interruptions"
      exports: ["InterruptionHandler", "InterruptionResult"]
  key_links:
    - from: "src/lib/agents/somnio/message-sequencer.ts"
      to: "src/inngest/functions/agent-timers.ts"
      via: "step.sleep for delays between messages"
      pattern: "step\\.sleep"
    - from: "src/lib/agents/somnio/message-sequencer.ts"
      to: "whatsapp.message.send handler"
      via: "executeToolFromAgent"
      pattern: "whatsapp\\.message\\.send"
---

<objective>
Create Message Sequencer component that handles delayed message sending with interruption detection and abort capability.

Purpose: Somnio agent sends multiple messages per response (e.g., greeting + price + mode of payment). Each has a delay. If customer interrupts, we must abort and remember pending messages.

Output: MessageSequencer for controlled message delivery, InterruptionHandler for detecting customer interruptions.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-agente-ventas-somnio/14-CONTEXT.md
@.planning/phases/14-agente-ventas-somnio/14-03-SUMMARY.md
@src/lib/agents/somnio/template-manager.ts
@src/inngest/functions/agent-timers.ts
@src/lib/tools/executor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Interruption Handler component</name>
  <files>
    src/lib/agents/somnio/interruption-handler.ts
  </files>
  <action>
Create src/lib/agents/somnio/interruption-handler.ts:

1. PendingMessage interface:
```typescript
interface PendingMessage {
  id: string
  content: string
  contentType: 'texto' | 'template' | 'imagen'
  delaySeconds: number
  originalIntent: string
  sequencePosition: number
}
```

2. InterruptionState interface:
```typescript
interface InterruptionState {
  pendingMessages: PendingMessage[]
  interruptedAt: string | null
  originalSequenceId: string | null
}
```

3. InterruptionResult interface:
```typescript
interface InterruptionResult {
  wasInterrupted: boolean
  pendingCount: number
  pendingMessages: PendingMessage[]
  shouldAppendPending: boolean
}
```

4. InterruptionHandler class:
```typescript
export class InterruptionHandler {
  constructor(private sessionManager: SessionManager) {}

  async detectInterruption(
    sessionId: string,
    currentTimestamp: Date
  ): Promise<InterruptionResult>

  async savePendingMessages(
    sessionId: string,
    pending: PendingMessage[]
  ): Promise<void>

  async getPendingMessages(
    sessionId: string
  ): Promise<PendingMessage[]>

  async clearPendingMessages(
    sessionId: string
  ): Promise<void>

  async markInterruption(
    sessionId: string,
    timestamp: Date
  ): Promise<void>
}
```

5. Implementation details:
   - Store pending messages in session_state.datos_capturados with special key: __pending_messages
   - detectInterruption checks if there are pending messages and last_activity_at is recent
   - When interrupted: save remaining messages, mark interruption time
   - When resuming: get pending, clear storage, return for appending
   - shouldAppendPending: true if pending exist and original intent is complementary (not conflicting)
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit
```
TypeScript compiles. InterruptionHandler properly handles pending message state.
  </verify>
  <done>
InterruptionHandler component created for:
- Detecting if customer interrupted a message sequence
- Storing pending messages in session state
- Retrieving and clearing pending messages
- Deciding whether to append pending to new response
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Message Sequencer component</name>
  <files>
    src/lib/agents/somnio/message-sequencer.ts
    src/lib/agents/somnio/index.ts
  </files>
  <action>
Create src/lib/agents/somnio/message-sequencer.ts:

1. MessageToSend interface:
```typescript
interface MessageToSend {
  id: string
  content: string
  contentType: 'texto' | 'template' | 'imagen'
  delaySeconds: number
  metadata?: {
    intent: string
    templateId?: string
    sequencePosition: number
  }
}
```

2. SequenceStatus type:
```typescript
type SequenceStatus = 'pending' | 'sending' | 'completed' | 'aborted' | 'interrupted'
```

3. MessageSequence interface:
```typescript
interface MessageSequence {
  id: string
  sessionId: string
  conversationId: string
  messages: MessageToSend[]
  status: SequenceStatus
  sentCount: number
  startedAt: string | null
  completedAt: string | null
}
```

4. SequenceResult interface:
```typescript
interface SequenceResult {
  sequenceId: string
  messagesSent: number
  messagesAborted: number
  status: SequenceStatus
  pendingMessages?: PendingMessage[]
}
```

5. MessageSequencer class:
```typescript
export class MessageSequencer {
  private interruptionHandler: InterruptionHandler

  constructor(
    private sessionManager: SessionManager,
    interruptionHandler?: InterruptionHandler
  ) {
    this.interruptionHandler = interruptionHandler ?? new InterruptionHandler(sessionManager)
  }

  async executeSequence(
    sequence: MessageSequence,
    workspaceId: string,
    phoneNumber: string,
    onInterruption?: () => Promise<boolean>
  ): Promise<SequenceResult>

  async sendMessage(
    message: MessageToSend,
    workspaceId: string,
    phoneNumber: string
  ): Promise<boolean>

  async checkForInterruption(
    sessionId: string
  ): Promise<boolean>

  buildSequence(
    sessionId: string,
    conversationId: string,
    templates: ProcessedTemplate[],
    intent: string
  ): MessageSequence

  async mergeWithPending(
    newMessages: MessageToSend[],
    sessionId: string
  ): Promise<MessageToSend[]>
}
```

6. Implementation details:
   - executeSequence:
     - For each message in sequence:
       - Wait delay_s seconds (use step.sleep if in Inngest, else setTimeout)
       - Check for interruption before sending
       - If interrupted: save remaining as pending, return early
       - Send message via executeToolFromAgent('whatsapp.message.send', {...})
     - Track sent count and status
   - sendMessage:
     - Call whatsapp.message.send tool with content
     - Handle success/failure
   - checkForInterruption:
     - Check session.last_activity_at vs sequence start time
     - If customer sent message after sequence started, return true
   - mergeWithPending:
     - Get pending from interruptionHandler
     - New messages first, then pending (complementary info)
     - Clear pending after merge

7. For non-Inngest execution:
   - Use simple setTimeout for delays
   - Poll session for activity changes

Update src/lib/agents/somnio/index.ts:
- Export MessageSequencer, MessageSequence, SequenceResult, SequenceStatus
- Export InterruptionHandler, InterruptionResult, PendingMessage
  </action>
  <verify>
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit
```
TypeScript compiles. MessageSequencer handles delays and interruptions.
  </verify>
  <done>
MessageSequencer component created that:
- Sends messages with configurable delays
- Checks for customer interruption before each send
- Aborts sequence and saves pending if interrupted
- Merges pending messages into new response
- Tracks sequence status and sent count
  </done>
</task>

</tasks>

<verification>
1. InterruptionHandler stores/retrieves pending messages correctly
2. MessageSequencer applies delays between messages
3. Interruption detection based on session activity time
4. Sequence aborts when interrupted, saves pending
5. Pending messages merge correctly with new response
6. TypeScript compiles without errors
</verification>

<success_criteria>
- Delays of 0-5 seconds applied between messages
- Customer interruption aborts remaining messages
- Pending messages stored in session state
- New response followed by pending complementary messages
- Sequence tracking with status and counts
</success_criteria>

<output>
After completion, create `.planning/phases/14-agente-ventas-somnio/14-04-SUMMARY.md`
</output>
