---
phase: 06-orders
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/actions/orders.ts
  - src/app/(dashboard)/crm/pedidos/page.tsx
  - src/app/(dashboard)/crm/pedidos/components/orders-table.tsx
  - src/app/(dashboard)/crm/pedidos/components/order-form.tsx
  - src/app/(dashboard)/crm/pedidos/components/columns.tsx
  - src/app/(dashboard)/crm/pedidos/components/product-picker.tsx
  - src/app/(dashboard)/crm/pedidos/components/contact-selector.tsx
autonomous: true

must_haves:
  truths:
    - "User can view list of orders in their workspace"
    - "User can create an order with contact, products, and tracking info"
    - "User can edit and delete orders"
    - "Order total auto-calculates from products"
    - "Orders can have multiple products with quantities"
  artifacts:
    - path: "src/app/actions/orders.ts"
      provides: "Server Actions for order CRUD"
      exports: ["getOrders", "createOrder", "updateOrder", "deleteOrder", "addOrderProduct"]
    - path: "src/app/(dashboard)/crm/pedidos/page.tsx"
      provides: "Orders list page"
    - path: "src/app/(dashboard)/crm/pedidos/components/order-form.tsx"
      provides: "Order creation/edit form with product picker"
  key_links:
    - from: "order-form.tsx"
      to: "product-picker.tsx"
      via: "Product selection for order"
      pattern: "ProductPicker"
    - from: "order-form.tsx"
      to: "actions/orders.ts"
      via: "Server Action to save"
      pattern: "createOrder|updateOrder"
---

<objective>
Create order CRUD with list view, allowing users to create orders with contacts, multiple products, and tracking information.

Purpose: Orders are the core business entity; list view provides table-based management before Kanban
Output: Orders page with table view, forms for create/edit, product picker component
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-orders/06-CONTEXT.md
@.planning/phases/06-orders/06-RESEARCH.md
@.planning/phases/06-orders/06-01-SUMMARY.md
@src/lib/orders/types.ts
@src/app/actions/contacts.ts
@src/app/actions/products.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Server Actions for order CRUD</name>
  <files>src/app/actions/orders.ts</files>
  <action>
Create comprehensive Server Actions for order management:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'
import type { Order, OrderFormData, OrderProductInput, OrderFilters } from '@/lib/orders/types'

// Validation schemas
const orderProductSchema = z.object({
  product_id: z.string().uuid().optional().nullable(),
  sku: z.string().min(1),
  title: z.string().min(1),
  unit_price: z.number().min(0),
  quantity: z.number().int().min(1),
})

const orderSchema = z.object({
  contact_id: z.string().uuid().optional().nullable(),
  pipeline_id: z.string().uuid(),
  stage_id: z.string().uuid(),
  closing_date: z.string().optional().nullable(),
  description: z.string().optional().nullable(),
  carrier: z.string().optional().nullable(),
  tracking_number: z.string().optional().nullable(),
  custom_fields: z.record(z.unknown()).optional().default({}),
  products: z.array(orderProductSchema).optional().default([]),
})

// Get orders with filters
export async function getOrders(filters?: OrderFilters): Promise<{ data: Order[] | null; error: string | null }> {
  const supabase = await createClient()

  let query = supabase
    .from('orders')
    .select(`
      *,
      contact:contacts(id, name, phone, city),
      stage:pipeline_stages(id, name, color, position),
      pipeline:pipelines(id, name),
      products:order_products(*),
      tags:order_tags(tag:tags(*))
    `)
    .order('created_at', { ascending: false })

  // Apply filters
  if (filters?.pipeline_id) {
    query = query.eq('pipeline_id', filters.pipeline_id)
  }
  if (filters?.stage_ids && filters.stage_ids.length > 0) {
    query = query.in('stage_id', filters.stage_ids)
  }
  if (filters?.contact_id) {
    query = query.eq('contact_id', filters.contact_id)
  }

  const { data, error } = await query

  if (error) return { data: null, error: error.message }

  // Transform tags from nested structure
  const orders = data?.map(order => ({
    ...order,
    tags: order.tags?.map((t: { tag: { id: string; name: string; color: string } }) => t.tag) || [],
  }))

  return { data: orders, error: null }
}

// Get orders by pipeline (for Kanban)
export async function getOrdersByPipeline(pipelineId: string): Promise<{ data: Order[] | null; error: string | null }> {
  return getOrders({ pipeline_id: pipelineId })
}

// Get single order
export async function getOrder(id: string): Promise<{ data: Order | null; error: string | null }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      contact:contacts(id, name, phone, email, city, address),
      stage:pipeline_stages(id, name, color, position, wip_limit),
      pipeline:pipelines(id, name),
      products:order_products(*),
      tags:order_tags(tag:tags(*))
    `)
    .eq('id', id)
    .single()

  if (error) return { data: null, error: error.message }

  // Transform tags
  const order = {
    ...data,
    tags: data.tags?.map((t: { tag: { id: string; name: string; color: string } }) => t.tag) || [],
  }

  return { data: order, error: null }
}

// Create order with products
export async function createOrder(formData: OrderFormData): Promise<{ data: Order | null; error: string | null }> {
  const validation = orderSchema.safeParse(formData)
  if (!validation.success) {
    return { data: null, error: validation.error.issues[0].message }
  }

  const supabase = await createClient()
  const { products, ...orderData } = validation.data

  // Create order
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .insert(orderData)
    .select()
    .single()

  if (orderError) return { data: null, error: orderError.message }

  // Add products if provided
  if (products && products.length > 0) {
    const productsToInsert = products.map(p => ({
      ...p,
      order_id: order.id,
    }))

    const { error: productsError } = await supabase
      .from('order_products')
      .insert(productsToInsert)

    if (productsError) {
      // Rollback order if products fail
      await supabase.from('orders').delete().eq('id', order.id)
      return { data: null, error: 'Error agregando productos: ' + productsError.message }
    }
  }

  revalidatePath('/crm/pedidos')
  return getOrder(order.id)
}

// Update order
export async function updateOrder(id: string, formData: Partial<OrderFormData>): Promise<{ data: Order | null; error: string | null }> {
  const supabase = await createClient()
  const { products, ...orderData } = formData

  // Update order fields
  const { error: orderError } = await supabase
    .from('orders')
    .update({ ...orderData, updated_at: new Date().toISOString() })
    .eq('id', id)

  if (orderError) return { data: null, error: orderError.message }

  // If products provided, replace all
  if (products !== undefined) {
    // Delete existing products
    await supabase.from('order_products').delete().eq('order_id', id)

    // Insert new products
    if (products.length > 0) {
      const productsToInsert = products.map(p => ({
        ...p,
        order_id: id,
      }))

      const { error: productsError } = await supabase
        .from('order_products')
        .insert(productsToInsert)

      if (productsError) return { data: null, error: 'Error actualizando productos' }
    }
  }

  revalidatePath('/crm/pedidos')
  return getOrder(id)
}

// Move order to stage (for Kanban drag)
export async function moveOrderToStage(orderId: string, newStageId: string): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  // Get stage to check WIP limit
  const { data: stage } = await supabase
    .from('pipeline_stages')
    .select('id, wip_limit, pipeline_id')
    .eq('id', newStageId)
    .single()

  if (!stage) {
    return { success: false, error: 'Etapa no encontrada' }
  }

  // Check WIP limit
  if (stage.wip_limit) {
    const { count } = await supabase
      .from('orders')
      .select('*', { count: 'exact', head: true })
      .eq('stage_id', newStageId)
      .neq('id', orderId) // Exclude the order being moved

    if (count !== null && count >= stage.wip_limit) {
      return { success: false, error: `Esta etapa tiene limite de ${stage.wip_limit} pedidos` }
    }
  }

  // Update order stage
  const { error } = await supabase
    .from('orders')
    .update({
      stage_id: newStageId,
      updated_at: new Date().toISOString(),
    })
    .eq('id', orderId)

  if (error) return { success: false, error: 'Error moviendo pedido' }

  revalidatePath('/crm/pedidos')
  return { success: true, error: null }
}

// Delete order
export async function deleteOrder(id: string): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('orders')
    .delete()
    .eq('id', id)

  if (error) return { success: false, error: error.message }

  revalidatePath('/crm/pedidos')
  return { success: true, error: null }
}

// Add/remove tags
export async function addOrderTag(orderId: string, tagId: string): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('order_tags')
    .insert({ order_id: orderId, tag_id: tagId })

  if (error) {
    if (error.code === '23505') return { success: true, error: null } // Already exists
    return { success: false, error: error.message }
  }

  revalidatePath('/crm/pedidos')
  return { success: true, error: null }
}

export async function removeOrderTag(orderId: string, tagId: string): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('order_tags')
    .delete()
    .eq('order_id', orderId)
    .eq('tag_id', tagId)

  if (error) return { success: false, error: error.message }

  revalidatePath('/crm/pedidos')
  return { success: true, error: null }
}
```

Note: Order total is calculated automatically by database trigger, not in application code.
  </action>
  <verify>
Run: `pnpm tsc --noEmit` - No TypeScript errors
Check: All Server Action exports
  </verify>
  <done>
Server Actions for complete order CRUD with products, tags, and stage movement
  </done>
</task>

<task type="auto">
  <name>Task 2: Create orders page with table view and forms</name>
  <files>
    src/app/(dashboard)/crm/pedidos/page.tsx
    src/app/(dashboard)/crm/pedidos/components/orders-table.tsx
    src/app/(dashboard)/crm/pedidos/components/order-form.tsx
    src/app/(dashboard)/crm/pedidos/components/columns.tsx
    src/app/(dashboard)/crm/pedidos/components/product-picker.tsx
    src/app/(dashboard)/crm/pedidos/components/contact-selector.tsx
  </files>
  <action>
Create orders list UI:

**1. page.tsx:**
- Async Server Component
- Fetch orders, pipelines, products, tags, contacts
- Call getOrCreateDefaultPipeline() to ensure pipeline exists
- Pass data to OrdersTable
- Title: "Pedidos"

**2. orders-table.tsx:**
- Client component with TanStack Table
- Toolbar with:
  - Search input (filter by contact name, tracking number)
  - Pipeline selector dropdown
  - Stage filter (multi-select)
  - "Nuevo Pedido" button
- Empty state with CTA
- Order form in Sheet (side panel, not Dialog)

**3. order-form.tsx (in Sheet):**
- Large form for create/edit order
- Sections:
  1. **Contacto**: ContactSelector component
  2. **Productos**: ProductPicker component (add multiple)
  3. **Detalles**: Pipeline/Stage selectors, closing date
  4. **Envio**: Carrier, tracking number
  5. **Notas**: Description textarea
- Shows calculated total (from products)
- Submit creates/updates order
- Toast notifications

**4. columns.tsx:**
- Column definitions:
  - Contacto (name, with link to contact)
  - Valor (formatted currency, sortable)
  - Etapa (colored badge)
  - Pipeline (text)
  - Productos (count, first product name)
  - Tracking (guia number)
  - Fecha (created_at, sortable)
  - Acciones (edit, delete)
- createColumns factory pattern

**5. product-picker.tsx:**
- Component to add products to order
- Shows list of added products with quantities
- "Agregar Producto" button opens Combobox/Command to search products
- Each product row: title, unit price, quantity input, subtotal, remove button
- Displays running total
- Can add same product multiple times (separate line items)
- Can manually enter SKU/title/price for products not in catalog

**6. contact-selector.tsx:**
- Combobox to search and select contact
- Search by name or phone
- Shows "Crear contacto" option if no match
- Displays selected contact with name, phone, city

Format currency with:
```typescript
const formatCurrency = (value: number) =>
  new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', minimumFractionDigits: 0 }).format(value)
```
  </action>
  <verify>
Navigate to /crm/pedidos - Page renders with table
Test: Create order with contact and products
Test: Edit order, change products
Test: Delete order with confirmation
Run: `pnpm tsc --noEmit`
  </verify>
  <done>
Orders page with table view, order form with contact selector and product picker, CRUD operations working
  </done>
</task>

</tasks>

<verification>
1. Orders Server Actions compile: `pnpm tsc --noEmit`
2. Orders page accessible at /crm/pedidos
3. Can create order with contact and products
4. Order total auto-calculates from products
5. Can edit order (change products, contact, details)
6. Can delete order with confirmation
7. Table shows orders with filtering by pipeline/stage
8. Product picker allows adding multiple products with quantities
</verification>

<success_criteria>
- Complete order CRUD with list view
- Contact selection from existing contacts
- Product picker with multiple products per order
- Order total calculated from products (via DB trigger)
- Tracking info (carrier, guia) support
- Tag support for orders
</success_criteria>

<output>
After completion, create `.planning/phases/06-orders/06-04-SUMMARY.md`
</output>
