---
phase: 13-agent-engine-core
plan: 04
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - src/lib/agents/intent-detector.ts
  - src/lib/agents/orchestrator.ts
  - src/lib/agents/index.ts
autonomous: true

must_haves:
  truths:
    - "Intent detector classifies messages with confidence scores"
    - "Confidence thresholds route to correct action (proceed/reanalyze/clarify/handoff)"
    - "Orchestrator validates state transitions"
    - "Orchestrator can request tool execution"
  artifacts:
    - path: "src/lib/agents/intent-detector.ts"
      provides: "IntentDetector class with detect method and default prompt"
      exports: ["IntentDetector", "DEFAULT_INTENT_PROMPT"]
    - path: "src/lib/agents/orchestrator.ts"
      provides: "Orchestrator class with orchestrate method and confidence routing"
      exports: ["Orchestrator", "DEFAULT_ORCHESTRATOR_PROMPT"]
  key_links:
    - from: "src/lib/agents/intent-detector.ts"
      to: "src/lib/agents/claude-client.ts"
      via: "ClaudeClient.detectIntent call"
      pattern: "this\\.claudeClient\\.detectIntent"
    - from: "src/lib/agents/orchestrator.ts"
      to: "src/lib/agents/claude-client.ts"
      via: "ClaudeClient.orchestrate call"
      pattern: "this\\.claudeClient\\.orchestrate"
---

<objective>
Create Intent Detector and Orchestrator components.

Purpose: These are the two Claude-powered components that form the agent's intelligence. The Intent Detector classifies customer messages with confidence scores. The Orchestrator decides what action to take based on intent, confidence, and session state.

Output: IntentDetector class with default prompt, Orchestrator class with confidence routing and state validation.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-agent-engine-core/13-CONTEXT.md
@.planning/phases/13-agent-engine-core/13-RESEARCH.md
@.planning/phases/13-agent-engine-core/13-01-SUMMARY.md
@.planning/phases/13-agent-engine-core/13-02-SUMMARY.md
@.planning/phases/13-agent-engine-core/13-03-SUMMARY.md

# Types and components from prior plans
@src/lib/agents/types.ts
@src/lib/agents/errors.ts
@src/lib/agents/claude-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Intent Detector component</name>
  <files>src/lib/agents/intent-detector.ts</files>
  <action>
Create the IntentDetector class:

```typescript
/**
 * Intent Detector
 * Phase 13: Agent Engine Core
 *
 * Classifies customer messages and returns confidence scores.
 * Uses fast Claude model (Haiku) for low latency and cost.
 *
 * Architecture decision from CONTEXT.md:
 * - Detects the intent of the customer message
 * - Returns percentage of confidence (0-100%)
 * - Returns alternatives when there's ambiguity
 * - Does NOT decide the flow, only classifies
 */

import { ClaudeClient } from './claude-client'
import type {
  AgentConfig,
  ClaudeMessage,
  ClaudeModel,
  ConfidenceAction,
  ConfidenceThresholds,
  IntentResult,
} from './types'
import { DEFAULT_CONFIDENCE_THRESHOLDS } from './types'
import { IntentDetectionError } from './errors'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('intent-detector')

/**
 * Default system prompt for intent detection.
 * Can be overridden per agent in AgentConfig.
 */
export const DEFAULT_INTENT_PROMPT = `Eres un clasificador de intents para un agente de ventas.

Tu UNICA tarea es analizar el mensaje del cliente y retornar JSON con:
- intent: el intent detectado
- confidence: porcentaje de confianza (0-100)
- alternatives: array de intents alternativos si hay ambiguedad
- reasoning: breve explicacion de por que elegiste ese intent

INTENTS DISPONIBLES:
- saludo: Cliente saluda o inicia conversacion
- precio: Pregunta sobre precios o costos
- envio: Pregunta sobre envio, delivery o tiempos de entrega
- producto: Pregunta sobre caracteristicas, materiales, tamanos del producto
- promocion: Pregunta sobre promociones, descuentos, ofertas
- datos_cliente: Cliente proporciona datos personales (nombre, direccion, telefono, ciudad)
- seleccion_pack: Cliente selecciona un pack especifico (1x, 2x, 3x)
- confirmar_compra: Cliente confirma que quiere comprar
- cancelar: Cliente quiere cancelar, no esta interesado, rechaza
- duda_general: Pregunta que no encaja en otras categorias
- otro: Mensaje que no es una pregunta ni respuesta clara

REGLAS DE CONFIANZA:
- > 90%: El mensaje es claro y sin ambiguedad
- 70-90%: Bastante seguro pero podria haber otras interpretaciones
- 50-70%: Ambiguo, hay varias interpretaciones posibles
- < 50%: Muy incierto, el mensaje no es claro

RESPONDE SOLO JSON, sin texto adicional ni markdown:
{
  "intent": "string",
  "confidence": number,
  "alternatives": [{"intent": "string", "confidence": number}],
  "reasoning": "breve explicacion"
}

Ejemplos:
- "hola buenas" -> {"intent": "saludo", "confidence": 95, "alternatives": [], "reasoning": "Saludo tipico"}
- "cuanto cuesta?" -> {"intent": "precio", "confidence": 92, "alternatives": [], "reasoning": "Pregunta directa de precio"}
- "ok" -> {"intent": "otro", "confidence": 40, "alternatives": [{"intent": "confirmar_compra", "confidence": 35}], "reasoning": "ok es ambiguo, puede ser confirmacion o acknowledgment"}
- "mi nombre es Juan y vivo en Bogota" -> {"intent": "datos_cliente", "confidence": 95, "alternatives": [], "reasoning": "Proporciona nombre y ciudad"}
`

/**
 * Intent detection result with routing decision.
 */
export interface IntentDetectionResult {
  intent: IntentResult
  action: ConfidenceAction
  tokensUsed: number
}

/**
 * Intent Detector component.
 *
 * Wraps ClaudeClient.detectIntent with:
 * - Default prompt management
 * - Confidence-to-action routing
 * - Validation and error handling
 */
export class IntentDetector {
  private claudeClient: ClaudeClient

  constructor(claudeClient?: ClaudeClient) {
    this.claudeClient = claudeClient ?? new ClaudeClient()
  }

  /**
   * Detect intent from customer message.
   *
   * @param message The customer's message
   * @param history Conversation history for context
   * @param config Agent configuration (for custom prompt/model)
   * @returns Intent result with confidence and routing action
   */
  async detect(
    message: string,
    history: ClaudeMessage[],
    config?: {
      systemPrompt?: string
      model?: ClaudeModel
      thresholds?: ConfidenceThresholds
    }
  ): Promise<IntentDetectionResult> {
    const systemPrompt = config?.systemPrompt ?? DEFAULT_INTENT_PROMPT
    const model = config?.model ?? 'claude-haiku-4-5'
    const thresholds = config?.thresholds ?? DEFAULT_CONFIDENCE_THRESHOLDS

    logger.debug(
      { messageLength: message.length, historyLength: history.length, model },
      'Detecting intent'
    )

    try {
      const { result: intent, tokensUsed } = await this.claudeClient.detectIntent(
        systemPrompt,
        history,
        message,
        model
      )

      // Validate intent result
      if (!intent.intent || typeof intent.confidence !== 'number') {
        throw new IntentDetectionError(
          'Invalid intent response: missing intent or confidence',
          JSON.stringify(intent)
        )
      }

      // Determine action based on confidence
      const action = this.routeByConfidence(intent.confidence, thresholds)

      logger.info(
        {
          intent: intent.intent,
          confidence: intent.confidence,
          action,
          tokensUsed,
        },
        'Intent detected with action'
      )

      return { intent, action, tokensUsed }
    } catch (error) {
      if (error instanceof IntentDetectionError) {
        throw error
      }
      throw new IntentDetectionError(
        `Intent detection failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        undefined
      )
    }
  }

  /**
   * Route to action based on confidence score.
   *
   * Thresholds from CONTEXT.md:
   * >= 85%: PROCEED - execute flow normally
   * 60-84%: REANALYZE - use more context to decide
   * 40-59%: CLARIFY - ask customer for clarification
   * < 40%: HANDOFF - pass to human
   */
  routeByConfidence(
    confidence: number,
    thresholds: ConfidenceThresholds = DEFAULT_CONFIDENCE_THRESHOLDS
  ): ConfidenceAction {
    if (confidence >= thresholds.proceed) {
      return 'proceed'
    }
    if (confidence >= thresholds.reanalyze) {
      return 'reanalyze'
    }
    if (confidence >= thresholds.clarify) {
      return 'clarify'
    }
    return 'handoff'
  }

  /**
   * Check if an intent requires clarification.
   */
  needsClarification(intent: IntentResult, thresholds?: ConfidenceThresholds): boolean {
    const action = this.routeByConfidence(
      intent.confidence,
      thresholds ?? DEFAULT_CONFIDENCE_THRESHOLDS
    )
    return action === 'clarify' || action === 'reanalyze'
  }

  /**
   * Check if an intent should be handed off to human.
   */
  shouldHandoff(intent: IntentResult, thresholds?: ConfidenceThresholds): boolean {
    const action = this.routeByConfidence(
      intent.confidence,
      thresholds ?? DEFAULT_CONFIDENCE_THRESHOLDS
    )
    return action === 'handoff'
  }

  /**
   * Get the best alternative intent if available.
   */
  getBestAlternative(intent: IntentResult): { intent: string; confidence: number } | null {
    if (!intent.alternatives || intent.alternatives.length === 0) {
      return null
    }
    // Return highest confidence alternative
    return intent.alternatives.reduce((best, alt) =>
      alt.confidence > best.confidence ? alt : best
    )
  }
}
```

Key implementation notes:
- Default prompt is Spanish, tailored for sales agent
- Confidence thresholds match user decision in CONTEXT.md (85/60/40)
- routeByConfidence returns ConfidenceAction type
- Helper methods for common checks (needsClarification, shouldHandoff)
- ClaudeClient dependency injection for testability
  </action>
  <verify>
TypeScript compilation:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/intent-detector.ts
```
Check exports:
```bash
grep -E "^export" src/lib/agents/intent-detector.ts
```
Verify confidence routing:
```bash
grep -A20 "routeByConfidence" src/lib/agents/intent-detector.ts
```
  </verify>
  <done>
- IntentDetector class with detect method
- DEFAULT_INTENT_PROMPT with Spanish instructions
- routeByConfidence implementing user-defined thresholds
- Helper methods: needsClarification, shouldHandoff, getBestAlternative
- IntentDetectionResult type with action routing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Orchestrator component</name>
  <files>
src/lib/agents/orchestrator.ts
src/lib/agents/index.ts
  </files>
  <action>
Create the Orchestrator class:

```typescript
/**
 * Orchestrator
 * Phase 13: Agent Engine Core
 *
 * Decides what action to take based on intent, confidence, and session state.
 * Can request tool execution via Action DSL.
 *
 * Architecture decision from CONTEXT.md:
 * - Has overall view of the sales flow
 * - Receives intent + confidence + session state
 * - Decides which components to call based on intent
 * - Validates that the flow is correct (no skipping steps)
 * - Handles edge cases intelligently
 * - Decides handoff when confidence is very low
 */

import { ClaudeClient } from './claude-client'
import type {
  AgentConfig,
  ClaudeMessage,
  ClaudeModel,
  ConfidenceAction,
  IntentResult,
  OrchestratorResult,
  SessionState,
  ToolCallRequest,
} from './types'
import { AgentError } from './errors'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('orchestrator')

/**
 * Default system prompt for orchestration.
 * Can be overridden per agent in AgentConfig.
 */
export const DEFAULT_ORCHESTRATOR_PROMPT = `Eres el orquestador de un agente de ventas.

CONTEXTO:
- Recibes: intent detectado, confianza, estado de sesion
- Decides: que accion tomar basado en confianza y flujo

REGLAS DE CONFIANZA:
- >= 85%: PROCEDER con flujo normal
- 60-84%: RE-ANALIZAR con mas contexto antes de actuar
- 40-59%: CLARIFICAR pidiendo al cliente mas informacion
- < 40%: HANDOFF a humano (demasiado incierto)

FLUJO DE VENTA:
conversacion -> collecting_data -> ofrecer_promos -> resumen -> compra_confirmada

VALIDACIONES OBLIGATORIAS:
1. NO puedes saltar a "ofrecer_promos" sin datos minimos (nombre, telefono, ciudad, direccion)
2. NO puedes saltar a "resumen" sin haber ofrecido promos
3. NO puedes confirmar compra sin haber enviado resumen

DATOS MINIMOS vs OPCIONALES:
- MINIMOS (requeridos): nombre, telefono, ciudad, direccion
- OPCIONALES: apellido, barrio, departamento, correo

Si faltan solo opcionales, puedes proceder a ofrecer promos.

TEMPLATES ENVIADOS:
No repitas templates. Si ya enviaste un template, usa parafraseo o template de respaldo.

TOOLS DISPONIBLES:
Puedes llamar herramientas del sistema usando tool_use. Los nombres usan guiones bajos.

FORMATO DE RESPUESTA:
Si necesitas llamar tools, usa tool_use blocks.
Si solo respondes texto, responde un JSON:
{
  "action": "proceed" | "reanalyze" | "clarify" | "handoff",
  "response": "texto para el cliente",
  "nextMode": "nuevo modo si cambia"
}

Recuerda: Tu trabajo es ORQUESTAR, no generar la respuesta final.
Decide QUE hacer basado en el contexto completo.
`

/**
 * Orchestration input combining all context.
 */
export interface OrchestrationInput {
  intent: IntentResult
  action: ConfidenceAction
  message: string
  history: ClaudeMessage[]
  sessionState: SessionState
  currentMode: string
}

/**
 * Full orchestration result with metadata.
 */
export interface OrchestrationOutput {
  result: OrchestratorResult
  tokensUsed: number
  transitionValid: boolean
  validationError?: string
}

/**
 * Orchestrator component.
 *
 * Wraps ClaudeClient.orchestrate with:
 * - State transition validation
 * - Flow rule enforcement
 * - Action routing based on confidence
 */
export class Orchestrator {
  private claudeClient: ClaudeClient

  /** Valid state transitions (from CONTEXT.md) */
  private static readonly VALID_TRANSITIONS: Record<string, string[]> = {
    conversacion: ['conversacion', 'collecting_data'],
    collecting_data: ['collecting_data', 'ofrecer_promos'],
    ofrecer_promos: ['ofrecer_promos', 'resumen'],
    resumen: ['resumen', 'compra_confirmada'],
    compra_confirmada: ['compra_confirmada'],
  }

  /** Minimum required data fields */
  private static readonly REQUIRED_DATA_FIELDS = ['nombre', 'telefono', 'ciudad', 'direccion']

  constructor(claudeClient?: ClaudeClient) {
    this.claudeClient = claudeClient ?? new ClaudeClient()
  }

  /**
   * Orchestrate the agent response.
   *
   * @param input All context needed for orchestration
   * @param config Agent configuration (for custom prompt/model/tools)
   * @returns Orchestration result with action and optional tool calls
   */
  async orchestrate(
    input: OrchestrationInput,
    config?: {
      systemPrompt?: string
      model?: ClaudeModel
      tools?: string[]
    }
  ): Promise<OrchestrationOutput> {
    const systemPrompt = config?.systemPrompt ?? DEFAULT_ORCHESTRATOR_PROMPT
    const model = config?.model ?? 'claude-sonnet-4-5'
    const tools = config?.tools ?? []

    logger.debug(
      {
        intent: input.intent.intent,
        action: input.action,
        currentMode: input.currentMode,
        toolCount: tools.length,
      },
      'Starting orchestration'
    )

    // Handle low-confidence actions without calling Claude
    if (input.action === 'handoff') {
      logger.info({ confidence: input.intent.confidence }, 'Handoff triggered by low confidence')
      return {
        result: {
          action: 'handoff',
          response: 'Necesito transferirte con un asesor humano para ayudarte mejor.',
        },
        tokensUsed: 0,
        transitionValid: true,
      }
    }

    if (input.action === 'clarify') {
      logger.info({ confidence: input.intent.confidence }, 'Clarification needed')
      return {
        result: {
          action: 'clarify',
          response: this.generateClarificationResponse(input.intent),
        },
        tokensUsed: 0,
        transitionValid: true,
      }
    }

    // For proceed and reanalyze, call Claude
    try {
      const { result, tokensUsed } = await this.claudeClient.orchestrate(
        systemPrompt,
        input.history,
        input.intent,
        input.sessionState,
        tools,
        model
      )

      // Validate state transition if nextMode is specified
      let transitionValid = true
      let validationError: string | undefined

      if (result.nextMode) {
        const validation = this.validateTransition(
          input.currentMode,
          result.nextMode,
          input.sessionState
        )
        transitionValid = validation.valid
        validationError = validation.error

        if (!transitionValid) {
          logger.warn(
            { from: input.currentMode, to: result.nextMode, error: validationError },
            'Invalid state transition requested'
          )
          // Override the result to stay in current mode
          result.nextMode = input.currentMode
        }
      }

      logger.info(
        {
          action: result.action,
          toolCallCount: result.toolCalls?.length ?? 0,
          nextMode: result.nextMode,
          transitionValid,
          tokensUsed,
        },
        'Orchestration complete'
      )

      return { result, tokensUsed, transitionValid, validationError }
    } catch (error) {
      throw new AgentError(
        `Orchestration failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'ORCHESTRATION_ERROR'
      )
    }
  }

  /**
   * Validate a state transition.
   */
  validateTransition(
    from: string,
    to: string,
    state: SessionState
  ): { valid: boolean; error?: string } {
    // Check if transition is allowed
    const allowed = Orchestrator.VALID_TRANSITIONS[from]
    if (!allowed || !allowed.includes(to)) {
      return {
        valid: false,
        error: `Transition from "${from}" to "${to}" is not allowed`,
      }
    }

    // Special validation for ofrecer_promos: need minimum data
    if (to === 'ofrecer_promos') {
      const missing = this.getMissingRequiredData(state)
      if (missing.length > 0) {
        return {
          valid: false,
          error: `Cannot transition to ofrecer_promos: missing ${missing.join(', ')}`,
        }
      }
    }

    // Special validation for resumen: need templates_enviados to include promo
    if (to === 'resumen') {
      const hasPromo = state.templates_enviados.some((t) =>
        t.toLowerCase().includes('promo') || t.toLowerCase().includes('ofrecer')
      )
      if (!hasPromo && state.intents_vistos.every((i) => i.intent !== 'ofrecer_promos')) {
        return {
          valid: false,
          error: 'Cannot transition to resumen: must offer promos first',
        }
      }
    }

    // Special validation for compra_confirmada: need resumen sent
    if (to === 'compra_confirmada') {
      const hasResumen = state.templates_enviados.some((t) =>
        t.toLowerCase().includes('resumen')
      )
      if (!hasResumen && !state.intents_vistos.some((i) => i.intent === 'resumen')) {
        return {
          valid: false,
          error: 'Cannot transition to compra_confirmada: must send resumen first',
        }
      }
    }

    return { valid: true }
  }

  /**
   * Get missing required data fields.
   */
  getMissingRequiredData(state: SessionState): string[] {
    return Orchestrator.REQUIRED_DATA_FIELDS.filter(
      (field) => !state.datos_capturados[field]
    )
  }

  /**
   * Check if minimum data is collected.
   */
  hasMinimumData(state: SessionState): boolean {
    return this.getMissingRequiredData(state).length === 0
  }

  /**
   * Generate a clarification response for ambiguous intents.
   */
  private generateClarificationResponse(intent: IntentResult): string {
    // If we have alternatives, mention them
    if (intent.alternatives && intent.alternatives.length > 0) {
      const topAlternative = intent.alternatives[0]
      return `Disculpa, no estoy seguro si te refieres a ${intent.intent} o ${topAlternative.intent}. ¿Podrias ser mas especifico?`
    }

    // Generic clarification
    return 'Disculpa, no entendi bien tu mensaje. ¿Podrias explicarme con mas detalle?'
  }

  /**
   * Get valid next states from current state.
   */
  getValidNextStates(currentMode: string): string[] {
    return Orchestrator.VALID_TRANSITIONS[currentMode] ?? []
  }

  /**
   * Check if a tool call is requested.
   */
  hasToolCalls(result: OrchestratorResult): boolean {
    return result.action === 'execute_tool' && (result.toolCalls?.length ?? 0) > 0
  }
}
```

**Update src/lib/agents/index.ts to add exports:**

Add to existing exports:
```typescript
// Intent Detector
export { IntentDetector, DEFAULT_INTENT_PROMPT } from './intent-detector'
export type { IntentDetectionResult } from './intent-detector'

// Orchestrator
export { Orchestrator, DEFAULT_ORCHESTRATOR_PROMPT } from './orchestrator'
export type { OrchestrationInput, OrchestrationOutput } from './orchestrator'
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/orchestrator.ts
```
Check exports:
```bash
grep -E "^export" src/lib/agents/orchestrator.ts
```
Verify state validation:
```bash
grep -A10 "validateTransition" src/lib/agents/orchestrator.ts | head -15
```
Check index exports:
```bash
grep -E "IntentDetector|Orchestrator" src/lib/agents/index.ts
```
  </verify>
  <done>
- Orchestrator class with orchestrate method
- DEFAULT_ORCHESTRATOR_PROMPT with Spanish instructions
- VALID_TRANSITIONS map enforcing flow rules
- validateTransition checking state machine rules
- getMissingRequiredData for data validation
- Automatic handoff/clarify responses without Claude call
- Helper methods: hasMinimumData, getValidNextStates, hasToolCalls
- Exports added to index.ts
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. IntentDetector exports verified:
```bash
grep "export class IntentDetector" src/lib/agents/intent-detector.ts
```

2. Orchestrator exports verified:
```bash
grep "export class Orchestrator" src/lib/agents/orchestrator.ts
```

3. Confidence thresholds match CONTEXT.md:
```bash
grep -A5 "proceed.*85\|reanalyze.*60\|clarify.*40" src/lib/agents/intent-detector.ts
```

4. State transitions defined:
```bash
grep -A10 "VALID_TRANSITIONS" src/lib/agents/orchestrator.ts
```

5. All exports in index.ts:
```bash
grep -E "export.*from.*intent-detector\|export.*from.*orchestrator" src/lib/agents/index.ts
```

6. TypeScript compiles:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit
```
</verification>

<success_criteria>
- IntentDetector.detect returns intent with confidence and action
- IntentDetector.routeByConfidence implements 85/60/40 thresholds
- Orchestrator.orchestrate returns tool calls or text response
- Orchestrator.validateTransition enforces state machine rules
- Orchestrator handles handoff/clarify without calling Claude
- Default prompts are in Spanish, tailored for sales agent
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-agent-engine-core/13-04-SUMMARY.md`
</output>
