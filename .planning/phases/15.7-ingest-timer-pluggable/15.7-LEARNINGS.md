# Phase 15.7: Ingest Timer Pluggable - Learnings

**Fecha:** 2026-02-08 a 2026-02-09
**Duracion:** 2 dias (implementacion + 17 hotfixes)
**Plans ejecutados:** 2 de 3 (plan 03 = verificacion humana pendiente)

---

## Bugs Encontrados

| Bug | Causa | Fix | Prevencion |
|-----|-------|-----|------------|
| Timer no emitia signal al entrar a collecting_data | El path normal (captura_datos_si_compra -> collecting_data) no pasaba por handleIngestMode, y no habia signal emission en el path del orquestador | Agregar emision de `lastTimerSignal = { type: 'start' }` en seccion 8b cuando `newState.currentMode === 'collecting_data'` | Siempre verificar TODOS los paths que pueden causar una transicion de modo, no solo el path principal |
| Timer usaba contexto vacio en buildAction al expirar | setTimeout capturaba closure con contexto vacio en vez de leer estado actual | Agregar `setContextProvider()` al simulator que lee de `stateRef.current` al momento de expirar | Nunca confiar en closures de setTimeout para datos que cambian - usar refs o providers |
| ingestStatus se perdia al construir newState | `newState` en processMessage() no incluia `ingestStatus` de `currentState` | Agregar `ingestStatus: currentState.ingestStatus` al objeto newState | Al construir objetos de estado nuevos, SIEMPRE verificar que todos los campos del tipo estan incluidos |
| timerEnabled stale en closure de handleSendMessage | `timerEnabled` capturado en closure del useCallback podia estar desactualizado despues de message delays | Cambiar a `timerEnabledRef.current` para leer valor actual | Para valores que se leen despues de awaits largos, usar refs en vez de state |
| Timer no arrancaba al activar toggle | `handleTimerToggle(true)` solo hacia `setTimerEnabled(true)` sin evaluar estado actual | Agregar evaluacion retroactiva: leer stateRef, evaluar nivel, startTimerForLevel si aplica | Cuando un toggle activa funcionalidad, siempre considerar el estado actual - no asumir que una signal futura lo activara |
| Timer se desactivaba en cada session reset | `handleReset` llamaba `setTimerEnabled(false)` | Remover la linea - timer persiste entre sesiones | Considerar si los toggles de configuracion deben sobrevivir resets de datos |
| Timer defaulteaba a false | `useState(false)` y `useRef(false)` para timerEnabled | Cambiar ambos a `true` | Features que son necesarias para el flujo normal deben estar activas por defecto |
| L2 no disparaba ofrecer_promos via engine | Timer L2 hacia `setState({ currentMode: 'ofrecer_promos' })` localmente sin pasar por engine | Agregar `triggerPromos()` que llama al engine con `forceIntent: 'ofrecer_promos'` para enviar templates reales | Transiciones de modo siempre deben pasar por el engine para que los templates se envien |
| L3/L4 no creaban ordenes reales | Timer L3/L4 mostraban placeholder en vez de invocar CRM orchestrator | Agregar `triggerOrderCreation()` que llama al engine con `forceIntent: 'compra_confirmada'` + CRM modes | Acciones que involucran side effects (crear orden, enviar mensaje) deben delegarse al engine, no hacerse localmente |
| Timer no se cancelaba al responder promos | Usuario seleccionaba promo pero timer L3 seguia contando | Agregar signal `{ type: 'cancel' }` cuando usuario responde en modo ofrecer_promos | Cualquier interaccion del usuario en un modo con timer debe re-evaluar si el timer sigue siendo relevante |
| L4 evaluaba modo incorrecto | L4 (Pack sin confirmar) evaluaba `ofrecer_promos` pero el pack se selecciona en modo `resumen` | Cambiar evaluate de L4 a `ctx.currentMode === 'resumen'` | Verificar que las condiciones de evaluacion reflejan el flujo real del agente, no suposiciones |
| Timer no re-evaluaba al cambiar de modo | Transicion de collecting_data a ofrecer_promos no emitia reevaluate | Agregar seccion 8d: emitir `{ type: 'reevaluate' }` en cualquier cambio de modo | Los cambios de modo SIEMPRE deben triggerear re-evaluacion del timer |
| Templates se enviaban en compra_confirmada por timer | Cuando timer forzaba compra_confirmada, el orchestrator tambien enviaba templates de confirmacion duplicados | Agregar `skipTemplateDispatch` flag cuando el intent viene de timer | Cuando se fuerza un intent desde timer, verificar si el flujo normal del intent tiene side effects no deseados |
| indicaciones_extra no se mapeaba en direccion | Datos como "apto 1601b" se perdian del campo direccion | Agregar `indicaciones_extra` como campo adicional en address mapping | Revisar que TODOS los campos de datos capturados se incluyan en los objetos de salida |
| Transition validation fallaba para timer-forced ofrecer_promos | Orchestrator validaba que collecting_data no podia ir a ofrecer_promos directamente | Agregar `skipValidation: true` cuando intent viene de timer o forceIntent | Flujos forzados (timer, forceIntent) necesitan bypass de validacion de transiciones |
| lastClassification type mismatch | `undefined` no era asignable al tipo esperado | Cambiar tipo a aceptar `undefined` ademas de la clasificacion | Campos opcionales en interfaces deben ser `T | undefined`, no solo `T` |
| Signal de timer-start faltaba despues de ingest complete -> ofrecer_promos | Cuando ingest completaba y transitaba a ofrecer_promos, el cancel del ingest sobreescribia la necesidad de iniciar L3 | Override: si `justCompletedIngest && newState.currentMode === 'ofrecer_promos'`, forzar `{ type: 'start' }` | Transiciones que van de un "mundo de timer" a otro (ingest -> promos) necesitan re-iniciar timer, no cancelarlo |

## Decisiones Tecnicas

| Decision | Alternativas Descartadas | Razon |
|----------|-------------------------|-------|
| Pure-logic IngestTimerSimulator (no React) | Custom hook con useState/useEffect | Facilita testing, evita re-renders innecesarios, separacion clara logica/UI |
| Callback ref pattern (timerExpireRef) | Recrear simulator en cada render | Simulator se crea 1 vez en mount; callback ref da acceso a handler actualizado sin stale closures |
| 5 niveles en array evaluados en orden 0-4 | Switch-case o map | Orden importa (first match wins), facil agregar niveles, evaluate() es pure function testeable |
| TIMER_MINIMUM_FIELDS (6) separado de CRITICAL_FIELDS (5) | Reusar CRITICAL_FIELDS + apellido | Propositos distintos: timer evaluation vs order creation. Desacoplados para flexibilidad |
| Timer enabled por defecto (true) | Disabled por defecto (false) | Feature esencial para el flujo - no deberia requerir activacion manual |
| lastTimerSignal como class property | Pasar signal como parametro | Multiples paths pueden setear signal; class property permite que el ultimo path "gane" |

## Problemas de Integracion

| Componente A | Componente B | Problema | Solucion |
|--------------|--------------|----------|----------|
| IngestTimerSimulator | sandbox-layout | Stale closures en onExpire callback | timerExpireRef pattern + contextProvider |
| SandboxEngine | sandbox-layout | timerSignal se perdia en JSON serialization cuando undefined | `this.lastTimerSignal ?? undefined` (JSON omits undefined, client checks truthiness) |
| handleIngestMode | processMessage newState | ingestStatus mutado en currentState no se propagaba a newState | Agregar `ingestStatus: currentState.ingestStatus` al construir newState |
| Timer L2 expiration | SomnioOrchestrator | Transicion local sin templates | Delegar al engine con forceIntent |
| Timer L3/L4 expiration | CRM Orchestrator | Ordenes no se creaban | Delegar al engine con forceIntent + crmModes |
| Timer signals | handleSendMessage delays | Signal procesada despues de 2-6s de message delays | Usar refs (timerEnabledRef) para leer estado actual post-delays |

## Tips para Futuros Agentes

### Lo que funciono bien
- Pure-logic simulator class sin React - facil de razonar y testar
- Ref pattern para evitar stale closures en callbacks de larga vida
- contextProvider para obtener datos frescos en el momento de expiracion
- Presets que setean los 5 niveles simultaneamente - excelente UX

### Lo que NO hacer
- NO confiar en closures de setTimeout/setInterval para datos que cambian
- NO construir objetos de estado parciales - siempre incluir TODOS los campos del tipo
- NO asumir que un toggle estara activo cuando una signal llegue - evaluar retroactivamente
- NO hacer transiciones de modo localmente (setState) - siempre pasar por el engine
- NO crear ordenes o enviar mensajes sin pasar por el engine/orchestrator
- NO cancelar timer en transicion a otro modo sin verificar si el nuevo modo necesita su propio timer

### Patrones a seguir
- `lastTimerSignal` pattern: reset al inicio de processMessage, setear en cada path, retornar al final
- `timerExpireRef` pattern: ref que siempre tiene el handler actualizado, pasado al simulator en mount
- `stateRef.current` pattern: para leer estado actual dentro de async functions y callbacks
- `forceIntent` pattern: para que timer/external events triggeren flujos del engine sin mensaje del usuario
- Seccion 8b/8c/8d pattern: verificaciones post-orquestador para emitir signals en transiciones

### Comandos utiles
```bash
# Ver todos los fixes del timer
git log --oneline | grep -i "fix.*15\.7\|15\.7.*fix"

# Ver estado del ingest en debug panel
# Expandir "Estado Ingest (JSON)" en la tab Ingest del sandbox
```

## Deuda Tecnica Identificada

| Item | Prioridad | Fase sugerida |
|------|-----------|---------------|
| Plan 03 (verificacion humana) pendiente | Alta | 15.7-03 |
| 17 hotfixes sugieren que los plans originales no anticiparon edge cases de integracion | Media | Mejorar research de integracion en futuras fases |
| Timer L3/L4 order creation deberia usar CRM orchestrator real, no mock | Media | Phase 16 |
| No hay unit tests para IngestTimerSimulator | Media | Post-MVP |
| Signal flow engine -> API -> client es fragil (un undefined perdido rompe todo) | Baja | Refactor post-MVP |

## Notas para el Modulo

- El timer es 100% client-side (IngestTimerSimulator). En produccion (Phase 16), los timers reales usaran Inngest
- La relacion signal engine -> client es 1:1 por mensaje. Si se pierde, no hay retry
- Los 5 niveles estan hardcoded en TIMER_LEVELS array. Agregar un nivel = agregar entrada al array + actualizar TIMER_PRESETS
- `handleTimerExpire` en sandbox-layout es el punto central de todas las acciones de expiracion
- El timer se re-evalua automaticamente cuando llegan datos nuevos (reevaluate signal), pero NO cuando el usuario cambia el preset/slider (solo cambia duracion del timer activo)

---
*Generado al completar la fase. Input para entrenamiento de agentes de documentacion.*
