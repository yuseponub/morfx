---
phase: 03-action-dsl-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - supabase/migrations/20260128_tool_executions.sql
  - supabase/migrations/20260128_api_keys.sql
  - src/lib/tools/types.ts
autonomous: true

must_haves:
  truths:
    - "Dependencies ajv, pino, jose are installed and importable"
    - "tool_executions table exists with RLS by workspace"
    - "api_keys table exists for external API authentication"
    - "Tool type definitions are available for TypeScript"
  artifacts:
    - path: "package.json"
      provides: "New dependencies for tool system"
      contains: "ajv"
    - path: "src/lib/tools/types.ts"
      provides: "Tool schema types and execution types"
      exports: ["ToolSchema", "ToolExecution", "ExecutionContext"]
  key_links:
    - from: "supabase/migrations/20260128_tool_executions.sql"
      to: "workspace_members"
      via: "RLS policy joins"
      pattern: "workspace_id.*workspace_members"
---

<objective>
Set up the foundation for the Action DSL system: install dependencies, create database tables, and define TypeScript types.

Purpose: This plan establishes the infrastructure that all subsequent plans depend on. Without the database tables, we can't log executions. Without the types, we can't build the registry.

Output: Dependencies installed, database migrations ready, and tool types defined.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-action-dsl-core/03-CONTEXT.md
@.planning/phases/03-action-dsl-core/03-RESEARCH.md
@src/lib/permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Action DSL Dependencies</name>
  <files>package.json</files>
  <action>
Install the required dependencies for the tool system:

```bash
npm install ajv ajv-formats pino pino-http jose
npm install --save-dev json-schema-to-typescript
```

Dependencies:
- ajv (8.17+): JSON Schema validation
- ajv-formats (3.0+): Email, URI, date-time format validators
- pino (9.5+): Structured logging (50k logs/sec)
- pino-http (10.3+): HTTP request context logging
- jose (5.9+): JWT/API key validation (Edge Runtime compatible)
- json-schema-to-typescript (15.0+): Generate TS types from schemas (dev)

Do NOT use jsonwebtoken (not Edge Runtime compatible).
  </action>
  <verify>
Run `npm ls ajv pino jose` - all packages should be listed.
Run `node -e "require('ajv'); require('pino'); require('jose')"` - no errors.
  </verify>
  <done>All 6 packages are installed and importable without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create Database Tables for Tool System</name>
  <files>
    supabase/migrations/20260128_tool_executions.sql
    supabase/migrations/20260128_api_keys.sql
  </files>
  <action>
Create two SQL migration files:

**1. tool_executions table** (forensic audit log):
```sql
-- 20260128_tool_executions.sql
CREATE TABLE tool_executions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,

  -- Tool info
  tool_name TEXT NOT NULL,

  -- Inputs/Outputs (JSONB for flexibility)
  inputs JSONB NOT NULL DEFAULT '{}',
  outputs JSONB DEFAULT '{}',

  -- Status
  status TEXT NOT NULL CHECK (status IN ('success', 'error', 'dry_run')),
  error_message TEXT,
  error_stack TEXT,

  -- Timing
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ NOT NULL,
  duration_ms INTEGER NOT NULL,

  -- Context
  user_id UUID REFERENCES auth.users(id),
  session_id TEXT,

  -- Request context (forensic)
  request_context JSONB NOT NULL DEFAULT '{}',

  -- Snapshots for reversibility
  snapshot_before JSONB,
  snapshot_after JSONB,

  -- Batch relationships
  batch_id UUID,
  related_executions UUID[],

  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT timezone('America/Bogota', NOW())
);

-- Indexes for common queries
CREATE INDEX idx_tool_executions_workspace ON tool_executions(workspace_id);
CREATE INDEX idx_tool_executions_tool_name ON tool_executions(tool_name);
CREATE INDEX idx_tool_executions_status ON tool_executions(status);
CREATE INDEX idx_tool_executions_created_at ON tool_executions(created_at DESC);
CREATE INDEX idx_tool_executions_batch ON tool_executions(batch_id) WHERE batch_id IS NOT NULL;

-- RLS policies
ALTER TABLE tool_executions ENABLE ROW LEVEL SECURITY;

-- Members can view executions in their workspace
CREATE POLICY "Members can view workspace tool executions"
  ON tool_executions FOR SELECT
  USING (
    workspace_id IN (
      SELECT workspace_id FROM workspace_members
      WHERE user_id = auth.uid()
    )
  );

-- Only system (service role) can insert executions
CREATE POLICY "Service role can insert tool executions"
  ON tool_executions FOR INSERT
  WITH CHECK (true);
```

**2. api_keys table** (external API authentication):
```sql
-- 20260128_api_keys.sql
CREATE TABLE api_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id UUID NOT NULL REFERENCES workspaces(id) ON DELETE CASCADE,

  -- Key info
  name TEXT NOT NULL,
  key_hash TEXT NOT NULL UNIQUE, -- bcrypt hash, NOT plaintext
  key_prefix TEXT NOT NULL, -- First 8 chars for identification (mfx_xxxx...)

  -- Permissions
  permissions TEXT[] NOT NULL DEFAULT '{}',

  -- Status
  revoked BOOLEAN NOT NULL DEFAULT false,
  revoked_at TIMESTAMPTZ,
  revoked_by UUID REFERENCES auth.users(id),

  -- Metadata
  last_used_at TIMESTAMPTZ,
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT timezone('America/Bogota', NOW()),
  expires_at TIMESTAMPTZ -- NULL = never expires
);

-- Indexes
CREATE INDEX idx_api_keys_workspace ON api_keys(workspace_id);
CREATE INDEX idx_api_keys_key_hash ON api_keys(key_hash) WHERE revoked = false;

-- RLS policies
ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;

-- Admins+ can manage API keys in their workspace
CREATE POLICY "Admins can manage workspace API keys"
  ON api_keys FOR ALL
  USING (
    workspace_id IN (
      SELECT workspace_id FROM workspace_members
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin')
    )
  );
```

Apply migrations to local Supabase (if running) or document for production.
  </action>
  <verify>
If local Supabase: `supabase db push` succeeds.
Otherwise: SQL syntax valid (check with pgAdmin or Supabase dashboard).
Tables `tool_executions` and `api_keys` exist in schema.
  </verify>
  <done>Both tables created with proper columns, indexes, and RLS policies.</done>
</task>

<task type="auto">
  <name>Task 3: Define Tool Type System</name>
  <files>src/lib/tools/types.ts</files>
  <action>
Create the TypeScript type definitions for the tool system following MCP-compatible JSON Schema format:

```typescript
// src/lib/tools/types.ts

import type { JSONSchemaType } from 'ajv'

/**
 * Tool metadata following MCP specification
 */
export interface ToolMetadata {
  module: 'crm' | 'whatsapp' | 'system'
  entity: string  // e.g., 'contact', 'order', 'message'
  action: string  // e.g., 'create', 'update', 'delete', 'send'
  reversible: boolean
  requiresApproval: boolean
  sideEffects: string[]  // e.g., ['creates_record', 'sends_message']
  permissions: string[]  // Required permissions from src/lib/permissions.ts
}

/**
 * Tool schema definition (MCP-compatible)
 */
export interface ToolSchema<TInput = unknown, TOutput = unknown> {
  name: string  // Format: module.entity.action (e.g., 'crm.contact.create')
  description: string
  inputSchema: JSONSchemaType<TInput> | object  // JSON Schema for inputs
  outputSchema?: object  // JSON Schema for outputs
  metadata: ToolMetadata
}

/**
 * Execution context provided to every tool invocation
 */
export interface ExecutionContext {
  userId: string | null  // null for API-only calls
  workspaceId: string
  sessionId?: string
  requestContext: {
    ip?: string
    userAgent?: string
    source: 'ui' | 'api' | 'agent' | 'webhook'
  }
}

/**
 * Options for tool execution
 */
export interface ExecutionOptions {
  dryRun?: boolean
  context: ExecutionContext
}

/**
 * Result of a tool execution
 */
export interface ToolExecutionResult<T = unknown> {
  id: string
  toolName: string
  status: 'success' | 'error' | 'dry_run'
  outputs: T
  durationMs: number
  error?: {
    message: string
    stack?: string
  }
}

/**
 * Tool execution record (matches database schema)
 */
export interface ToolExecutionRecord {
  id: string
  workspace_id: string
  tool_name: string
  inputs: Record<string, unknown>
  outputs: Record<string, unknown>
  status: 'success' | 'error' | 'dry_run'
  error_message?: string
  error_stack?: string
  started_at: string
  completed_at: string
  duration_ms: number
  user_id?: string
  session_id?: string
  request_context: {
    ip?: string
    user_agent?: string
    source: 'ui' | 'api' | 'agent' | 'webhook'
  }
  snapshot_before?: Record<string, unknown>
  snapshot_after?: Record<string, unknown>
  batch_id?: string
  related_executions?: string[]
}

/**
 * Tool handler function signature
 */
export type ToolHandler<TInput = unknown, TOutput = unknown> = (
  input: TInput,
  context: ExecutionContext,
  dryRun: boolean
) => Promise<TOutput>

/**
 * Registered tool with handler
 */
export interface RegisteredTool<TInput = unknown, TOutput = unknown>
  extends ToolSchema<TInput, TOutput> {
  handler: ToolHandler<TInput, TOutput>
}

/**
 * Batch execution item
 */
export interface BatchItem {
  tool: string
  inputs: Record<string, unknown>
}

/**
 * Batch execution options
 */
export interface BatchOptions {
  atomic: boolean  // If true, rollback all on any failure
  context: ExecutionContext
}

/**
 * API Key record (matches database schema)
 */
export interface ApiKeyRecord {
  id: string
  workspace_id: string
  name: string
  key_prefix: string
  permissions: string[]
  revoked: boolean
  last_used_at?: string
  created_at: string
  expires_at?: string
}
```

This provides the complete type foundation for:
- Tool definition (schema + metadata)
- Execution context and options
- Execution results and records
- Handler signatures
- Batch operations
- API key management
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/tools/types.ts`
Imports work: Create test file that imports all types.
  </verify>
  <done>All tool types exported and TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
1. `npm ls ajv pino jose json-schema-to-typescript` shows all packages
2. Database tables exist (check via Supabase dashboard or psql)
3. `npx tsc --noEmit` passes with new types file
4. Types are importable from `@/lib/tools/types`
</verification>

<success_criteria>
- All dependencies installed (ajv, ajv-formats, pino, pino-http, jose, json-schema-to-typescript)
- tool_executions table exists with workspace RLS
- api_keys table exists for external auth
- Tool types compile and export correctly
- No TypeScript errors in the project
</success_criteria>

<output>
After completion, create `.planning/phases/03-action-dsl-core/03-01-SUMMARY.md`
</output>
