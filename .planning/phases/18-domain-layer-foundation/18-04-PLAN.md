---
phase: 18-domain-layer-foundation
plan: 04
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/lib/domain/contacts.ts
  - src/lib/domain/tags.ts
  - src/lib/domain/index.ts
autonomous: true

must_haves:
  truths:
    - "createContact domain function creates contact + emits contact.created trigger"
    - "updateContact domain function updates fields + emits field.changed triggers per changed field"
    - "deleteContact domain function deletes contact (no trigger currently defined)"
    - "bulkCreateContacts domain function creates multiple contacts + emits contact.created per contact"
    - "assignTag domain function assigns tag to contact or order + emits tag.assigned trigger"
    - "removeTag domain function removes tag from contact or order + emits tag.removed trigger"
  artifacts:
    - path: "src/lib/domain/contacts.ts"
      provides: "4 contact domain functions"
      exports: ["createContact", "updateContact", "deleteContact", "bulkCreateContacts"]
    - path: "src/lib/domain/tags.ts"
      provides: "2 tag domain functions (shared by contacts and orders)"
      exports: ["assignTag", "removeTag"]
  key_links:
    - from: "src/lib/domain/contacts.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "import emitContactCreated, emitFieldChanged"
      pattern: "trigger-emitter"
    - from: "src/lib/domain/tags.ts"
      to: "src/lib/automations/trigger-emitter.ts"
      via: "import emitTagAssigned, emitTagRemoved"
      pattern: "trigger-emitter"
---

<objective>
Create contact and tag domain functions. Tags are a shared entity (used by both contacts and orders), so they get their own file.

Purpose: Contacts + Tags have 3+ code paths each. The tag functions will also replace the order tag functions from Plan 02 (orders.ts addOrderTag/removeOrderTag can delegate to tags.ts, or the callers can call tags.ts directly — Claude's discretion on the cleanest approach).

Output: `src/lib/domain/contacts.ts` (4 functions), `src/lib/domain/tags.ts` (2 functions).
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/18-domain-layer-foundation/18-RESEARCH.md
@.planning/phases/18-domain-layer-foundation/18-01-SUMMARY.md

Key reference files (READ THESE for existing logic):
@src/app/actions/contacts.ts (server action implementations — createContact, updateContactFromForm, deleteContact, bulkCreateContacts, addTagToContact, removeTagFromContact, bulkAddTag, bulkRemoveTag)
@src/lib/tools/handlers/crm/index.ts (crm.contact.create, crm.contact.update, crm.contact.delete, crm.tag.add, crm.tag.remove handler logic)
@src/lib/automations/action-executor.ts (assign_tag, remove_tag, update_field action logic)
@src/lib/shopify/webhook-handler.ts (resolveContact logic for contact creation)
@src/lib/automations/trigger-emitter.ts (trigger signatures)
@src/lib/domain/types.ts (DomainContext, DomainResult)
@src/lib/utils/phone.ts (normalizePhone for contact phone normalization)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contacts domain functions</name>
  <files>src/lib/domain/contacts.ts</files>
  <action>
Create `src/lib/domain/contacts.ts` with 4 functions:

**createContact(ctx, params):**
- Params: name, phone?, email?, address?, city?, departamento?, tags?: string[] (tag names)
- Logic: Normalize phone if provided (import normalizePhone from utils). Insert into contacts with workspace_id. If tags provided, for each tag name: find tag by name+workspace, insert into contact_tags.
- Emit: `emitContactCreated({ workspaceId, contactId, contactName, contactPhone, contactEmail, contactCity, cascadeDepth })`
- Return: `{ contactId: string }`
- Handle duplicate phone gracefully (23505 unique constraint) — return error message, not throw.
- IMPORTANT: Study `src/app/actions/contacts.ts` createContact AND `src/lib/shopify/webhook-handler.ts` resolveContact for exact column names.

**updateContact(ctx, params):**
- Params: contactId, name?, phone?, email?, address?, city?, departamento?, customFields?: Record<string, unknown>
- Logic: Read current contact. Build update object from provided params. Update contacts row. For each changed standard field, emit `emitFieldChanged`. For custom_fields, if changed, merge JSONB and emit field.changed for each changed custom field key.
- Emit: `emitFieldChanged({ workspaceId, entityType: 'contact', entityId: contactId, fieldName, previousValue, newValue, contactId, contactName, cascadeDepth })` per changed field
- Return: `{ contactId: string }`
- IMPORTANT: Study existing server action `updateContactFromForm` for the field comparison logic.

**deleteContact(ctx, params):**
- Params: contactId
- Logic: Verify contact belongs to workspace. Delete from contacts (contact_tags cascade). No delete trigger currently defined.
- Return: `{ contactId: string }`

**bulkCreateContacts(ctx, params):**
- Params: contacts: Array<{ name, phone?, email?, address?, city? }>
- Logic: Insert batch into contacts with workspace_id. For each created contact, emit `emitContactCreated`. Use insert with returning to get IDs.
- Emit: `emitContactCreated` per contact (per-item as per CONTEXT.md decision)
- Return: `{ created: number, contactIds: string[] }`
- Note: Bulk operations emit per-item triggers (CONTEXT.md: "50 contacts = 50 events").
  </action>
  <verify>File compiles. 4 functions exported. Every mutation emits its trigger. createAdminClient used exclusively.</verify>
  <done>4 contact domain functions complete with trigger emission.</done>
</task>

<task type="auto">
  <name>Task 2: Create tags domain functions + update barrel export</name>
  <files>src/lib/domain/tags.ts, src/lib/domain/index.ts</files>
  <action>
Create `src/lib/domain/tags.ts` with 2 functions that handle BOTH contact tags AND order tags:

**assignTag(ctx, params):**
- Params: entityType: 'contact' | 'order', entityId: string, tagName: string
- Logic:
  1. Find tag by name + workspace_id in tags table. If not found, return error (don't auto-create).
  2. Determine junction table: entityType === 'contact' ? 'contact_tags' : 'order_tags'
  3. Determine FK column: entityType === 'contact' ? 'contact_id' : 'order_id'
  4. Insert into junction table. Handle 23505 (already assigned) gracefully = success.
  5. Fetch contactId for trigger context:
     - If entityType === 'contact', contactId = entityId
     - If entityType === 'order', query order's contact_id
  6. Also fetch contactName, contactPhone for rich trigger context.
- Emit: `emitTagAssigned({ workspaceId, entityType, entityId, tagId, tagName, contactId, contactName, contactPhone, cascadeDepth })`
- Return: `{ tagId: string }`

**removeTag(ctx, params):**
- Params: entityType: 'contact' | 'order', entityId: string, tagName: string
- Logic: Same tag lookup. Delete from junction table. Fetch contactId for context.
- Emit: `emitTagRemoved({ workspaceId, entityType, entityId, tagId, tagName, contactId, contactName, cascadeDepth })`
- Return: `{ tagId: string }`

**Important design decision:** Orders domain (Plan 02) has addOrderTag/removeOrderTag. Those can now be simplified to delegate to tags.ts, OR callers can directly use tags.ts. Claude's discretion — if orders.ts already works, it's fine to have both as long as they don't duplicate trigger emissions. Recommended: make orders.ts addOrderTag/removeOrderTag delegate to tags.ts functions (single source of truth for tag logic).

Update `src/lib/domain/index.ts`:
- Add `export * from './contacts'`
- Add `export * from './tags'`
  </action>
  <verify>File compiles. Both tag functions handle contact and order entity types. Barrel export includes contacts and tags. No circular deps.</verify>
  <done>Tag domain functions handle both entity types. Contacts + tags modules exported from barrel.</done>
</task>

</tasks>

<verification>
1. `src/lib/domain/contacts.ts` exports 4 functions
2. `src/lib/domain/tags.ts` exports 2 functions
3. Every function uses createAdminClient + workspace_id filter
4. createContact emits contact.created, updateContact emits field.changed per field, assignTag emits tag.assigned, removeTag emits tag.removed
5. bulkCreateContacts emits per-item triggers
6. Tags functions handle both 'contact' and 'order' entity types
7. `src/lib/domain/index.ts` re-exports contacts and tags
8. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- Contact and tag domain functions compile and follow DomainContext/DomainResult contract
- Tags are a shared module (not duplicated between contacts.ts and orders.ts)
- Per-item trigger emission for bulk operations
- Phone normalization applied on contact creation
</success_criteria>

<output>
After completion, create `.planning/phases/18-domain-layer-foundation/18-04-SUMMARY.md`
</output>
