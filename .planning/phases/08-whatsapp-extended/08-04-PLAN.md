---
phase: 08-whatsapp-extended
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/(dashboard)/whatsapp/components/template-button.tsx
  - src/app/(dashboard)/whatsapp/components/template-send-modal.tsx
  - src/app/(dashboard)/whatsapp/components/template-preview.tsx
  - src/app/(dashboard)/whatsapp/components/message-input.tsx
  - src/app/actions/messages.ts
autonomous: true

must_haves:
  truths:
    - "User can see 'Send Template' button when 24h window is closed"
    - "User can select from approved templates in modal"
    - "User sees preview with variables substituted before sending"
    - "Template message is sent via 360dialog API"
    - "Sent template appears in conversation history"
  artifacts:
    - path: "src/app/(dashboard)/whatsapp/components/template-send-modal.tsx"
      provides: "Modal for template selection and preview"
      min_lines: 100
    - path: "src/app/(dashboard)/whatsapp/components/template-preview.tsx"
      provides: "Template preview with variable substitution"
      min_lines: 40
  key_links:
    - from: "template-send-modal.tsx"
      to: "src/app/actions/messages.ts"
      via: "sendTemplateMessage action"
      pattern: "sendTemplateMessage"
    - from: "template-send-modal.tsx"
      to: "src/app/actions/templates.ts"
      via: "getApprovedTemplates action"
      pattern: "getApprovedTemplates"
---

<objective>
Enable users to send approved templates when the 24-hour window is closed.

Purpose: Allow continuing conversation with customers outside the service window (WAPP-04).
Output: Template button in chat, selection modal with preview, and template sending functionality.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-whatsapp-extended/08-CONTEXT.md
@.planning/phases/08-whatsapp-extended/08-RESEARCH.md
@src/app/(dashboard)/whatsapp/components/message-input.tsx
@src/app/actions/messages.ts
@src/app/actions/templates.ts
@src/lib/whatsapp/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Template Sending Server Action and API</name>
  <files>
    src/app/actions/messages.ts
    src/lib/whatsapp/api.ts
  </files>
  <action>
**Extend src/lib/whatsapp/api.ts** to add template sending:

```typescript
// Add to existing file

interface TemplateParameter {
  type: 'text'
  text: string
}

interface TemplateComponent {
  type: 'header' | 'body' | 'button'
  parameters?: TemplateParameter[]
}

export interface SendTemplateParams {
  to: string  // E.164 format
  template_name: string
  language_code: string
  components?: TemplateComponent[]
}

export async function sendTemplateMessage(
  apiKey: string,
  params: SendTemplateParams
): Promise<{ messages: { id: string }[] }> {
  const body = {
    messaging_product: 'whatsapp',
    recipient_type: 'individual',
    to: params.to,
    type: 'template',
    template: {
      name: params.template_name,
      language: {
        code: params.language_code
      },
      components: params.components || []
    }
  }

  const response = await fetch(`${BASE_URL}/v1/messages`, {
    method: 'POST',
    headers: {
      'D360-API-KEY': apiKey,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  })

  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error?.message || 'Failed to send template')
  }

  return response.json()
}
```

**Extend src/app/actions/messages.ts** to add sendTemplateMessage Server Action:

```typescript
// Add imports
import { sendTemplateMessage as sendTemplate360 } from '@/lib/whatsapp/api'
import { getTemplate } from './templates'

// Add new action
export async function sendTemplateMessage(params: {
  conversationId: string
  templateId: string
  variableValues: Record<string, string>  // "1" -> "Juan", "2" -> "12345"
}): Promise<void> {
  const supabase = await createClient()
  const workspaceId = await getWorkspaceId()

  if (!workspaceId) throw new Error('No workspace selected')

  // Get conversation to get recipient phone
  const { data: conversation, error: convError } = await supabase
    .from('conversations')
    .select('phone_number, contact_id')
    .eq('id', params.conversationId)
    .eq('workspace_id', workspaceId)
    .single()

  if (convError || !conversation) {
    throw new Error('Conversation not found')
  }

  // Get template
  const template = await getTemplate(params.templateId)
  if (!template || template.status !== 'APPROVED') {
    throw new Error('Template not found or not approved')
  }

  // Build template components with variable values
  const bodyComponent = template.components.find(c => c.type === 'BODY')
  const headerComponent = template.components.find(c => c.type === 'HEADER')

  const apiComponents: { type: string; parameters: { type: string; text: string }[] }[] = []

  // Extract variable numbers from body text and build parameters
  const bodyVars = bodyComponent?.text?.match(/\{\{(\d+)\}\}/g) || []
  if (bodyVars.length > 0) {
    apiComponents.push({
      type: 'body',
      parameters: bodyVars.map(v => {
        const num = v.replace(/[{}]/g, '')
        return { type: 'text', text: params.variableValues[num] || '' }
      })
    })
  }

  // Same for header if it has variables
  const headerVars = headerComponent?.text?.match(/\{\{(\d+)\}\}/g) || []
  if (headerVars.length > 0) {
    apiComponents.push({
      type: 'header',
      parameters: headerVars.map(v => {
        const num = v.replace(/[{}]/g, '')
        return { type: 'text', text: params.variableValues[num] || '' }
      })
    })
  }

  // Send via 360dialog
  const apiKey = process.env.WHATSAPP_API_KEY
  if (!apiKey) throw new Error('WhatsApp API key not configured')

  const response = await sendTemplate360(apiKey, {
    to: conversation.phone_number,
    template_name: template.name,
    language_code: template.language,
    components: apiComponents
  })

  // Store message in database
  const wamid = response.messages[0]?.id
  if (wamid) {
    // Build the rendered message text for display
    let renderedText = bodyComponent?.text || ''
    Object.entries(params.variableValues).forEach(([num, value]) => {
      renderedText = renderedText.replace(`{{${num}}}`, value)
    })

    await supabase.from('messages').insert({
      workspace_id: workspaceId,
      conversation_id: params.conversationId,
      wamid,
      direction: 'outbound',
      type: 'template',
      content: renderedText,
      template_name: template.name,
      status: 'sent',
      sent_at: new Date().toISOString()
    })

    // Update conversation
    await supabase
      .from('conversations')
      .update({
        last_message_at: new Date().toISOString(),
        last_message_preview: `[Template] ${template.name}`
      })
      .eq('id', params.conversationId)
  }

  revalidatePath('/whatsapp')
}
```

Note: The template_name column is added to messages table by Plan 08-01 migration (20260131000001_whatsapp_extended_foundation.sql).
  </action>
  <verify>Run `pnpm tsc --noEmit` to verify TypeScript compiles correctly.</verify>
  <done>sendTemplateMessage API function added to whatsapp/api.ts. sendTemplateMessage Server Action created that gets template, builds component parameters, sends via API, and stores message in database.</done>
</task>

<task type="auto">
  <name>Task 2: Template Selection Modal and Preview</name>
  <files>
    src/app/(dashboard)/whatsapp/components/template-send-modal.tsx
    src/app/(dashboard)/whatsapp/components/template-preview.tsx
  </files>
  <action>
**Create src/app/(dashboard)/whatsapp/components/template-preview.tsx:**

```typescript
'use client'

import { Template } from '@/lib/whatsapp/types'
import { Card, CardContent } from '@/components/ui/card'

interface TemplatePreviewProps {
  template: Template
  variableValues: Record<string, string>
}

export function TemplatePreview({ template, variableValues }: TemplatePreviewProps) {
  const bodyComponent = template.components.find(c => c.type === 'BODY')
  const headerComponent = template.components.find(c => c.type === 'HEADER')
  const footerComponent = template.components.find(c => c.type === 'FOOTER')

  // Replace variables with actual values
  const renderText = (text: string | undefined) => {
    if (!text) return null
    let rendered = text
    Object.entries(variableValues).forEach(([num, value]) => {
      rendered = rendered.replace(new RegExp(`\\{\\{${num}\\}\\}`, 'g'), value || `{{${num}}}`)
    })
    return rendered
  }

  return (
    <Card className="bg-[#dcf8c6] max-w-xs ml-auto">
      <CardContent className="p-3">
        {headerComponent?.text && (
          <p className="font-medium text-sm mb-1">
            {renderText(headerComponent.text)}
          </p>
        )}

        {bodyComponent?.text && (
          <p className="text-sm whitespace-pre-wrap">
            {renderText(bodyComponent.text)}
          </p>
        )}

        {footerComponent?.text && (
          <p className="text-xs text-muted-foreground mt-2">
            {renderText(footerComponent.text)}
          </p>
        )}
      </CardContent>
    </Card>
  )
}
```

**Create src/app/(dashboard)/whatsapp/components/template-send-modal.tsx:**

```typescript
'use client'

import { useState, useEffect } from 'react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { ScrollArea } from '@/components/ui/scroll-area'
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'
import { TemplatePreview } from './template-preview'
import { getApprovedTemplates } from '@/app/actions/templates'
import { sendTemplateMessage } from '@/app/actions/messages'
import { Template } from '@/lib/whatsapp/types'
import { toast } from 'sonner'
import { Loader2, FileText, ChevronRight, ArrowLeft } from 'lucide-react'

interface Contact {
  id: string
  name: string
  phone: string
  email?: string
  city?: string
}

interface Order {
  id: string
  total: number
  tracking_number?: string
  carrier?: string
}

interface TemplateSendModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  conversationId: string
  contact: Contact | null
  recentOrder?: Order | null
}

// Map field paths to actual values
function resolveFieldValue(
  path: string,
  contact: Contact | null,
  order: Order | null
): string {
  const [entity, field] = path.split('.')

  if (entity === 'contact' && contact) {
    switch (field) {
      case 'name': return contact.name || ''
      case 'phone': return contact.phone || ''
      case 'email': return contact.email || ''
      case 'city': return contact.city || ''
      default: return ''
    }
  }

  if (entity === 'order' && order) {
    switch (field) {
      case 'id': return order.id || ''
      case 'total': return order.total?.toLocaleString('es-CO', { style: 'currency', currency: 'COP' }) || ''
      case 'tracking_number': return order.tracking_number || ''
      case 'carrier': return order.carrier || ''
      default: return ''
    }
  }

  return path  // Return path as-is if custom value
}

export function TemplateSendModal({
  open,
  onOpenChange,
  conversationId,
  contact,
  recentOrder
}: TemplateSendModalProps) {
  const [step, setStep] = useState<'select' | 'preview'>('select')
  const [templates, setTemplates] = useState<Template[]>([])
  const [loading, setLoading] = useState(true)
  const [sending, setSending] = useState(false)
  const [selectedId, setSelectedId] = useState<string | null>(null)
  const [variableValues, setVariableValues] = useState<Record<string, string>>({})

  const selectedTemplate = templates.find(t => t.id === selectedId)

  useEffect(() => {
    if (open) {
      setStep('select')
      setSelectedId(null)
      setVariableValues({})
      loadTemplates()
    }
  }, [open])

  async function loadTemplates() {
    setLoading(true)
    try {
      const data = await getApprovedTemplates()
      setTemplates(data)
    } catch (error) {
      toast.error('Error al cargar templates')
    } finally {
      setLoading(false)
    }
  }

  function handleSelectTemplate(templateId: string) {
    setSelectedId(templateId)
    const template = templates.find(t => t.id === templateId)

    if (template) {
      // Pre-fill variables from mapping
      const values: Record<string, string> = {}
      Object.entries(template.variable_mapping || {}).forEach(([num, path]) => {
        values[num] = resolveFieldValue(path, contact, recentOrder || null)
      })
      setVariableValues(values)
    }
  }

  function handleContinue() {
    if (selectedTemplate) {
      setStep('preview')
    }
  }

  async function handleSend() {
    if (!selectedTemplate) return

    setSending(true)
    try {
      await sendTemplateMessage({
        conversationId,
        templateId: selectedTemplate.id,
        variableValues
      })
      toast.success('Template enviado')
      onOpenChange(false)
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Error al enviar template')
    } finally {
      setSending(false)
    }
  }

  // Extract variables from template
  const getVariables = (template: Template) => {
    const bodyText = template.components.find(c => c.type === 'BODY')?.text || ''
    const headerText = template.components.find(c => c.type === 'HEADER')?.text || ''
    const allText = bodyText + headerText
    const matches = allText.match(/\{\{(\d+)\}\}/g) || []
    return [...new Set(matches)].map(m => m.replace(/[{}]/g, ''))
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle>
            {step === 'select' ? 'Enviar Template' : 'Vista Previa'}
          </DialogTitle>
          <DialogDescription>
            {step === 'select'
              ? 'Selecciona un template aprobado para enviar'
              : 'Verifica el mensaje antes de enviar'}
          </DialogDescription>
        </DialogHeader>

        {step === 'select' && (
          <>
            {loading ? (
              <div className="py-8 text-center">
                <Loader2 className="h-6 w-6 animate-spin mx-auto" />
                <p className="text-sm text-muted-foreground mt-2">Cargando templates...</p>
              </div>
            ) : templates.length === 0 ? (
              <div className="py-8 text-center">
                <FileText className="h-8 w-8 mx-auto text-muted-foreground" />
                <p className="mt-2 font-medium">No hay templates aprobados</p>
                <p className="text-sm text-muted-foreground">
                  Crea un template en Configuracion y espera la aprobacion de Meta
                </p>
              </div>
            ) : (
              <ScrollArea className="h-[300px] -mx-6 px-6">
                <RadioGroup value={selectedId || ''} onValueChange={handleSelectTemplate}>
                  <div className="space-y-2">
                    {templates.map((template) => (
                      <div
                        key={template.id}
                        className={`flex items-center p-3 border rounded-lg cursor-pointer transition-colors ${
                          selectedId === template.id ? 'border-primary bg-primary/5' : 'hover:bg-muted/50'
                        }`}
                        onClick={() => handleSelectTemplate(template.id)}
                      >
                        <RadioGroupItem value={template.id} id={template.id} />
                        <div className="ml-3 flex-1">
                          <Label htmlFor={template.id} className="cursor-pointer font-medium">
                            {template.name}
                          </Label>
                          <p className="text-xs text-muted-foreground mt-0.5">
                            {template.components.find(c => c.type === 'BODY')?.text?.slice(0, 60)}...
                          </p>
                        </div>
                      </div>
                    ))}
                  </div>
                </RadioGroup>
              </ScrollArea>
            )}

            <DialogFooter>
              <Button variant="outline" onClick={() => onOpenChange(false)}>
                Cancelar
              </Button>
              <Button onClick={handleContinue} disabled={!selectedId}>
                Continuar
                <ChevronRight className="h-4 w-4 ml-1" />
              </Button>
            </DialogFooter>
          </>
        )}

        {step === 'preview' && selectedTemplate && (
          <>
            <div className="space-y-4">
              {/* Variable inputs */}
              {getVariables(selectedTemplate).length > 0 && (
                <div className="space-y-3">
                  <p className="text-sm font-medium">Variables</p>
                  {getVariables(selectedTemplate).map((num) => {
                    const mapping = selectedTemplate.variable_mapping?.[num]
                    return (
                      <div key={num} className="flex items-center gap-3">
                        <span className="text-sm font-mono bg-muted px-2 py-1 rounded min-w-[50px] text-center">
                          {`{{${num}}}`}
                        </span>
                        <Input
                          value={variableValues[num] || ''}
                          onChange={(e) => setVariableValues({
                            ...variableValues,
                            [num]: e.target.value
                          })}
                          placeholder={mapping || 'Valor...'}
                          className="flex-1"
                        />
                      </div>
                    )
                  })}
                </div>
              )}

              {/* Preview */}
              <div>
                <p className="text-sm font-medium mb-2">Vista previa</p>
                <div className="bg-muted/30 rounded-lg p-4">
                  <TemplatePreview
                    template={selectedTemplate}
                    variableValues={variableValues}
                  />
                </div>
              </div>
            </div>

            <DialogFooter>
              <Button variant="outline" onClick={() => setStep('select')}>
                <ArrowLeft className="h-4 w-4 mr-1" />
                Atras
              </Button>
              <Button onClick={handleSend} disabled={sending}>
                {sending && <Loader2 className="h-4 w-4 mr-2 animate-spin" />}
                Enviar Template
              </Button>
            </DialogFooter>
          </>
        )}
      </DialogContent>
    </Dialog>
  )
}
```

Note: RadioGroup component may need to be added if not present. Use shadcn/ui.
  </action>
  <verify>Run `pnpm tsc --noEmit` to verify components compile. Check that RadioGroup is available from shadcn/ui.</verify>
  <done>TemplateSendModal created with two steps: template selection with radio buttons, and preview with editable variables. TemplatePreview renders template with substituted variables in WhatsApp-style bubble.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Template Button into Chat</name>
  <files>
    src/app/(dashboard)/whatsapp/components/template-button.tsx
    src/app/(dashboard)/whatsapp/components/message-input.tsx
  </files>
  <action>
**Create src/app/(dashboard)/whatsapp/components/template-button.tsx:**

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { FileText } from 'lucide-react'
import { TemplateSendModal } from './template-send-modal'

interface Contact {
  id: string
  name: string
  phone: string
  email?: string
  city?: string
}

interface Order {
  id: string
  total: number
  tracking_number?: string
  carrier?: string
}

interface TemplateButtonProps {
  conversationId: string
  contact: Contact | null
  recentOrder?: Order | null
  disabled?: boolean
}

export function TemplateButton({
  conversationId,
  contact,
  recentOrder,
  disabled
}: TemplateButtonProps) {
  const [open, setOpen] = useState(false)

  return (
    <>
      <Button
        variant="outline"
        size="sm"
        onClick={() => setOpen(true)}
        disabled={disabled}
        className="flex items-center gap-2"
      >
        <FileText className="h-4 w-4" />
        Enviar Template
      </Button>

      <TemplateSendModal
        open={open}
        onOpenChange={setOpen}
        conversationId={conversationId}
        contact={contact}
        recentOrder={recentOrder}
      />
    </>
  )
}
```

**Modify src/app/(dashboard)/whatsapp/components/message-input.tsx:**

Integrate the TemplateButton when the 24h window is closed:

```typescript
// Add imports at top
import { TemplateButton } from './template-button'

// In the component, add props for contact and order
interface MessageInputProps {
  conversationId: string
  isWindowOpen: boolean
  contact?: Contact | null
  recentOrder?: Order | null
  onSend: (content: string, type?: string) => Promise<void>
}

// In the render, when isWindowOpen is false, show template button
// Replace or extend the disabled state UI:

{!isWindowOpen && (
  <div className="flex items-center justify-between p-3 bg-yellow-50 border-t border-yellow-100">
    <div className="text-sm text-yellow-800">
      <p className="font-medium">Ventana de 24h cerrada</p>
      <p className="text-xs">Solo puedes enviar templates aprobados</p>
    </div>
    <TemplateButton
      conversationId={conversationId}
      contact={contact}
      recentOrder={recentOrder}
    />
  </div>
)}

{isWindowOpen && (
  // Existing message input UI
  <div className="p-3 border-t">
    {/* ... existing input with emoji picker, file upload, etc. */}
  </div>
)}
```

The exact integration depends on the current message-input.tsx structure. Key points:
1. Add contact and recentOrder props
2. When window closed, show warning bar with TemplateButton instead of disabled input
3. When window open, show normal input as before

Modify parent component (chat-view.tsx or inbox-layout.tsx) to pass contact and recentOrder to MessageInput.
  </action>
  <verify>Run `pnpm tsc --noEmit` to verify components compile. Test that TemplateButton appears when 24h window is closed.</verify>
  <done>TemplateButton component created. MessageInput modified to show template button when 24h window is closed instead of disabled input. Warning message explains the limitation.</done>
</task>

</tasks>

<verification>
1. sendTemplateMessage API function sends correct payload to 360dialog
2. Template messages are stored in database with correct type
3. Modal shows only approved templates
4. Variable values are pre-filled from contact/order based on mapping
5. Preview shows message with substituted variables
6. Template button appears when 24h window is closed
7. Sent template appears in conversation history
</verification>

<success_criteria>
- API function compiles and exports correctly
- Server Action handles variable substitution
- Modal has two-step flow (select -> preview)
- Variables can be edited before sending
- Template button shows in chat when window closed
- Message stored with type='template' and template_name
</success_criteria>

<output>
After completion, create `.planning/phases/08-whatsapp-extended/08-04-SUMMARY.md`
</output>
