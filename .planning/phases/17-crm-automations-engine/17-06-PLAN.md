---
phase: 17-crm-automations-engine
plan: 06
type: execute
wave: 4
depends_on: ["17-02", "17-04"]
files_modified:
  - src/inngest/events.ts
  - src/inngest/client.ts
  - src/inngest/functions/automation-runner.ts
  - src/app/api/inngest/route.ts
autonomous: true

must_haves:
  truths:
    - "Inngest functions process automation trigger events and execute matching automations"
    - "Conditions evaluated in TypeScript before action execution"
    - "Actions execute sequentially with delays via step.sleep()"
    - "Execution logged to automation_executions table with per-action results"
    - "Disabled automations checked before each action (mid-execution disable)"
  artifacts:
    - path: "src/inngest/functions/automation-runner.ts"
      provides: "Inngest durable functions for automation execution"
      exports: ["automationFunctions"]
    - path: "src/inngest/events.ts"
      provides: "Extended event types including automation events"
      contains: "AutomationEvents"
  key_links:
    - from: "src/inngest/functions/automation-runner.ts"
      to: "src/lib/automations/condition-evaluator.ts"
      via: "evaluateConditionGroup for condition checking"
      pattern: "evaluateConditionGroup"
    - from: "src/inngest/functions/automation-runner.ts"
      to: "src/lib/automations/action-executor.ts"
      via: "executeAction for each action in sequence"
      pattern: "executeAction"
    - from: "src/app/api/inngest/route.ts"
      to: "src/inngest/functions/automation-runner.ts"
      via: "Registers automation functions in serve()"
      pattern: "automationFunctions"
---

<objective>
Create the Inngest automation runner functions that listen for trigger events, evaluate conditions, and execute action sequences with durable execution guarantees.

Purpose: This is the runtime engine. When a trigger event fires (emitted by trigger-emitter.ts), Inngest invokes the matching runner function. The runner loads all enabled automations for that trigger type and workspace, evaluates conditions, and executes actions sequentially using step.run() and step.sleep(). Each execution is logged to the automation_executions table.

Output: Inngest function definitions, extended event types, updated route registration.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-crm-automations-engine/17-CONTEXT.md
@.planning/phases/17-crm-automations-engine/17-RESEARCH.md
@src/inngest/events.ts
@src/inngest/client.ts
@src/inngest/functions/agent-timers.ts
@src/app/api/inngest/route.ts
@src/lib/automations/types.ts
@src/lib/automations/condition-evaluator.ts
@src/lib/automations/action-executor.ts
@src/lib/automations/variable-resolver.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Inngest events and client with automation event types</name>
  <files>src/inngest/events.ts, src/inngest/client.ts</files>
  <action>
**File 1: src/inngest/events.ts**
Add a new `AutomationEvents` type after the existing `IngestEvents` type:

```typescript
// ============================================================================
// Automation Events (Phase 17: CRM Automations Engine)
// ============================================================================

export type AutomationEvents = {
  'automation/order.stage_changed': {
    data: {
      workspaceId: string
      orderId: string
      previousStageId: string
      newStageId: string
      pipelineId: string
      contactId: string | null
      previousStageName?: string
      newStageName?: string
      pipelineName?: string
      contactName?: string
      contactPhone?: string
      cascadeDepth: number
    }
  }
  'automation/tag.assigned': {
    data: {
      workspaceId: string
      entityType: 'contact' | 'order' | 'conversation'
      entityId: string
      tagId: string
      tagName: string
      contactId?: string
      contactName?: string
      cascadeDepth: number
    }
  }
  'automation/tag.removed': {
    data: {
      workspaceId: string
      entityType: 'contact' | 'order' | 'conversation'
      entityId: string
      tagId: string
      tagName: string
      contactId?: string
      cascadeDepth: number
    }
  }
  'automation/contact.created': {
    data: {
      workspaceId: string
      contactId: string
      contactName: string
      contactPhone: string
      contactEmail?: string
      contactCity?: string
      cascadeDepth: number
    }
  }
  'automation/order.created': {
    data: {
      workspaceId: string
      orderId: string
      pipelineId: string
      stageId: string
      contactId: string | null
      totalValue: number
      sourceOrderId?: string
      cascadeDepth: number
    }
  }
  'automation/field.changed': {
    data: {
      workspaceId: string
      entityType: 'contact' | 'order'
      entityId: string
      fieldName: string
      previousValue: unknown
      newValue: unknown
      cascadeDepth: number
    }
  }
  'automation/whatsapp.message_received': {
    data: {
      workspaceId: string
      conversationId: string
      contactId: string | null
      messageContent: string
      phone: string
      cascadeDepth: number
    }
  }
  'automation/whatsapp.keyword_match': {
    data: {
      workspaceId: string
      conversationId: string
      contactId: string | null
      messageContent: string
      phone: string
      keywordMatched: string
      cascadeDepth: number
    }
  }
  'automation/task.completed': {
    data: {
      workspaceId: string
      taskId: string
      taskTitle: string
      contactId: string | null
      orderId: string | null
      cascadeDepth: number
    }
  }
  'automation/task.overdue': {
    data: {
      workspaceId: string
      taskId: string
      taskTitle: string
      dueDate: string
      contactId: string | null
      orderId: string | null
      cascadeDepth: number
    }
  }
}
```

Update `AllAgentEvents` to include automation events:
```typescript
export type AllAgentEvents = AgentEvents & IngestEvents & AutomationEvents
```

**File 2: src/inngest/client.ts**
No changes needed — the client already uses `AllAgentEvents` via `fromRecord<AllAgentEvents>()`, so adding `AutomationEvents` to the union automatically extends the client's type system.

Verify this is the case. If `AllAgentEvents` is NOT used in client.ts, update to use it.
  </action>
  <verify>AutomationEvents type added to events.ts. AllAgentEvents includes AutomationEvents. Client type system includes new events. TypeScript compiles.</verify>
  <done>Inngest event types extended with 10 automation trigger event types. Client automatically picks them up via AllAgentEvents union.</done>
</task>

<task type="auto">
  <name>Task 2: Automation runner Inngest functions and route registration</name>
  <files>src/inngest/functions/automation-runner.ts, src/app/api/inngest/route.ts</files>
  <action>
**File 1: src/inngest/functions/automation-runner.ts**

Create a generic automation runner pattern. Instead of one function per trigger type (which would be 10 nearly-identical functions), use a factory that creates runners for each trigger type.

```typescript
import { inngest } from '@/inngest/client'
import { createAdminClient } from '@/lib/supabase/admin'
import { evaluateConditionGroup } from '@/lib/automations/condition-evaluator'
import { executeAction } from '@/lib/automations/action-executor'
import { buildTriggerContext } from '@/lib/automations/variable-resolver'
import { delayToMs } from '@/lib/automations/constants'
import type { Automation, TriggerType, TriggerContext } from '@/lib/automations/types'
```

**Factory function:**
```typescript
function createAutomationRunner(triggerType: TriggerType, eventName: string) {
  return inngest.createFunction(
    {
      id: `automation-${triggerType.replace('.', '-')}`,
      name: `Automation: ${triggerType}`,
      retries: 2,
      concurrency: [{ key: 'event.data.workspaceId', limit: 5 }],
    },
    { event: eventName as any },
    async ({ event, step }) => {
      const { workspaceId, cascadeDepth } = event.data as any

      // 1. Load matching automations
      const automations = await step.run('load-automations', async () => {
        const supabase = createAdminClient()
        const { data } = await supabase
          .from('automations')
          .select('*')
          .eq('workspace_id', workspaceId)
          .eq('trigger_type', triggerType)
          .eq('is_enabled', true)
        return (data ?? []) as Automation[]
      })

      if (automations.length === 0) return { processed: 0 }

      // 2. Build trigger context
      const context = buildTriggerContext(event.data as Record<string, unknown>)

      // 3. Process each matching automation
      let processed = 0
      for (const automation of automations) {
        // Check trigger config filter (e.g., specific pipeline)
        if (!matchesTriggerConfig(automation, event.data as Record<string, unknown>)) continue

        // Evaluate conditions
        if (automation.conditions) {
          const matches = evaluateConditionGroup(automation.conditions, context)
          if (!matches) continue
        }

        processed++

        // Create execution record
        const executionId = await step.run(`create-exec-${automation.id}`, async () => {
          const supabase = createAdminClient()
          const { data } = await supabase
            .from('automation_executions')
            .insert({
              workspace_id: workspaceId,
              automation_id: automation.id,
              trigger_event: event.data,
              status: 'running',
              cascade_depth: cascadeDepth,
            })
            .select('id')
            .single()
          return data?.id
        })

        // Execute actions sequentially
        let failed = false
        const actionsLog: any[] = []

        for (let i = 0; i < automation.actions.length; i++) {
          const action = automation.actions[i]

          // Check if automation still enabled (Pitfall 6)
          const stillEnabled = await step.run(`check-enabled-${automation.id}-${i}`, async () => {
            const supabase = createAdminClient()
            const { data } = await supabase
              .from('automations')
              .select('is_enabled')
              .eq('id', automation.id)
              .single()
            return data?.is_enabled ?? false
          })

          if (!stillEnabled) {
            // Mark as cancelled
            await step.run(`cancel-${automation.id}`, async () => {
              const supabase = createAdminClient()
              await supabase
                .from('automation_executions')
                .update({
                  status: 'cancelled',
                  completed_at: new Date().toISOString(),
                  actions_log: actionsLog,
                })
                .eq('id', executionId)
            })
            break
          }

          // Optional delay
          if (action.delay) {
            const ms = delayToMs(action.delay)
            if (ms > 0) {
              await step.sleep(`delay-${automation.id}-${i}`, ms)
            }
          }

          // Execute action
          const result = await step.run(`action-${automation.id}-${i}`, async () => {
            return executeAction(action, context as TriggerContext, workspaceId, cascadeDepth)
          })

          actionsLog.push({
            index: i,
            type: action.type,
            status: result.success ? 'success' : 'failed',
            result: result.result,
            duration_ms: result.duration_ms,
            error: result.error,
          })

          // Stop on failure (CONTEXT.md: error handling -> stop sequence)
          if (!result.success) {
            failed = true
            await step.run(`fail-exec-${automation.id}`, async () => {
              const supabase = createAdminClient()
              await supabase
                .from('automation_executions')
                .update({
                  status: 'failed',
                  error_message: result.error,
                  completed_at: new Date().toISOString(),
                  actions_log: actionsLog,
                  duration_ms: actionsLog.reduce((sum, a) => sum + a.duration_ms, 0),
                })
                .eq('id', executionId)
            })
            break
          }
        }

        // Mark success if all actions completed
        if (!failed) {
          await step.run(`complete-exec-${automation.id}`, async () => {
            const supabase = createAdminClient()
            await supabase
              .from('automation_executions')
              .update({
                status: 'success',
                completed_at: new Date().toISOString(),
                actions_log: actionsLog,
                duration_ms: actionsLog.reduce((sum, a) => sum + a.duration_ms, 0),
              })
              .eq('id', executionId)
          })
        }
      }

      return { processed }
    }
  )
}
```

**Helper: matchesTriggerConfig**
Checks trigger-specific filters:
- `order.stage_changed`: if trigger_config has pipelineId, check event.data.pipelineId matches. If has stageId, check newStageId matches.
- `tag.assigned`/`tag.removed`: if trigger_config has tagId, check event.data.tagId matches.
- `order.created`: if trigger_config has pipelineId, check matches.
- `whatsapp.keyword_match`: already filtered by keyword before emitting (the emitter only fires if keyword matches).
- `field.changed`: if trigger_config has fieldName, check matches.
- Others: no filter needed, return true.

**Create all 10 runner instances:**
```typescript
export const automationFunctions = [
  createAutomationRunner('order.stage_changed', 'automation/order.stage_changed'),
  createAutomationRunner('tag.assigned', 'automation/tag.assigned'),
  createAutomationRunner('tag.removed', 'automation/tag.removed'),
  createAutomationRunner('contact.created', 'automation/contact.created'),
  createAutomationRunner('order.created', 'automation/order.created'),
  createAutomationRunner('field.changed', 'automation/field.changed'),
  createAutomationRunner('whatsapp.message_received', 'automation/whatsapp.message_received'),
  createAutomationRunner('whatsapp.keyword_match', 'automation/whatsapp.keyword_match'),
  createAutomationRunner('task.completed', 'automation/task.completed'),
  createAutomationRunner('task.overdue', 'automation/task.overdue'),
]
```

**File 2: src/app/api/inngest/route.ts**
Add automation functions to the serve() call:
```typescript
import { automationFunctions } from '@/inngest/functions/automation-runner'

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [
    ...agentTimerFunctions,
    ...agentProductionFunctions,
    ...automationFunctions,
  ],
})
```
  </action>
  <verify>10 automation runner functions created. Route.ts registers all automation functions. Actions execute sequentially with delay support. Execution logged to DB. Mid-execution disable check works. TypeScript compiles.

**matchesTriggerConfig inline test cases (add as comments in the function):**
```typescript
// TEST CASES for matchesTriggerConfig:
// 1. order.stage_changed + trigger_config: { pipelineId: 'p1' } + event: { pipelineId: 'p1' } → true
// 2. order.stage_changed + trigger_config: { pipelineId: 'p1' } + event: { pipelineId: 'p2' } → false
// 3. order.stage_changed + trigger_config: { pipelineId: 'p1', stageId: 's1' } + event: { pipelineId: 'p1', newStageId: 's1' } → true
// 4. order.stage_changed + trigger_config: { pipelineId: 'p1', stageId: 's1' } + event: { pipelineId: 'p1', newStageId: 's2' } → false
// 5. order.stage_changed + trigger_config: {} + event: { pipelineId: 'p1' } → true (no filter = match all)
// 6. tag.assigned + trigger_config: { tagId: 't1' } + event: { tagId: 't1' } → true
// 7. tag.assigned + trigger_config: { tagId: 't1' } + event: { tagId: 't2' } → false
// 8. tag.assigned + trigger_config: {} + event: { tagId: 't1' } → true (no filter)
// 9. order.created + trigger_config: { pipelineId: 'p1' } + event: { pipelineId: 'p2' } → false
// 10. field.changed + trigger_config: { fieldName: 'city' } + event: { fieldName: 'city' } → true
// 11. field.changed + trigger_config: { fieldName: 'city' } + event: { fieldName: 'email' } → false
// 12. whatsapp.message_received + trigger_config: {} + event: { ... } → true (always matches)
// 13. task.completed + trigger_config: {} + event: { ... } → true (always matches)
```
Verify ALL 13 test cases are included as comments in matchesTriggerConfig.</verify>
  <done>10 Inngest automation runner functions registered, each processing matching automations with condition evaluation, sequential action execution, delay support, mid-execution disable check, and full execution logging.</done>
</task>

</tasks>

<verification>
1. AutomationEvents type has all 10 trigger event types
2. AllAgentEvents includes AutomationEvents
3. 10 runner functions created via factory pattern
4. Each runner: loads automations, evaluates conditions, executes actions, logs execution
5. matchesTriggerConfig filters by pipeline, tag, keyword, field as appropriate
6. Delays use step.sleep() (durable, survives restarts)
7. Mid-execution disable check before each action
8. Route.ts serves all automation functions
9. TypeScript compiles
</verification>

<success_criteria>
- Automation events fully typed in Inngest type system
- Runner functions handle all 10 trigger types
- Conditions evaluated before execution
- Actions execute sequentially with durable delays
- Execution history logged to automation_executions table
- All functions registered in Inngest route
</success_criteria>

<output>
After completion, create `.planning/phases/17-crm-automations-engine/17-06-SUMMARY.md`
</output>
