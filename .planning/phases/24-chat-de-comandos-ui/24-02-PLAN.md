---
phase: 24-chat-de-comandos-ui
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/app/actions/comandos.ts
  - src/hooks/use-robot-job-progress.ts
autonomous: true

must_haves:
  truths:
    - "Server action executeSubirOrdenesCoord fetches orders from the dispatch stage, validates cities, creates a robot job, and emits Inngest event"
    - "Server action returns structured result with jobId, valid/invalid counts, and invalid order details"
    - "Server action getJobStatus returns job status plus items for an active job"
    - "Server action getCommandHistory returns recent jobs for the workspace"
    - "Realtime hook subscribes to robot_job_items and robot_jobs changes for a given job ID"
    - "Realtime hook returns items array, job status, success/error counts that update live"
    - "buildPedidoInputFromOrder helper correctly assembles PedidoInput with sensible defaults for missing fields"
  artifacts:
    - path: "src/app/actions/comandos.ts"
      provides: "Server actions for command execution, job status, and history"
      exports: ["executeSubirOrdenesCoord", "getJobStatus", "getCommandHistory"]
    - path: "src/hooks/use-robot-job-progress.ts"
      provides: "Supabase Realtime hook for live job progress"
      exports: ["useRobotJobProgress"]
  key_links:
    - from: "src/app/actions/comandos.ts"
      to: "src/lib/domain/carrier-configs.ts"
      via: "getCarrierCredentials + getDispatchStage"
      pattern: "getCarrierCredentials|getDispatchStage"
    - from: "src/app/actions/comandos.ts"
      to: "src/lib/domain/carrier-coverage.ts"
      via: "validateCities batch call"
      pattern: "validateCities"
    - from: "src/app/actions/comandos.ts"
      to: "src/lib/domain/robot-jobs.ts"
      via: "createRobotJob + getActiveJob"
      pattern: "createRobotJob|getActiveJob"
    - from: "src/app/actions/comandos.ts"
      to: "src/inngest/client.ts"
      via: "inngest.send for robot/job.submitted"
      pattern: "inngest\\.send"
    - from: "src/hooks/use-robot-job-progress.ts"
      to: "Supabase Realtime"
      via: "postgres_changes subscription"
      pattern: "supabase\\.channel.*robot"
---

<objective>
Build the server actions that power the command execution flow and the Realtime hook that powers live progress display.

Purpose: The `subir ordenes coord` command needs a server action that orchestrates the full flow (credentials -> orders -> city validation -> job creation -> Inngest dispatch). The UI needs a Realtime hook to show per-order progress as the robot processes.

Output: Server actions file with full command flow, Realtime subscription hook.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/24-chat-de-comandos-ui/24-01-SUMMARY.md

@src/lib/domain/carrier-configs.ts
@src/lib/domain/carrier-coverage.ts
@src/lib/domain/robot-jobs.ts
@src/lib/domain/orders.ts
@src/lib/domain/types.ts
@src/lib/logistics/constants.ts
@src/inngest/client.ts
@src/inngest/events.ts
@src/hooks/use-conversations.ts
@src/hooks/use-messages.ts
@src/app/actions/orders.ts
@src/lib/supabase/client.ts
@src/lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server actions for command execution and queries</name>
  <files>src/app/actions/comandos.ts</files>
  <action>
  Create `src/app/actions/comandos.ts` with `'use server'` directive. This file contains all server actions for the Comandos module.

  **Auth helper** (reuse pattern from orders.ts):
  ```typescript
  async function getAuthContext(): Promise<{ workspaceId: string } | { error: string }>
  ```
  Uses `createClient()` from `@/lib/supabase/server`, `cookies()` for workspace_id.

  **Types** (defined at top of file):
  ```typescript
  interface CommandResult<T = unknown> {
    success: boolean
    data?: T
    error?: string
  }

  interface SubirOrdenesResult {
    jobId: string
    totalOrders: number
    validCount: number
    invalidCount: number
    invalidOrders: Array<{ orderId: string; orderName: string | null; reason: string }>
  }

  interface OrderForDispatch {
    id: string
    name: string | null
    contact_id: string | null
    contact_name: string | null
    contact_phone: string | null
    contact_email: string | null
    shipping_address: string | null
    shipping_city: string | null
    shipping_department: string | null
    total_value: number
    products: Array<{ quantity: number }>
    custom_fields: Record<string, unknown>
  }
  ```

  **buildPedidoInputFromOrder helper** (private function in this file):
  Takes `(order: OrderForDispatch, cityValidation: CityValidationItem)` and returns `PedidoInput`.

  Logic:
  - `identificacion`: order.custom_fields?.identificacion as string || "N/A"
  - `nombres` / `apellidos`: Split contact_name on first space. First part = nombres, rest = apellidos. If single word, apellidos = "". If no name, nombres = "Cliente", apellidos = "".
  - `direccion`: order.shipping_address || "Sin direccion"
  - `ciudad`: cityValidation.coordinadoraCity! (guaranteed valid at this point)
  - `departamento`: cityValidation.departmentAbbrev! (guaranteed valid)
  - `celular`: order.contact_phone || "0000000000"
  - `email`: order.contact_email || "sin@email.com"
  - `referencia`: order.name || order.id.slice(0, 8)
  - `unidades`: Sum of product quantities, minimum 1
  - `totalConIva`: order.total_value || 0
  - `valorDeclarado`: order.total_value || 0
  - `esRecaudoContraentrega`: false (default, configurable later)
  - `peso`: 1, `alto`: 10, `largo`: 10, `ancho`: 10

  **executeSubirOrdenesCoord** (exported async function):
  Returns `Promise<CommandResult<SubirOrdenesResult>>`.

  Full flow:
  1. Get auth context (workspace_id).
  2. Build `DomainContext` with `{ workspaceId, source: 'server-action' }`.
  3. Call `getCarrierCredentials(ctx)` -- return error if not configured.
  4. Call `getDispatchStage(ctx)` -- return error if not configured ("Etapa de despacho no configurada. Configure la etapa en Configuracion > Logistica.").
  5. Check for existing active job via `getActiveJob(ctx)` -- return error if job already running ("Ya hay un job activo en progreso").
  6. Fetch orders from the dispatch stage using `createAdminClient()`:
     ```
     .from('orders')
     .select('id, name, contact_id, shipping_address, shipping_city, shipping_department, total_value, custom_fields, contacts(name, phone, email), order_products(quantity)')
     .eq('workspace_id', ctx.workspaceId)
     .eq('stage_id', dispatchStage.stageId)
     ```
     If no orders found, return error ("No hay pedidos en la etapa de despacho").
  7. Map orders into `OrderForDispatch[]` (extract contact name/phone/email from joined data, sum product quantities).
  8. Call `validateCities(ctx, { cities: orders.map(o => ({ city: o.shipping_city || '', department: o.shipping_department || '', orderId: o.id })) })`.
  9. Separate valid and invalid orders based on validation results.
  10. If no valid orders, return error with invalid details ("Todas las ordenes tienen ciudades invalidas").
  11. Call `createRobotJob(ctx, { orderIds: validOrderIds })`.
  12. Build PedidoInput for each valid order using `buildPedidoInputFromOrder()`.
  13. Dispatch to Inngest:
      ```typescript
      await (inngest.send as any)({
        name: 'robot/job.submitted',
        data: {
          jobId: job.data.jobId,
          workspaceId: ctx.workspaceId,
          carrier: 'coordinadora',
          credentials: creds.data,
          orders: job.data.items.map((item, idx) => ({
            itemId: item.itemId,
            orderId: item.orderId,
            pedidoInput: pedidoInputs[idx],
          })),
        },
      })
      ```
      CRITICAL: ALWAYS await inngest.send in serverless (Vercel terminates early otherwise).
  14. Return success with SubirOrdenesResult.

  **getJobStatus** (exported async function):
  Returns `Promise<CommandResult<GetJobWithItemsResult | null>>`.
  - Gets auth context
  - Calls `getActiveJob(ctx)` from robot-jobs domain
  - Returns the active job with items (or null if none)

  **getCommandHistory** (exported async function):
  Returns `Promise<CommandResult<RobotJob[]>>`.
  - Gets auth context
  - Calls `getJobHistory(ctx, 20)` from robot-jobs domain
  - Returns the jobs array

  IMPORTANT: Import inngest client from `@/inngest/client` (check exact path in existing codebase, same as robot-orchestrator.ts uses).
  IMPORTANT: All domain calls use `createAdminClient()` but this file is a server action so auth is handled via cookies + Supabase auth first.
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - File has `'use server'` directive at top
  - `executeSubirOrdenesCoord`, `getJobStatus`, `getCommandHistory` are exported
  - `buildPedidoInputFromOrder` is a private function (not exported)
  - Inngest send is awaited (not fire-and-forget)
  - Auth check happens before any domain calls
  </verify>
  <done>Server actions file handles the full subir ordenes coord flow (credentials -> orders -> validate -> job -> inngest), plus job status and history queries.</done>
</task>

<task type="auto">
  <name>Task 2: Supabase Realtime hook for live job progress</name>
  <files>src/hooks/use-robot-job-progress.ts</files>
  <action>
  Create `src/hooks/use-robot-job-progress.ts` following the pattern from `use-messages.ts` and `use-conversations.ts`.

  **Hook signature:**
  ```typescript
  export function useRobotJobProgress(jobId: string | null): {
    job: RobotJob | null
    items: RobotJobItem[]
    successCount: number
    errorCount: number
    totalItems: number
    isComplete: boolean
    isLoading: boolean
  }
  ```

  **Implementation:**

  1. State:
     - `job: RobotJob | null` (initially null)
     - `items: RobotJobItem[]` (initially empty)
     - `isLoading: boolean` (initially true when jobId provided)

  2. Initial data fetch (useEffect on jobId change):
     - When jobId changes from null to a value, call `getJobStatus()` server action to get current state.
     - This handles the reconnect scenario (user leaves page and comes back during active job).
     - Set job and items state from the result.
     - Set isLoading to false.

  3. Realtime subscription (useEffect on jobId change):
     - If jobId is null, clean up any existing subscription and return.
     - Create Supabase browser client via `createClient()` from `@/lib/supabase/client`.
     - Subscribe to channel `robot-job:${jobId}` with TWO listeners:

     **Listener A: robot_job_items changes**
     ```typescript
     .on('postgres_changes', {
       event: '*',
       schema: 'public',
       table: 'robot_job_items',
       filter: `job_id=eq.${jobId}`,
     }, handleItemChange)
     ```
     The `handleItemChange` callback updates the items array using surgical update:
     - If item exists in array (match by id), replace it.
     - If item doesn't exist, append it.
     - Use `setItems()` with functional updater to avoid stale closure.

     **Listener B: robot_jobs changes**
     ```typescript
     .on('postgres_changes', {
       event: 'UPDATE',
       schema: 'public',
       table: 'robot_jobs',
       filter: `id=eq.${jobId}`,
     }, handleJobChange)
     ```
     The `handleJobChange` callback updates the job state.

     Both callbacks use the pattern from `use-conversations.ts`: functional state updaters + useRef for mutable references when needed.

  4. Cleanup:
     - On unmount or jobId change, call `supabase.removeChannel(channel)`.
     - Pattern: `return () => { supabase.removeChannel(channel) }`.

  5. Computed values (useMemo):
     - `successCount`: items.filter(i => i.status === 'success').length
     - `errorCount`: items.filter(i => i.status === 'error').length
     - `totalItems`: job?.total_items ?? 0
     - `isComplete`: job?.status === 'completed' || job?.status === 'failed'

  **IMPORTANT anti-stale-closure:**
  - Use `useRef` for items array if callbacks reference it inside subscription handler.
  - Prefer functional setters `setItems(prev => ...)` which always get latest state.
  - The functional setter approach is sufficient here since we're doing surgical updates, NOT reading existing state for logic decisions.

  **Import types:**
  - `RobotJob`, `RobotJobItem` from `@/lib/domain/robot-jobs`
  - `createClient` from `@/lib/supabase/client`
  - `getJobStatus` from `@/app/actions/comandos`
  </action>
  <verify>
  - `npx tsc --noEmit` passes
  - Hook file uses `'use client'` or is in hooks/ directory (client-only by convention)
  - Subscribes to both `robot_job_items` and `robot_jobs` tables
  - Cleanup removes channel on unmount
  - Initial fetch happens before Realtime subscription takes over
  - Functional setters used to avoid stale closures
  </verify>
  <done>Realtime hook provides live-updating job progress (items array, counters, completion status) via Supabase postgres_changes, with initial fetch for reconnect scenarios.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Server action `executeSubirOrdenesCoord` composes: credentials -> dispatch stage -> orders -> validate cities -> create job -> build PedidoInput -> Inngest dispatch
3. Realtime hook subscribes to both job items AND job status changes
4. buildPedidoInputFromOrder uses sensible defaults (peso=1, dimensions=10x10x10, COD=false)
5. All functions use proper auth patterns (server action = cookies auth, domain = admin client)
</verification>

<success_criteria>
- `subir ordenes coord` flow works end-to-end: reads dispatch stage config, fetches orders, validates cities, creates job, builds PedidoInput, dispatches to Inngest
- Invalid cities produce clear error reports with order name and reason
- Realtime hook receives per-item updates and job status changes
- Reconnect scenario works: fetch full state first, then overlay Realtime updates
</success_criteria>

<output>
After completion, create `.planning/phases/24-chat-de-comandos-ui/24-02-SUMMARY.md`
</output>
