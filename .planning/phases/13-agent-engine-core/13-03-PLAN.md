---
phase: 13-agent-engine-core
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/lib/agents/claude-client.ts
  - src/lib/agents/token-budget.ts
  - src/lib/agents/index.ts
autonomous: true
user_setup:
  - service: anthropic
    why: "Claude API for agent intelligence"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "Anthropic Console -> API Keys -> Create Key"

must_haves:
  truths:
    - "Claude API can be called for intent detection"
    - "Claude API can be called for orchestration with tools"
    - "Streaming responses are supported"
    - "Token budget is tracked and enforced per session"
  artifacts:
    - path: "src/lib/agents/claude-client.ts"
      provides: "ClaudeClient with detectIntent, orchestrate, streamResponse methods"
      exports: ["ClaudeClient"]
    - path: "src/lib/agents/token-budget.ts"
      provides: "TokenBudgetManager with getUsage, checkBudget, recordUsage methods"
      exports: ["TokenBudgetManager"]
  key_links:
    - from: "src/lib/agents/claude-client.ts"
      to: "@anthropic-ai/sdk"
      via: "Anthropic class instantiation"
      pattern: "new Anthropic"
    - from: "src/lib/agents/token-budget.ts"
      to: "agent_turns table"
      via: "Supabase query for tokens_used"
      pattern: "from\\('agent_turns'\\)"
---

<objective>
Create Claude API client and token budget manager.

Purpose: The ClaudeClient wraps the Anthropic SDK for agent-specific needs (intent detection, orchestration, streaming). The TokenBudgetManager tracks and enforces the 50K token limit per conversation to prevent runaway costs.

Output: ClaudeClient class with methods for each agent component, TokenBudgetManager for budget enforcement.
</objective>

<execution_context>
@/home/jose147/.claude/get-shit-done/workflows/execute-plan.md
@/home/jose147/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/13-agent-engine-core/13-CONTEXT.md
@.planning/phases/13-agent-engine-core/13-RESEARCH.md
@.planning/phases/13-agent-engine-core/13-01-SUMMARY.md

# Types from Plan 01
@src/lib/agents/types.ts
@src/lib/agents/errors.ts

# Tool registry for tool definitions
@src/lib/tools/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Anthropic SDK and create Claude Client</name>
  <files>src/lib/agents/claude-client.ts</files>
  <action>
First, install the Anthropic SDK:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npm install @anthropic-ai/sdk
```

Then create the Claude client:

```typescript
/**
 * Claude Client
 * Phase 13: Agent Engine Core
 *
 * Wrapper around the Anthropic SDK for agent-specific needs.
 * Handles intent detection, orchestration, and streaming responses.
 */

import Anthropic from '@anthropic-ai/sdk'
import { toolRegistry } from '@/lib/tools/registry'
import type {
  ClaudeModel,
  ClaudeMessage,
  ClaudeContentBlock,
  IntentResult,
  OrchestratorResult,
  SessionState,
  ToolCallRequest,
} from './types'
import { ClaudeApiError, IntentDetectionError } from './errors'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('claude-client')

/** Map of model IDs to Anthropic API model strings */
const MODEL_MAP: Record<ClaudeModel, string> = {
  'claude-haiku-4-5': 'claude-sonnet-4-5-20250514', // Using Sonnet as Haiku 4.5 not yet available
  'claude-sonnet-4-5': 'claude-sonnet-4-5-20250514',
}

/**
 * Client for interacting with Claude API.
 *
 * Provides specialized methods for:
 * - Intent detection (fast, cheap with Haiku)
 * - Orchestration (intelligent with Sonnet, tool use)
 * - Streaming responses
 *
 * Tool names are converted between Action DSL format (dots) and
 * Claude format (underscores) automatically.
 */
export class ClaudeClient {
  private client: Anthropic

  constructor(apiKey?: string) {
    this.client = new Anthropic({
      apiKey: apiKey ?? process.env.ANTHROPIC_API_KEY,
    })
  }

  // ============================================================================
  // Intent Detection
  // ============================================================================

  /**
   * Detect intent from customer message.
   *
   * Uses a fast model (Haiku) to classify the message and return
   * confidence score with alternatives.
   *
   * @returns IntentResult with confidence 0-100
   */
  async detectIntent(
    systemPrompt: string,
    conversationHistory: ClaudeMessage[],
    currentMessage: string,
    model: ClaudeModel = 'claude-haiku-4-5'
  ): Promise<{ result: IntentResult; tokensUsed: number }> {
    logger.debug(
      { model, messageLength: currentMessage.length },
      'Detecting intent'
    )

    try {
      const response = await this.client.messages.create({
        model: MODEL_MAP[model],
        max_tokens: 500,
        system: systemPrompt,
        messages: [
          ...this.convertToAnthropicMessages(conversationHistory),
          { role: 'user', content: currentMessage },
        ],
      })

      const text = this.extractText(response.content)
      const result = this.parseIntentResponse(text)
      const tokensUsed = response.usage.input_tokens + response.usage.output_tokens

      logger.info(
        { intent: result.intent, confidence: result.confidence, tokensUsed },
        'Intent detected'
      )

      return { result, tokensUsed }
    } catch (error) {
      if (error instanceof Anthropic.APIError) {
        throw new ClaudeApiError(
          `Intent detection failed: ${error.message}`,
          error.status,
          error.message
        )
      }
      throw error
    }
  }

  /**
   * Parse the intent response from Claude.
   * Expects JSON format, falls back to unknown intent if parsing fails.
   */
  private parseIntentResponse(text: string): IntentResult {
    // Try to extract JSON from the response
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      try {
        const parsed = JSON.parse(jsonMatch[0])
        return {
          intent: parsed.intent ?? 'unknown',
          confidence: typeof parsed.confidence === 'number' ? parsed.confidence : 0,
          alternatives: Array.isArray(parsed.alternatives) ? parsed.alternatives : undefined,
          reasoning: parsed.reasoning,
        }
      } catch {
        // Fall through to default
      }
    }

    // Fallback: could not parse JSON
    logger.warn({ rawText: text.substring(0, 200) }, 'Failed to parse intent JSON')
    return {
      intent: 'unknown',
      confidence: 0,
      reasoning: text,
    }
  }

  // ============================================================================
  // Orchestration
  // ============================================================================

  /**
   * Orchestrate the agent response.
   *
   * Uses a more capable model (Sonnet) to decide what action to take
   * based on the detected intent, session state, and conversation history.
   * Can request tool execution.
   *
   * @returns OrchestratorResult with action and optional tool calls
   */
  async orchestrate(
    systemPrompt: string,
    conversationHistory: ClaudeMessage[],
    intentResult: IntentResult,
    sessionState: SessionState,
    toolNames: string[],
    model: ClaudeModel = 'claude-sonnet-4-5'
  ): Promise<{ result: OrchestratorResult; tokensUsed: number }> {
    logger.debug(
      { model, intent: intentResult.intent, toolCount: toolNames.length },
      'Orchestrating response'
    )

    // Build context message with intent and state
    const contextMessage = this.buildOrchestratorContext(intentResult, sessionState)

    // Convert tool names to Claude tool definitions
    const tools = this.buildToolDefinitions(toolNames)

    try {
      const response = await this.client.messages.create({
        model: MODEL_MAP[model],
        max_tokens: 2000,
        system: systemPrompt,
        tools,
        messages: [
          ...this.convertToAnthropicMessages(conversationHistory),
          { role: 'user', content: contextMessage },
        ],
      })

      const result = this.parseOrchestratorResponse(response)
      const tokensUsed = response.usage.input_tokens + response.usage.output_tokens

      logger.info(
        {
          action: result.action,
          toolCallCount: result.toolCalls?.length ?? 0,
          tokensUsed,
        },
        'Orchestration complete'
      )

      return { result, tokensUsed }
    } catch (error) {
      if (error instanceof Anthropic.APIError) {
        throw new ClaudeApiError(
          `Orchestration failed: ${error.message}`,
          error.status,
          error.message
        )
      }
      throw error
    }
  }

  /**
   * Build context message for orchestrator.
   * Includes intent result and current session state.
   */
  private buildOrchestratorContext(
    intent: IntentResult,
    state: SessionState
  ): string {
    return JSON.stringify({
      intent: intent.intent,
      confidence: intent.confidence,
      alternatives: intent.alternatives,
      session_state: {
        current_mode: 'from session',  // Filled by engine
        intents_vistos: state.intents_vistos,
        templates_enviados: state.templates_enviados,
        datos_capturados: state.datos_capturados,
        pack_seleccionado: state.pack_seleccionado,
      },
    }, null, 2)
  }

  /**
   * Parse orchestrator response from Claude.
   * Extracts tool use blocks or text response.
   */
  private parseOrchestratorResponse(
    response: Anthropic.Message
  ): OrchestratorResult {
    const content = response.content

    // Check for tool_use blocks
    const toolUses = content.filter(
      (block): block is Anthropic.ToolUseBlock => block.type === 'tool_use'
    )

    if (toolUses.length > 0) {
      return {
        action: 'execute_tool',
        toolCalls: toolUses.map((tu) => ({
          // Convert underscores back to dots for Action DSL
          name: tu.name.replace(/_/g, '.'),
          input: tu.input as Record<string, unknown>,
        })),
      }
    }

    // Extract text response
    const textBlock = content.find(
      (block): block is Anthropic.TextBlock => block.type === 'text'
    )

    // Try to parse structured response from text
    const text = textBlock?.text ?? ''
    const jsonMatch = text.match(/\{[\s\S]*\}/)
    if (jsonMatch) {
      try {
        const parsed = JSON.parse(jsonMatch[0])
        return {
          action: parsed.action ?? 'proceed',
          response: parsed.response ?? text,
          nextMode: parsed.nextMode,
        }
      } catch {
        // Fall through to default
      }
    }

    return {
      action: 'proceed',
      response: text,
    }
  }

  // ============================================================================
  // Streaming
  // ============================================================================

  /**
   * Stream a response from Claude.
   *
   * Useful for generating customer-facing responses where
   * we want to show progress.
   */
  async streamResponse(
    systemPrompt: string,
    conversationHistory: ClaudeMessage[],
    model: ClaudeModel = 'claude-sonnet-4-5',
    onText: (text: string) => void
  ): Promise<{ fullText: string; tokensUsed: number }> {
    logger.debug({ model }, 'Starting streaming response')

    let fullText = ''

    try {
      const stream = this.client.messages.stream({
        model: MODEL_MAP[model],
        max_tokens: 2000,
        system: systemPrompt,
        messages: this.convertToAnthropicMessages(conversationHistory),
      })

      stream.on('text', (text) => {
        fullText += text
        onText(text)
      })

      const finalMessage = await stream.finalMessage()
      const tokensUsed = finalMessage.usage.input_tokens + finalMessage.usage.output_tokens

      logger.info(
        { textLength: fullText.length, tokensUsed },
        'Streaming complete'
      )

      return { fullText, tokensUsed }
    } catch (error) {
      if (error instanceof Anthropic.APIError) {
        throw new ClaudeApiError(
          `Streaming failed: ${error.message}`,
          error.status,
          error.message
        )
      }
      throw error
    }
  }

  // ============================================================================
  // Tool Definition Building
  // ============================================================================

  /**
   * Build Claude tool definitions from Action DSL tool names.
   *
   * Converts tool names from dot notation (crm.contact.create)
   * to underscore notation (crm_contact_create) for Claude.
   */
  buildToolDefinitions(toolNames: string[]): Anthropic.Tool[] {
    return toolNames.map((name) => {
      const tool = toolRegistry.getTool(name)
      if (!tool) {
        logger.warn({ toolName: name }, 'Tool not found in registry')
        return {
          name: name.replace(/\./g, '_'),
          description: `Tool ${name} (not found in registry)`,
          input_schema: { type: 'object', properties: {} },
        }
      }

      return {
        // Claude tool names cannot contain dots
        name: name.replace(/\./g, '_'),
        description: tool.metadata.description,
        input_schema: tool.schema.inputSchema as Anthropic.Tool['input_schema'],
      }
    })
  }

  // ============================================================================
  // Helpers
  // ============================================================================

  /**
   * Convert our ClaudeMessage format to Anthropic SDK format.
   */
  private convertToAnthropicMessages(
    messages: ClaudeMessage[]
  ): Anthropic.MessageParam[] {
    return messages.map((msg) => ({
      role: msg.role,
      content: typeof msg.content === 'string'
        ? msg.content
        : this.convertContentBlocks(msg.content),
    }))
  }

  /**
   * Convert content blocks to Anthropic format.
   */
  private convertContentBlocks(
    blocks: ClaudeContentBlock[]
  ): Anthropic.ContentBlockParam[] {
    return blocks.map((block) => {
      if (block.type === 'text') {
        return { type: 'text', text: block.text ?? '' }
      }
      if (block.type === 'tool_use') {
        return {
          type: 'tool_use',
          id: block.id ?? '',
          name: block.name ?? '',
          input: block.input ?? {},
        }
      }
      if (block.type === 'tool_result') {
        return {
          type: 'tool_result',
          tool_use_id: block.tool_use_id ?? '',
          content: block.content ?? '',
          is_error: block.is_error ?? false,
        }
      }
      return { type: 'text', text: '' }
    })
  }

  /**
   * Extract text from Claude response content blocks.
   */
  private extractText(content: Anthropic.ContentBlock[]): string {
    return content
      .filter((block): block is Anthropic.TextBlock => block.type === 'text')
      .map((block) => block.text)
      .join('')
  }
}
```

Key implementation notes:
- MODEL_MAP handles model ID translation (Haiku 4.5 not yet available, using Sonnet as fallback)
- Tool names converted: dots -> underscores for Claude, underscores -> dots for Action DSL
- Intent parsing handles JSON extraction with fallback
- Orchestrator can return tool calls or text responses
- Streaming uses SDK's stream() method with event callbacks
- All errors wrapped in ClaudeApiError for consistent handling
  </action>
  <verify>
Check npm install succeeded:
```bash
cat /mnt/c/Users/Usuario/Proyectos/morfx-new/package.json | grep "@anthropic-ai/sdk"
```
TypeScript compilation:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/claude-client.ts
```
Check main methods exist:
```bash
grep -E "async (detectIntent|orchestrate|streamResponse)" src/lib/agents/claude-client.ts
```
  </verify>
  <done>
- @anthropic-ai/sdk installed
- ClaudeClient class with detectIntent method using fast model
- ClaudeClient.orchestrate method with tool use support
- ClaudeClient.streamResponse for streaming output
- Tool name conversion (dots <-> underscores) implemented
- Intent JSON parsing with fallback handling
- All errors wrapped in ClaudeApiError
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Token Budget Manager</name>
  <files>
src/lib/agents/token-budget.ts
src/lib/agents/index.ts
  </files>
  <action>
Create the TokenBudgetManager:

```typescript
/**
 * Token Budget Manager
 * Phase 13: Agent Engine Core
 *
 * Tracks and enforces token limits per conversation.
 * Prevents runaway costs by checking budget before each Claude call.
 */

import { createAdminClient } from '@/lib/supabase/admin'
import type { TokenUsage } from './types'
import { MAX_TOKENS_PER_CONVERSATION } from './types'
import { BudgetExceededError } from './errors'
import { createModuleLogger } from '@/lib/audit/logger'

const logger = createModuleLogger('token-budget')

/** Budget check result */
export interface BudgetCheckResult {
  allowed: boolean
  remaining: number
  used: number
  estimatedAfter: number
}

/**
 * Manages token budgets for agent sessions.
 *
 * Each session has a maximum token budget (default 50K).
 * Budget is checked before each Claude call and recorded after.
 *
 * Usage:
 * ```typescript
 * const budget = new TokenBudgetManager()
 *
 * // Before calling Claude
 * const check = await budget.checkBudget(sessionId, 2000)
 * if (!check.allowed) {
 *   // Handle budget exceeded
 * }
 *
 * // After calling Claude
 * await budget.recordUsage(sessionId, turnId, actualTokensUsed)
 * ```
 */
export class TokenBudgetManager {
  private supabase = createAdminClient()
  private maxTokens: number

  constructor(maxTokens: number = MAX_TOKENS_PER_CONVERSATION) {
    this.maxTokens = maxTokens
  }

  /**
   * Get current token usage for a session.
   */
  async getUsage(sessionId: string): Promise<TokenUsage> {
    const { data, error } = await this.supabase
      .from('agent_turns')
      .select('tokens_used')
      .eq('session_id', sessionId)

    if (error) {
      logger.error({ error, sessionId }, 'Failed to get token usage')
      throw new Error(`Failed to get token usage: ${error.message}`)
    }

    const totalTokens = data?.reduce((sum, turn) => sum + (turn.tokens_used ?? 0), 0) ?? 0
    const turnCount = data?.length ?? 0
    const remaining = this.maxTokens - totalTokens

    return {
      sessionId,
      totalTokens,
      turnCount,
      remaining,
    }
  }

  /**
   * Check if a session has budget for an estimated token usage.
   *
   * @param sessionId The session to check
   * @param estimatedTokens Estimated tokens for the upcoming operation
   * @returns Budget check result with allowed flag
   */
  async checkBudget(
    sessionId: string,
    estimatedTokens: number
  ): Promise<BudgetCheckResult> {
    const usage = await this.getUsage(sessionId)
    const estimatedAfter = usage.totalTokens + estimatedTokens
    const allowed = estimatedAfter <= this.maxTokens

    if (!allowed) {
      logger.warn(
        {
          sessionId,
          used: usage.totalTokens,
          estimated: estimatedTokens,
          limit: this.maxTokens,
        },
        'Token budget would be exceeded'
      )
    }

    return {
      allowed,
      remaining: usage.remaining,
      used: usage.totalTokens,
      estimatedAfter,
    }
  }

  /**
   * Check budget and throw if exceeded.
   * Convenience method for strict enforcement.
   */
  async requireBudget(
    sessionId: string,
    estimatedTokens: number
  ): Promise<BudgetCheckResult> {
    const check = await this.checkBudget(sessionId, estimatedTokens)

    if (!check.allowed) {
      throw new BudgetExceededError(sessionId, check.used, this.maxTokens)
    }

    return check
  }

  /**
   * Record token usage for a turn.
   * Called after a Claude call completes.
   */
  async recordUsage(
    sessionId: string,
    turnId: string,
    tokensUsed: number
  ): Promise<void> {
    const { error } = await this.supabase
      .from('agent_turns')
      .update({ tokens_used: tokensUsed })
      .eq('id', turnId)

    if (error) {
      logger.error({ error, sessionId, turnId }, 'Failed to record token usage')
      throw new Error(`Failed to record token usage: ${error.message}`)
    }

    logger.debug(
      { sessionId, turnId, tokensUsed },
      'Token usage recorded'
    )
  }

  /**
   * Get remaining budget percentage.
   * Useful for warning messages.
   */
  async getRemainingPercentage(sessionId: string): Promise<number> {
    const usage = await this.getUsage(sessionId)
    return Math.max(0, Math.round((usage.remaining / this.maxTokens) * 100))
  }

  /**
   * Check if session is near budget limit.
   * Returns true if less than 10% budget remaining.
   */
  async isNearLimit(sessionId: string): Promise<boolean> {
    const percentage = await this.getRemainingPercentage(sessionId)
    return percentage < 10
  }

  /**
   * Get budget summary for logging/debugging.
   */
  async getSummary(sessionId: string): Promise<{
    used: number
    remaining: number
    percentage: number
    turnCount: number
  }> {
    const usage = await this.getUsage(sessionId)
    const percentage = Math.round((usage.remaining / this.maxTokens) * 100)

    return {
      used: usage.totalTokens,
      remaining: usage.remaining,
      percentage,
      turnCount: usage.turnCount,
    }
  }
}
```

**Update src/lib/agents/index.ts to add exports:**

Add to existing exports:
```typescript
// Claude Client
export { ClaudeClient } from './claude-client'

// Token Budget
export { TokenBudgetManager } from './token-budget'
export type { BudgetCheckResult } from './token-budget'
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit src/lib/agents/token-budget.ts
```
Check TokenBudgetManager methods:
```bash
grep -E "async (getUsage|checkBudget|requireBudget|recordUsage)" src/lib/agents/token-budget.ts
```
Verify index exports:
```bash
grep -E "ClaudeClient|TokenBudgetManager" src/lib/agents/index.ts
```
  </verify>
  <done>
- TokenBudgetManager with getUsage, checkBudget, requireBudget, recordUsage
- BudgetExceededError thrown when budget would be exceeded
- getRemainingPercentage and isNearLimit for monitoring
- getSummary for debugging
- Exports added to index.ts
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Anthropic SDK installed:
```bash
cat /mnt/c/Users/Usuario/Proyectos/morfx-new/package.json | grep "anthropic"
```

2. ClaudeClient exports verified:
```bash
grep "export class ClaudeClient" src/lib/agents/claude-client.ts
```

3. TokenBudgetManager exports verified:
```bash
grep "export class TokenBudgetManager" src/lib/agents/token-budget.ts
```

4. All exports in index.ts:
```bash
grep -E "export.*from" src/lib/agents/index.ts
```

5. TypeScript compiles:
```bash
cd /mnt/c/Users/Usuario/Proyectos/morfx-new && npx tsc --noEmit
```
</verification>

<success_criteria>
- @anthropic-ai/sdk installed in package.json
- ClaudeClient.detectIntent returns IntentResult with confidence
- ClaudeClient.orchestrate handles tool use responses
- ClaudeClient.streamResponse provides streaming output
- Tool names correctly converted between dot and underscore notation
- TokenBudgetManager tracks usage per session
- TokenBudgetManager.checkBudget enforces 50K limit
- BudgetExceededError thrown when limit exceeded
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-agent-engine-core/13-03-SUMMARY.md`
</output>
